{"meta":{"title":"SUMSC","subtitle":"计算机爱好者协会（微软学生俱乐部）","description":"计算机爱好者协会（微软学生俱乐部）主页","author":"SUMSC","url":"https://sumsc-caa.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-02-26T04:10:38.892Z","updated":"2023-02-26T04:10:38.892Z","comments":false,"path":"/404.html","permalink":"https://sumsc-caa.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-02-26T04:10:38.892Z","updated":"2023-02-26T04:10:38.892Z","comments":false,"path":"about/index.html","permalink":"https://sumsc-caa.github.io/about/index.html","excerpt":"","text":"我们是谁？ 我们是苏州大学计算机爱好者协会（微软学生俱乐部）。 计算机爱好者协会是苏州大学计算机科学与技术学院的学术性社团，为 2015 年与微软亚洲研究院联合成立的苏州大学微软学生俱乐部，现为微软开源学习社群（MOSC）的联络社团。 团队成员 主席：张昊 首席技术官：刘轩良 联系我们 微信公众平台：SUMSTC 俱乐部 QQ 群：497516494 Bilibili：苏州大学微软俱乐部 GitHub Organization：SUMSC Location：苏州大学天赐庄校区理工楼 110 室 历史缘由 计算机爱好者协会是苏州大学计算机科学与技术学院的学术性社团，为 2015 年与微软亚洲研究院联合成立的苏州大学微软学生俱乐部，现为微软开源学习社群的联络社团。 我们采用线上开源社群+线下技术学习社团的模式，通过课程共建、知识共享、团队共创，培养社团成员的开源思想、创新头脑、实践能力和组织能力，助力所有学生从开源社区同获益、共成长。 我们是一个充满热情，富有开拓精神的新锐团体，在对技术保持的严谨的同时也不缺乏乐观活泼的生活态度。 我们本着“学习先进技术，开拓创新思维，体验多元文化，成就一流人才”的宗旨，通过学术讲座、技术沙龙、兴趣小组、大型比赛、参观访问等活动，为会员提供开阔视野，探索前沿 IT 技术，接触最新学术成果，培养管理能力的机会，培养会员的创新头脑、实践能力和组织能力，让来自不同领域的同学得以展现才华，共同成长，为学生的成长提供良好的平台，为顶尖人才培养贡献一份力量。 “予力每一位成员，成就非凡！” 什么是 MOSC 微软开源学习社群（Microsoft Open-source Study Community）脱胎于原微软学生俱乐部，是微软亚洲研究院对高校人才培养的进一步探索。社群以分布在各高校的联络社团成员为核心，以开源平台和社区为基础，通过课程共建、知识共享、团队共创的形式，培养社群成员的开源思想、创新头脑、实践能力和组织能力，并助力所有学生 从开源社区同获益、共成长。"},{"title":"分类","date":"2023-02-26T04:10:38.892Z","updated":"2023-02-26T04:10:38.892Z","comments":false,"path":"categories/index.html","permalink":"https://sumsc-caa.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-26T04:10:38.892Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"links/index.html","permalink":"https://sumsc-caa.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-26T04:10:38.892Z","updated":"2023-02-26T04:10:38.892Z","comments":false,"path":"repository/index.html","permalink":"https://sumsc-caa.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-26T04:10:38.892Z","updated":"2023-02-26T04:10:38.892Z","comments":false,"path":"tags/index.html","permalink":"https://sumsc-caa.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"技术赋能#2：Python可迭代对象的相关函数（1）","slug":"techpost-2022-2","date":"2022-11-18T08:23:48.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/11/18/techpost-2022-2/","link":"","permalink":"https://sumsc-caa.github.io/2022/11/18/techpost-2022-2/","excerpt":"","text":"Python内置了许多有用的工具函数与类，用于处理可迭代对象与迭代器产生的数据流。本文将对这些工具函数或类作简要介绍，包括map，filter，enumerate，zip，sum，all/any，min/max，sorted。 本文是本系列的上一篇文章“技术赋能#1：Python的可迭代对象、迭代器与生成器”的延续，建议先了解这一篇再继续阅读。 map函数 map是Python中常用的一个函数（类），它接受一个函数与一个或多个可迭代对象作为输入，并输出一个迭代器（map实例）。 例如，当我们需要得到一个数列的平方时，我们可以使用map函数这样编写代码： 1234567&gt;&gt;&gt; def square(x):... return x**2&gt;&gt;&gt; m = map(square, range(10))&gt;&gt;&gt; for i in m:... print(i, end=&quot; &quot;)... 0 1 4 9 16 25 36 49 64 81 这样写有点繁琐了，为了简化下文的代码，本文将使用Python提供的“lambda表达式（匿名函数）”与“序列解包”两个语法。上面的代码等价于： 12&gt;&gt;&gt; print(*map(lambda x: x**2, range(10)))0 1 4 9 16 25 36 49 64 81 上面提到的两种语法如果你没学到也没关系，你只需要知道lambda x: x**2和前面的square函数的定义相同，print和*+可迭代对象可以代替上面的那个循环。 如果设输入map的第一个参数为函数f(x)f(x)f(x)，第二个参数为数列⟨a1,a2,…,an⟩\\langle a_1, a_2, \\ldots, a_n\\rangle⟨a1​,a2​,…,an​⟩，则这个map调用的输出为⟨f(a1),f(a2),…,f(an)⟩\\langle f(a_1), f(a_2), \\ldots, f(a_n)\\rangle⟨f(a1​),f(a2​),…,f(an​)⟩。在上面的例子中，数列{ai}\\{a_i\\}{ai​}为 0-9 的自然数列，函数 f(x)=x2f(x)=x^2f(x)=x2 ，因此输出是 0-9 内各个自然数的平方。 当然，在Python中map接受的序列（可迭代对象）当然不止数列，字符串与字符串序列也是可以的，下面这个例子将列表与字符串中的小写字母全部转化成大写字母（字符串也是可迭代对象哦）： 1234&gt;&gt;&gt; print(*map(lambda s:s.upper(), [&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;]))ALPHA BETA GAMMA&gt;&gt;&gt; print(*map(lambda s:s.upper(), &quot;Alpha&quot;))A L P H A 此外，输入和输出不一定要保持相同的数据类型，这一段代码可以将输入的字符串形式的数字转化为整型变量的序列： 12&gt;&gt;&gt; print(*map(int, &quot;1,1,2,3,5,8,13,21&quot;.split(&quot;,&quot;)))1 1 2 3 5 8 13 21 上文提到，map也可以接受多个可迭代对象作为输入，此时函数f的参数数量需要与可迭代对象的数量相同，当多个输入序列长度不一样时，输出序列的长度与较短的序列的相同。这个例子使用map函数将两个序列对应位置的数相乘： 12&gt;&gt;&gt; print(*map(lambda x,y: x*y, [1,2,3,4,5], [6,7,8,9,10,11]))6 14 24 36 50 filter函数 filter的参数形式与map相似，其接受一个函数f与一个可迭代对象作为输入，输出一个迭代器（filter实例）。其中输入函数f的返回值必须是布尔类型（True/False）或是能隐式转换为布尔类型，函数值为True的值将留在输出序列中，为False的值将被筛去。下面两个例子分别筛选出了输入序列中的偶数与素数（O(n2)O(n^2)O(n2)的暴力算法，考试时不要使用哦）： 1234&gt;&gt;&gt; print(*filter(lambda n:n%2==0, range(20)))0 2 4 6 8 10 12 14 16 18&gt;&gt;&gt; print(*filter(lambda n: n==2 or n&gt;2 and all(n%i for i in range(2,int(n**0.5)+1)), range(100)))2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 enumerate函数 enumerate函数也是Python中很常用的一个函数，它接受一个可迭代对象和一个可选参数start作为输入，返回值是元组的可迭代对象，每个元组的第二项为原序列的内容，第一项为这一项在序列中的编号。在Python中它常常伴随for循环出现，例如： 123456789&gt;&gt;&gt; lst = [&quot;apple&quot;, &quot;pear&quot;, &quot;peach&quot;, &quot;banana&quot;, &quot;grape&quot;]&gt;&gt;&gt; for i, name in enumerate(lst):... print(i, name)... 0 apple1 pear2 peach3 banana4 grape 可选参数start制定了初始的计数值，默认为0： 12345678&gt;&gt;&gt; for i, name in enumerate(lst, start=5):... print(i, name)... 5 apple6 pear7 peach8 banana9 grape zip函数 zip函数用于对多个可迭代对象进行打包，对于输入序列⟨a1,a2,…,an⟩\\langle a_1,a_2,\\ldots,a_n\\rangle⟨a1​,a2​,…,an​⟩与⟨b1,b2,…,bn,…,bn+t⟩\\langle b_1,b_2,\\ldots,b_n,\\ldots,b_{n+t}\\rangle⟨b1​,b2​,…,bn​,…,bn+t​⟩，zip函数将对应位置的值打包成元组返回，并丢弃多余的值，即返回⟨(a1,b1), (a2,b2), …, (an,bn)⟩\\langle (a_1,b_1),~(a_2,b_2),~\\ldots,~(a_n,b_n)\\rangle⟨(a1​,b1​), (a2​,b2​), …, (an​,bn​)⟩ 12&gt;&gt;&gt; print(*zip(range(0,10,2), range(1,13,2)))(0, 1) (2, 3) (4, 5) (6, 7) (8, 9) sum函数 顾名思义，sum函数对输入的可迭代对象求和，例如： 12&gt;&gt;&gt; sum(range(1,101))5050 all/any函数 all/any函数都接受一个可迭代对象作为输入，要求这个可迭代对象内的值可以被隐式转化为布尔值，返回值为单个布尔值。all函数在逻辑上与多项的and（与逻辑）相同，当且仅当可迭代对象内的所有值都为True或相当于True时返回True，否则返回False。any函数则在逻辑上与or（或逻辑）相同，当可迭代对象内存在True时就返回True，否则（全为False时）返回False。 与Python的逻辑表达式（布尔表达式）相同，all与any函数也都是短路求值的，也就是说它们会在发现条件不满足时立刻返回（对于all来说就是第一次遇到False的时候），而不是过完整个序列。下面的这段代码演示了这一特性： 12345&gt;&gt;&gt; r = iter([5,4,3,2,1,0,-1,-2,-3])&gt;&gt;&gt; all(r) # 消耗 5,4,3,2,1,0 遇到0时直接返回FalseFalse&gt;&gt;&gt; print(*r) # 获取剩余值-1 -2 -3 此外，当输入序列为空时，all将返回True，any则返回False。 1234&gt;&gt;&gt; all([])True&gt;&gt;&gt; any([])False min/max函数 这两个函数都用于求序列中的极值，min返回最小值而max返回最大值。除了可迭代对象之外，它们还会接受可选参数key，key参数是一个函数，用法类似于下文的sorted的key参数，这里仅演示用法，例如： 123456&gt;&gt;&gt; min(map(abs, range(-15,11)))0&gt;&gt;&gt; max(map(abs, range(-15,11)))15&gt;&gt;&gt; max(range(-15,11), key=abs)-15 sorted函数 sorted函数对输入序列非原地排序，其返回值一定是一个排好序的列表，除了可迭代对象之外，它还接受reverse与key两个参数。reverse参数指定是否逆序排序，这个很好理解；而key参数接受的是一个函数，这个函数接受输入序列中的值作为输入，返回一个有序对象（例如数值、字符串等），sorted函数将以返回的有序对象作为排序的标准。 在下面的示例中，第一个sorted调用对lst顺序排序，第二个对其逆序排序，第三个以每个值的绝对值作为标准进行排序（绝对值小的排在前面），第四个以 f(x)=(x−2.2)2f(x)=(x-2.2)^2f(x)=(x−2.2)2 为标准排序。需要分组排序时，可以让key参数接受的函数返回一个元组，例如第五个sorted调用，先按照每个数除以3的余数分组，然后对每一组按值的大小逆序排序。 Python采用的Timsort算法是稳定排序算法，也就是说标准值相同的对象会按照它们在原序列中的顺序排序（相对位置保持不变），例如第三个示例中-3与3的绝对值相同，但是原序列中-3在前面，所以输出的列表中-3也在3的前面。 1234567891011&gt;&gt;&gt; lst = [1,-3,2,5,4,-1,-2,-4,3,0]&gt;&gt;&gt; sorted(lst) #1[-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]&gt;&gt;&gt; sorted(lst, reverse=True) #2[5, 4, 3, 2, 1, 0, -1, -2, -3, -4]&gt;&gt;&gt; sorted(lst, key=abs) #3[0, 1, -1, 2, -2, -3, 3, 4, -4, 5]&gt;&gt;&gt; sorted(lst, key=lambda x:(x-2.2)**2) #4[2, 3, 1, 4, 0, 5, -1, -2, -3, -4]&gt;&gt;&gt; sorted(range(15), key=lambda x:(x%3, -x)) #5[12, 9, 6, 3, 0, 13, 10, 7, 4, 1, 14, 11, 8, 5, 2] 本文介绍了Python内置的一些与可迭代对象有关的函数以及它们的使用方法，在本系列的下一篇文章内我们将介绍Python标准库中的itertools库，它提供了更多与可迭代对象有关的功能，敬请期待！","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"}]},{"title":"2022 Hackathon: 字符画与康威生命游戏","slug":"hackathon2022-2","date":"2022-11-04T18:30:03.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/11/04/hackathon2022-2/","link":"","permalink":"https://sumsc-caa.github.io/2022/11/04/hackathon2022-2/","excerpt":"","text":"苏州大学计算机爱好者协会 Hackathon 2022 赛题 以下两题请任选一题完成： Q1: 字符画 背景 字符画/ASCII艺术，是指在计算机中使用字符组成图片的一种艺术形式。其大致可以分为以下几种： 西方式表情符号：受限于ASCII字符集，其组成的图像与表达的意思都较为简单，通常需要旋转90°阅读。 东方式表情符号/颜文字：得益于东方语言丰富的字符与标点符号，其在形式和含义上都较前者更加复杂。 (⁄ ⁄•⁄ω⁄•⁄ ⁄) (≧∇≦)/ ∩(·ω·)∩ (Ｔ▽Ｔ) (._.)~ (=・・=) (－‸ლ) （ ﾟ Дﾟ) (づ￣ ³￣)づ (ノಠ益ಠ)ノ彡┻━┻ ┬─┬ノ( º _ ºノ) 以上二者都是单行的字符画，常在社交平台上的日常对话中被使用（不过近几年国内外emoji和表情包等图片式表情符号的发展使它们日渐式微）。 打字机风格/打字机艺术（Typewriter Art）：这是最早的字符画之一，下图中展示了1875年1月6日美国一份报纸上刊登的广告（来源：wikipedia - ASCII art），它们都利用打字机艺术使广告引人注目。 灰度字符画：即按照相同大小的不同ASCII字符所占面积组成灰度级，并用这些灰度级组合成一张图片。下图为这种形式的土星（来源：ASCII art）。在支持对单个字符指定颜色的软件内，这种方式也可以被用来制作彩色字符画。 矢量字符画：这些字符画通常会在图中加入一些线形字符来对线条作视觉引导，并使用灰度字符画的方式对色块进行填充，下图为这种形式的初音未来（来源：Ascii Art Archives for Recycle）。 此外，这种形式也被用于制作命令行界面中展示的标题文字，且有各种风格。例如（来源：Text to ASCII Art Generator）： 题目 绘制一幅字符画，或者选择一幅你们喜欢的图片并将其转化为字符画。 编写程序，使其能自动将文字或图片转化为字符画，并尽可能优化结果的观感。你可以选择完善我们提供的示例程序。 【可选】改进程序，将生成的字符画渲染为 PNG/JPEG（位图）、html（网页）、pdf（文档）或svg（矢量图）等格式，使其在不同环境的呈现效果一致。 【可选】改进程序，使其能逐帧处理视频，并将结果渲染到视频内。 关于本题的帮助请参见：2022 Hackathon: 字符画 示例程序与帮助 参考资料 下面是可能有用的资料： Emojipedia（测试图片可以从这里获取） 方块元素 - 维基百科 ASCII艺术 - 维基百科 等宽字体 - 维基百科 Pillow 库官方文档 colorama 库 | Github svgwrite 库 | Github argparse - Python 3.11 官方文档 Text to ASCII Art Generator Jave：使用Java编写的字符画编辑器 HTML（超文本标记语言） | MDN HTML 简介 - 学习 Web 开发 | MDN Q2: 康威生命游戏 背景 康威生命游戏（Conway’s Game of Life），又称康威生命棋，是英国数学家 John Horton Conway 在1970年发明的元胞自动机。康威生命游戏在充分大的棋盘（模拟世界）上运行，棋盘的每个格子被称为一个细胞，对于棋盘内的每个细胞，只有五条规则： 每个细胞有存活与死亡两种状态，每个细胞只与以自身为中心的周围八格细胞产生互动； 当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态（模拟生命数量稀少）； 当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样； 当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态（模拟生命数量过多）； 当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态（模拟繁殖）。 整个游戏从t=0开始模拟，每一步模拟会对棋盘上所有细胞运用上述五条规则，得到下一步的棋盘。在这个游戏中，玩家是这个模拟世界里的神，可以旁观模拟世界内细胞的发展、随意向棋盘中添加、删除细胞，甚至是通过编程改变模拟世界的规则。 题目 我们编写了一个康威生命游戏的模拟程序，你可以在比赛中使用它，也可以随意更改代码实现你期望的效果。关于代码与使用说明请见：2022 Hackathon: 康威生命游戏 示例程序与使用说明 除了我们编写的模拟程序之外，你也可以使用其它模拟程序，例如： https://playgameoflife.com/ https://conwaylife.com/ https://wavjaby.github.io/GameOfLife/ https://github.com/thearn/game-of-life/ 以下是你在本题可以尝试探索的几个方向： 游玩康威生命游戏，并尝试在其中创建能稳定存在并增殖的生命（可以使用已发现的模式，见 https://conwaylife.com/wiki/ ）。 尝试构建高生存力的生命体，即最大化一定时间内增殖的细胞数与初始细胞数之比。 编写程序，修改或添加生命游戏的规则，例如： 改变基础规则的阈值； 扩大单个细胞的互动范围； 每过一定时间随机消灭世界内一半的活细胞； 改进程序或为程序添加功能，例如： 利用方块元素中的半高方块代替两个全高方块（也就是每一行字符对应模拟世界里的两行细胞），让程序可以在相同大小的命令行界面中展示四倍的细胞； 活细胞死亡后在地图上留下标记； 跟踪种群（初始状态聚集在一起的一群细胞）的发展，并使用颜色（colorama 库）标记不同种群（通过规则5诞生的细胞的颜色与周围细胞中占多数的颜色相同），这样可以展示不同种群争夺生存资源（地盘）的过程。 参考资料 LifeWiki Numpy 官方文档：英文 中文 argparse - Python 3.11 官方文档 colorama 库 | Github Conway’s Game of Life - Wikipedia 【科普】康威生命游戏——孤独会致命，拥挤也一样 - 知乎 比赛规则 本次比赛你可以查阅任意资料，但是请尽可能避免直接照搬网上的代码的情况。 请在星期日（7月6日）15:00之前完成你们的作品，期间你可以（非强制）在比赛场地（博远楼104-107）讨论交流与编写代码，会有工作人员现场负责技术指导。如果遇到了技术问题，你可以在比赛场地寻找技术指导，或是在比赛群内询问。7月6日15:00之后是作品展示环节，届时各组将上台展示作品、运行代码，并由评委对作品打分，打分的结果将作为最终成绩。 比赛期间请密切关注比赛群内的消息，关于比赛的任何消息我们都会在群内通知。","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"2022 Hackathon: 字符画 示例程序与帮助","slug":"hackathon2022-asciiart","date":"2022-11-04T18:30:02.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/11/04/hackathon2022-asciiart/","link":"","permalink":"https://sumsc-caa.github.io/2022/11/04/hackathon2022-asciiart/","excerpt":"","text":"&lt;&lt;&lt;&lt; 返回赛题 示例程序 在运行程序前需要安装依赖：numpy与Pillow，在命令提示符中输入：（不含$） 1$ pip install numpy Pillow 示例程序如下（在这里也可以下载），其中只实现了图片转灰度字符画的核心步骤，你可以完善该程序，优化生成的字符画的效果，或者参考在线资料从零编写自己的程序。 代码中使用的trophy.png是emoji“🏆”（奖杯）在微软的部分产品中的显示效果。生成字符画时需要对比明显、尺寸较小、色彩简单且边缘清晰的图像，所以选择了这张图作为演示。你可以在 Emojipedia中找到更多类似的图片作为测试图片。trophy.png如下： 对这个程序提出几点可改进之处，仅供参考： 【重要】查阅Pillow 库的官方文档，在生成字符画之前缩小图像到合适的尺寸 等宽字体中一个半角字符的宽高比大约是1:2，因此在横向需要用2个字符才能代替1个像素 对输入图像进行预处理，例如增强图像的对比度等 使用-\\|/等字符突出图像边缘 尝试使用方块元素代替ascii字符组成字符画 使用命令行参数控制程序（如另一题的gameofLife.py，可能会用到python标准库中的argparse模块） 使用colorama模块在命令行中创建彩色字符画","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"2022 Hackathon: 康威生命游戏 示例程序与使用说明","slug":"hackathon2022-gameoflife","date":"2022-11-04T18:30:01.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/11/04/hackathon2022-gameoflife/","link":"","permalink":"https://sumsc-caa.github.io/2022/11/04/hackathon2022-gameoflife/","excerpt":"","text":"&lt;&lt;&lt;&lt; 返回赛题 使用说明 获取程序 在本地新建python文件gameofLife.py，在IDE（VScode或pyCharm等）中打开此文件。前往“代码本体”一节获取程序源代码，并复制到该文件中。 安装依赖 在命令提示符中输入下列指令（不包括$）： 1$ pip install numpy 回车运行即可。 程序的使用方法 在命令行中使用cd指令切换到gameofLife.py所在目录，然后输入python gameofLife.py或python3 gameofLife.py即可运行程序。（命令行界面要求是等宽字体才能正常显示程序界面） 添加命令行参数-h可以看到程序的使用方法： 123456789101112131415161718$ python3 gameofLife.py -husage: gameoflife [-h] [-s W H] [-t T] [-e] [-f F] [-p P] [-w] [FILE]Simple implementation of Conway&#x27;s Game of Life in python, CLI version. Written by Furffico for SUMSC Hackathon 2022.positional arguments: FILE Input initial state [default: random]options: -h, --help show this help message and exit -s W H, --shape W H Shape of the world. [default: fill the terminal] -t T, --iteration T Maximum count of iterations (set to 0 for infinity). [default: 0] -e, --autoexit Terminate the simulation when certain conditions are met (e.g. no live cells, repeated states). [default: False] -f F, --fps F Set the framerate (frames per second). [default: 10] -p P, --position P Select where to put the loaded world. The first letter indicates horizontal position (l, c, r); the second letter indicates vertical position (t, c, b). [default: cc, choices: lt, ct, rt, lc, cc, rc, lb, cb, rb] -w, --waitinit Pause the program after the initial state is drawn. [default: False]This program is distributed under GNU GENERAL PUBLIC LICENSE version 3, for full text please refer to https://www.gnu.org/licenses/gpl-3.0.html 下面将对各个参数进行详细讲解： FILE 位置参数为输入的文件，用来指定程序的初始状态，当没有输入文件时程序将随机初始化。关于输入文件的格式请见“文件格式说明” -h 参数用于打印上述帮助。 -s 参数接受两个整数参数，分别为宽与高，用来设定地图的大小，默认为填满整个命令行界面。 -t 参数用于指定程序模拟的运行轮数，设为0时程序将永久运行（默认为0）。在程序运行时可以通过Ctrl-C组合键终止程序的运行。 -e 用于设定当程序检测到循环的状态或者地图内没有活细胞时结束运行。 -f 用于设定程序运行的帧率，默认为每秒10帧。（当帧率过高时可能会导致程序界面出现闪烁现象。） -p 参数用于设定加载输入的初始状态在地图中的位置，当没有输入文件时该选项无效果。这个参数由两个字符构成，第一个字符指定水平位置，可选的有l、c与r，分别对应左、中、右；第二个字符指定垂直位置，包括t、c与b，分别对应上、中、下。参数一共有九种组合（lt、cb、rc等），默认值为cc，即将输入的状态加载到地图中间。 加入 -w 可以让程序在展示初始状态后等待你按下回车键再继续运行。 上述参数结合使用的一些示例如下：（示例在linux系统中运行） 加载p32-glider-gun.txt到地图左上角（lt），每秒10帧，等待Enter后开始运行。默认为永久运行，示例中使用Ctrl-C在第15秒终止了程序。 1$ python3 ./gameofLife.py ./p32-glider-gun.txt -f 10 -p lt -w 最多运行200轮，自动退出，设定地图大小为30x20，以每秒10帧的帧率运行（随机初始化）： 1$ python3 ./gameofLife.py -t 200 -e -s 30 20 -f 10 文件格式说明 输入文件为纯文本文件，格式为用于存储康威生命游戏状态的plaintext格式（详见 https://conwaylife.com/wiki/Plaintext ）。在文件中使用英文句号/小数点.表示死细胞，使用大写的英文字母O表示活细胞，每行的长度不定。此外以半角感叹号!开头的行会被忽略，可以在里面写注释。 下面是一个示例文件（也就是上面一节中示例1的输入文件，来源）： 12345678910111213!Name: Gosper glider gun!Author: Bill Gosper !The first known gun and the first known finite pattern with unbounded growth.!www.conwaylife.com/wiki/index.php?title=Gosper_glider_gun........................O.................................O.O............OO......OO............OO...........O...O....OO............OOOO........O.....O...OOOO........O...O.OO....O.O..........O.....O.......O...........O...O............OO 代码本体 你可以从下面展示的源代码中直接复制，如果没加载出来请前往Github Gist复制，或是从这里直接获取文件：下载地址（可能不是最新的）","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"技术赋能#1：python的可迭代对象、迭代器与生成器","slug":"techpost-2022-1","date":"2022-10-18T12:23:48.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/10/18/techpost-2022-1/","link":"","permalink":"https://sumsc-caa.github.io/2022/10/18/techpost-2022-1/","excerpt":"","text":"相信大家在学习 python 的 for 循环的时候，一定或多或少听说过迭代这个词语。例如下面这段代码中的循环可以描述为“变量i对range(100)迭代”，其中i是迭代变量，range(100)是被迭代的对象。而在 python 中，只有 可迭代对象（iterable） 能被迭代。本文将简要介绍可迭代对象，以及 python 中与之相关的两个概念：迭代器（iterator）与生成器（generator）。 1234s = 0for i in range(100): s += iprint(s) 可迭代对象与迭代器 可迭代对象（iterable） 包括两种对象，一是实现了__iter__()方法的对象，其中__iter__()方法要求返回一个迭代器；二是具有序列属性的对象，即具有__getitem__()方法，并可以使用连续的自然数作为索引从对象中获得值。我们所接触的大部分 python 内置的数据结构的实例都同时满足这两个条件，包括列表list，元组tuple，字符串str和bytes等；而集合set与字典dict只满足第一个条件，不过它们都是可迭代对象。除此之外，range、map、filter和enumerate等内置函数的返回值也是可迭代对象。 迭代器（iterator） 是实现了__next__()方法与__iter__()方法的对象，其中__iter__()方法只能返回对象自身，因此迭代器都是可迭代对象。每次调用该对象的__next__()方法或者对其使用内置函数next()可以从迭代器中获得一个值，当迭代器耗尽时抛出StopIteration异常，结束迭代。 几个示例 上面的描述有点抽象了，还是来看看示例吧。下面的例子以内置函数range为例，演示了可迭代对象和迭代器的一些属性： 1234567891011121314151617181920212223242526&gt;&gt;&gt; rg = range(5) # 创建range对象&gt;&gt;&gt; dir(rg) # rg有__iter__()方法，是可迭代对象[&#x27;__bool__&#x27;, ..., &#x27;__iter__&#x27;, &#x27;__le__&#x27;, ...]# 注：next(x)效果同调用 x.__next__()&gt;&gt;&gt; next(rg) # rg没有__next__()方法，不是迭代器Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;range&#x27; object is not an iterator# 注：iter(x)效果同调用 x.__iter__()&gt;&gt;&gt; r = iter(rg) # 调用__iter__()方法获得可迭代对象对应的迭代器&gt;&gt;&gt; dir(r) # r有__iter__()与__next__()方法，是迭代器[&#x27;__class__&#x27;, ..., &#x27;__iter__&#x27;, ..., &#x27;__next__&#x27;, ...]&gt;&gt;&gt; next(r) # 使用next()函数或者__next__()方法从r中获得值0&gt;&gt;&gt; next(r)1&gt;&gt;&gt; r.__next__()2&gt;&gt;&gt; r.__next__()3&gt;&gt;&gt; next(r)4&gt;&gt;&gt; next(r) # r被耗尽，抛出 StopIteration 异常Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 下面是一个对比示例，演示了 不是迭代器的可迭代对象 和 迭代器 在 for 循环中的区别。 不是迭代器的可迭代对象：代码与执行结果如下。因为每次循环开始前都会调用__iter__()方法返回一个新的迭代器，所以两次循环都是从 0 开始的。 12345678910rg = range(5)for i in rg: print(i, end=&quot; &quot;) if i&gt;=2: breakprint(&quot;|&quot;, end=&quot; &quot;)for i in rg: print(i, end=&quot; &quot;)print()# === output ===0 1 2 | 0 1 2 3 4 迭代器：将上例中第一行改为rg = iter(range(5))，此时rg变为迭代器，变更后代码的执行结果如下。两次 for 循环开始前都调用__iter__()方法返回rg对象自身（是同一个迭代器），而第一次循环执行到 2 停止了，此时rg中的 0 1 2 均被消耗，因此第二次循环从 3 开始。 10 1 2 | 3 4 自定义迭代器 根据定义，我们知道迭代器需要具有__next__()方法和返回自身的__iter__()方法。不难据此写出自己的迭代器类，下面就是笔者自定义的一个迭代器类，实现了一个可顺序访问的 Fibonacci 数列。 1234567891011121314151617class Fibonacci: def __init__(self, count: int): self.count = count self.last = 1 self.current = 0 def __iter__(self): # __iter__()方法返回对象自身 return self def __next__(self): if self.count == 0: # 如果迭代了指定的次数则抛出 StopIteration raise StopIteration() # 更新状态 self.last, self.current = self.current, self.last+self.current self.count -= 1 return self.current # 返回当前值 测试代码： 12345for i in Fibonacci(15): print(i, end=&quot; &quot;)print()# === output ===1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 同时 python 中的迭代器可以是无限的，在上例中只要将Fibonacci()的参数改为负数即可得到一个无限的迭代器。因为它们是无限的，所以在 for 循环中使用它们时一定不要忘记添加退出条件。 1234567for i in Fibonacci(-1): if i &gt; 10000: break print(i, end=&quot; &quot;)print()# === output ===1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 生成器 生成器（生成器函数，generator） 是指 python 中含有yield关键字的函数，是 python 提供的用于定义生成器的简易方法。生成器函数在调用时会返回一个生成器迭代器（generator iterator）（顾名思义这是一种迭代器）。 你可能也会觉得上面的那个自定义迭代器的代码太冗长了，我们可以使用生成器将其简化（这里就不考虑无限的情况了）： 12345def fibonacci(count: int): last, current = 1, 0 for i in range(count): last, current = current, last+current yield current # 使用yield函数返回当前值，同时表明这是一个生成器 在生成器函数中，当函数执行到yield语句的时候会保存函数当前的状态，然后返回语句里的值，相当于函数的运行在这里暂停了。当__next__()再次被调用的时候函数会加载之前保存的状态，并从yield语句继续执行。你可以在上面的例子中添加一些print函数，结合next对生成器迭代来查看具体的执行过程。 测试代码和结果都和上面的相似，这里就不展示了。需要注意的是，这个例子定义的函数是生成器函数，生成器函数本质上是一个函数，不是可迭代对象，调用生成器函数得到的对象才是迭代器，如下面的例子所示。 1234567891011121314&gt;&gt;&gt; fibonacci # fibonacci是生成器函数&lt;function fibonacci at 0x7facc4139cf0&gt;&gt;&gt;&gt; iter(fibonacci) # fibonacci不可迭代Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;function&#x27; object is not iterable&gt;&gt;&gt;&gt;&gt;&gt; fib = fibonacci(100)&gt;&gt;&gt; fib # fibonacci函数调用返回的才是生成器迭代器&lt;generator object fibonacci at 0x7facc42525e0&gt;&gt;&gt;&gt; iter(fib) # fib是可迭代对象，对应的迭代器是其自身（内存地址相同）&lt;generator object fibonacci at 0x7facc42525e0&gt;&gt;&gt;&gt; next(fib)1 生成器推导式 生成器推导式（generator expression） 是对生成器的简化，可以用来替换一些简单的生成器函数。它的语法结构如下，其中&lt;var&gt;为循环变量，&lt;iterable&gt;为被迭代对象，&lt;expr&gt;为输出表达式，&lt;condition&gt;为逻辑表达式（或者是能转换为布尔值的对象）。这个结构与列表推导式和集合推导式相似，除了两边使用的是圆括号，以及返回值是生成器迭代器。 1(&lt;expr&gt; for &lt;var&gt; in &lt;iterable&gt; if &lt;condition&gt;) 上面的生成器推导式的结果等价于这个生成器函数的执行结果： 1234def _(): for &lt;var&gt; in &lt;iterable&gt;: if &lt;condition&gt;: yield &lt;expr&gt; 同时也等价于这个 filter-map 链： 1map(lambda &lt;var&gt;:&lt;expr&gt;, filter(lambda &lt;var&gt;:&lt;condition&gt;, &lt;iterable&gt;)) 关于 yield 关键字 如果你需要在一个生成器中逐个返回另一个可迭代对象的值，比起使用 for 循环+yield，可以用更简便的yield from，比如下面这段代码： 1234567def rangerange(n: int): for i in range(n+1): yield from range(i)print(*rangerange(7))# === output ===0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5 0 1 2 3 4 5 6 还有一个不太常用的知识：yield语句是有返回值的，其值来自于调用生成器迭代器的send()方法时的参数。编程时可以利用这个在迭代过程中从外部影响迭代器的状态。可以用下面这个测试函数看看效果： 123456789101112131415161718192021222324def test(): counter = 0 while True: value = yield counter print(f&#x27;value received at &#123;counter&#125;:&#x27;, value) counter += 1# === testing ===&gt;&gt;&gt; g = test()&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g) # yield语句默认的返回值为Nonevalue received at 0: None1&gt;&gt;&gt; g.send(123) # 调用send方法也会触发一次生成器迭代器的更新value received at 1: 1232&gt;&gt;&gt; g.send() # send方法必须接受一个参数Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: generator.send() takes exactly one argument (0 given)&gt;&gt;&gt; next(g)value received at 2: None3 应用 你可能会想：自定义迭代器到底有什么用呢？我把这些代码移到 for 循环里面不是也有相同的效果？为什么不直接返回一个列表呢？下文将解答你的问题。迭代器的应用与优点包括但不限于： 迭代器是 python 提供的用于遍历自定义数据结构的接口：假如有人用 python 实现了一个单向链表，并且希望 for 语句能在这个单向链表上迭代，这个时候就需要在单向链表类中实现__iter__()方法将其变成可迭代对象。 节约内存：以上面的fibonacci生成器为例，记一次性返回完整列表的版本为fibonacci2，假设输入参数是 n，则前者的空间复杂度是 O(1)（因为不用存储每次迭代得到的值），而后者的是 O(n)（需要将每个值存到列表内一次性返回），在 n 很大的时候这个差距尤其明显。 代码封装：针对第二个问题，只有一个 for 循环时确实有相同的效果。若有多个 for 循环都要用到这段代码，则需要对其进行封装。如果使用返回列表的方法，在数据量大的时候会导致内存的浪费，这时生成器无疑是最合适的。 参考资料 术语对照表 - python3.10 官方中文文档","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"}]},{"title":"2022 Hackathon Online","slug":"hackathon2022-online","date":"2022-06-05T12:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/06/05/hackathon2022-online/","link":"","permalink":"https://sumsc-caa.github.io/2022/06/05/hackathon2022-online/","excerpt":"","text":"异步IO与QQ机器人 作者：苏州大学计算机爱好者协会 王嘉睿 如果是常年混迹各大qq群的同学想必都或多或少地见过qq机器人，它们常常具有丰富的功能，并在不同类型的群中发挥着作用：游戏群里的qq机器人可以在对话中查询游戏的相关数据；主播粉丝群里的机器人可以在主播开播时发消息提醒大家；vtuber字幕组群中的qq机器人可以是兼拉取推文、嵌字和发布于一体的“烤推机”；年级群里的qq机器人也可以被辅导员设置用来提醒同学们及时完成青年大学习；此外有些qq机器人还会安装一些小游戏，例如成语接龙等，用于活跃群里的气氛。 本期魔盒挑战旨在通过引导你动手实现一个简易的qq机器人，让你逐步了解异步编程和python的asyncio（异步io）。 1 背景知识 1.1 异步 了解过异步的同学可以跳过本节。 首先，什么是异步？要回答这个问题，我们可以看看这个例子（网上找的小学奥数题）： 玲玲想给客人烧水沏茶。洗水壶要2分钟，烧开水要12分钟，买茶叶要5分钟，洗茶杯要1分钟，冲茶叶要1分钟，要让客人尽可能早的喝上茶，你认为怎样安排才最合理？最少需要多少分钟？ 答案很简单，先洗水壶 2 分钟，然后用水壶烧开水，同时买茶叶、洗茶杯，共 min(12,5+1)=12 分钟，最后使用烧好的开水和买来的茶叶泡茶，需要 1 分钟。因此最少需要 2+12+1=15 分钟才能让客人喝上茶。 接下来用伪代码复现一下这个安排： 123洗水壶() # 2 min烧开水() # 12 min冲茶叶() # 1 min 诶？好像不太对，我们怎么让程序在执行A任务的同时完成B任务呢？ 有的同学可能会想到多线程，我们再开一个线程让它等水烧开就行： （CPython的多线程其实是假的多线程，详见全局解释器锁，不过在这里不重要） 123456789import threading洗水壶() # 2 mint=threading.Thread(target=烧开水)t.start()买茶叶() # 5 min洗茶杯() # 1 mint.join() # 12-5-1=6 min冲茶叶() # 1 min 但是这样就显得有点大材小用了，只是泡个茶居然要用掉两个线程，有没有更好的方法呢？ 让我们来回顾一下解题的过程，首先要理清楚五个任务的因果关系： 12345洗水壶 │ 烧开水 买茶叶 洗茶杯 └──────┼──────┘ 冲茶叶 然后我们会把题中的任务分成两类： A类：洗水壶、买茶叶、洗茶杯、冲茶叶 B类：烧开水 其中A类任务需要占用玲玲的处理时间，因此不能同时进行，例如玲玲不能在洗茶杯的同时出门买茶叶，称其为“同步”的任务。而B类任务不需要占用处理时间，换言之玲玲在烧开水的时候只需要将热水壶装好水插上电就行，剩下的等待时间她可以用来处理其它A类或者B类（比如再烧一壶水）任务，因此可以称其为“异步”的任务。 因为烧开水是异步的，且和买茶叶、洗茶杯之间不存在因果关系，所以我们安排玲玲在烧开水的同时去买茶叶和洗茶杯，节省了6分钟的时间。又因为剩下的任务必须要按因果顺序进行，所以这个就是时间最短的安排了。 而在python中，上面的程序可以使用asyncio改写成这样，其中的函数虽然都是异步函数的形式，但是只有烧开水是真正的异步： 123456789101112131415161718192021222324252627282930import asyncio # python的异步io库import timedef f(text1,text2,duration,block=True): async def wrapped(): print(&#x27;&#123;:.0f&#125;&#x27;.format(time.time()-t0),text1) if block: time.sleep(duration) # 同步的等待 else: await asyncio.sleep(duration) # 异步的等待 print(&#x27;&#123;:.0f&#125;&#x27;.format(time.time()-t0),text2) return wrapped洗水壶=f(&#x27;开始洗水壶&#x27;,&#x27;水壶洗好啦&#x27;,2,True) # 同步烧开水=f(&#x27;开始烧开水&#x27;,&#x27;水烧开啦&#x27;,12,False) # 异步买茶叶=f(&#x27;开始买茶叶&#x27;,&#x27;茶叶买好了&#x27;,5,True) # 同步洗茶杯=f(&#x27;开始洗茶杯&#x27;,&#x27;茶杯洗好了&#x27;,1,True) # 同步冲茶叶=f(&#x27;开始冲茶叶&#x27;,&#x27;茶冲好了&#x27;,1,True) # 同步async def 泡茶(): await 洗水壶() # 洗水壶 await asyncio.gather( # 等待下面三个任务全部完成 烧开水(), # 首先执行烧开水，因为烧开水是异步的，等待的时间内会依次执行下面两个任务 买茶叶(), 洗茶杯(), ) await 冲茶叶() # 冲茶叶t0=time.time() # 记录开始时间asyncio.run(泡茶()) # 运行异步函数的入口 运行之后可以看到类似这样的结果： 123456789100 开始洗水壶2 水壶洗好啦2 开始烧开水2 开始买茶叶7 茶叶买好了7 开始洗茶杯8 茶杯洗好了14 水烧开啦14 开始冲茶叶15 茶冲好了 可以看到烧开水的等待时间的确有一部分被玲玲用来买茶叶和洗茶杯了，这样玲玲就可以在一个线程内完成泡茶的任务了。实际程序中的任务模型会比上面的例子复杂许多，可能会有上百个异步的网络请求在同时进行，而python的异步io能帮助我们很好地安排和执行这些任务，同时保持代码的简洁与优雅。 最早在编程语言中大面积使用异步的是JavaScript，关于这个的故事可以参考这篇文章：https://blog.csdn.net/li123128/article/details/80650256 。而python中引入异步io最早是在2015年更新的python3.5，经过几年的打磨和优化，语法逐渐定型成我们今天所见的这个样子。 希望以上的说明能为你理解异步这个概念提供一些帮助。以下是一些关于python的异步IO的参考资料： python官方文档 | asyncio——异步I/O 廖雪峰的官方网站 | 异步IO 1.2 WebSocket WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。 在我们平时所接触的http/https协议中，所有请求都只能由客户端主动发起，这使得以往要实现从服务端向客户端实时发送数据只能使用轮询的模式，即客户端每隔一段时间向服务端发送http请求，服务端收到请求后返回这段时间内累积的数据。这个轮询方案有几个问题： 其一，传输的损耗很大。假设某实时聊天软件（IM）的客户端每隔5秒向服务器发送一个http的轮询请求，请求和响应的header的大小均为0.5KB，平均情况下每隔15秒就有人给你发一条1KB的消息（大约500个汉字）。这样你每分钟就要花掉1KB*60s/5s+1KB*60s/15s=16KB的流量，一个月下来就是16KB*60*24*30=691.2MB，而其中真正有效的信息只有(1KB/15s)/(1KB/5s+1KB/15s)=25%，无论是用户还是服务提供商都不想承受另外75%的没什么用的流量。 其二，不适合对延迟很敏感的场景。还是上面那个例子，在轮询机制下消息的延迟上限（不计其它网络延迟）与轮询的间隔相等，在上面的例子中你最多要等5秒才能收到朋友发的消息。而在即时对决的网游中为了降低延迟则必须提高轮询的频率，如果画面帧率为60fps，为了让画面保持同步轮询的频率也得大于60Hz，这样会导致巨额的流量（若是按照上面的数据算，相当于每一帧都要花掉至少1KB，20分钟累计1KB*60Hz*60s/min*20min=72MB），即使把header大小降到0（也就是不使用http协议，直接用tcp），高频率的请求依然会给服务器造成很大的压力。 WebSocket则可以很好地避免上述问题。WebSocket是全双工的，换言之ws连接的服务端和客户端都可以主动向对方发送信息，并且发送的消息不像http协议需要耗费一定体积作为header，这样就解决了轮询机制的两个问题。现在ws因为其特性被广泛运用在许多即时性强的应用中，例如实时聊天、直播平台的实时评论/弹幕、游戏的客户端与服务端的通信等等。 项目中使用到的go-cqhttp也提供了http轮询和websocket两种模式，这里我们选择后者是因为后者代码的逻辑更简单。 在python中我们将使用websockets包(package)来和go-cqhttp服务器通信。python中包的安装方法在此不在赘述，建议你为了任务新建一个虚拟环境（参见 venv - 创建虚拟环境），这样提交的时候可以方便一些。你可以从官方文档了解这个包的基本使用方法，在这里我们只要用到它作为ws客户端的用法，因此服务端的部分可以略过不看。 相关资料（感兴趣的同学可以阅读其中的 RFC 6455 了解 WebSocket 协议的技术细节）： websockets 10.3 documentation RFC 6455 - The WebSocket Protocol 2 说明 2.1 结构 这个项目的结构如下图： 其中OneBot标准是一个聊天机器人应用接口标准（官网：https://onebot.dev/ ），go-cqhttp是OneBot协议的服务端的golang实现（官网：https://docs.go-cqhttp.org/ ），在我们的项目中它的作用是连接QQ服务器，将其发来的消息解包后再用OneBot标准打包发送给我们的程序，同样我们发送的请求也会被go-cqhttp以QQ服务器可解析的方式重新打包后发送。 2.2 比赛说明 2.2.1 赛程 第一部分 开幕式：6月5日下午 第二部分 Hackathon主体：6月5日 - 6月12日 第三部分 作品展示与评选：6月12日 13:30-17:30 请于作品展示开始前（即 6月12日 13:30 之前）将你所写的程序的源码压缩后以你的小组名命名并发送至 furffy@outlook.com 2.2.2 评分方式 比赛一共有6道题目，各题的分值与评价方式如下： 题号 标题 分值 评价标准 #1 运行 go-cqhttp 服务端 5分 引导任务，不需要展示。只要完成#2就能得到这5分。 #2 复读机 5分 引导任务，不需要展示。只要完成#3就能得到这5分。 #3 天气助手 15分 基础分15分 #4 定时任务 20分 基础分10分，评委分10分 #5 小游戏 20分 基础分10分，评委分10分 #6 自由开发 30分 基础分10分，评委分20分 其中，只要你能完成题目的要求就可以拿到基础分，评委分是评委对该题给出的评分的均值。 2.3 注意事项 你不可以使用现成的python机器人框架，例如nonebot、nonebot2等，但是你可以在编写代码时参考这些框架的结构与实现。 虽然我们不会公开发布你上传的代码，但是上传时请务必抹去所有可能会导致你个人隐私泄漏的信息，包括但不限于：在go-cqhttp配置文件中填写的qq号与密码。要对你自己的信息安全负责哦~ qq机器人在群里发消息时有一定概率会被腾讯风控，具体表现为机器人无法正常在群聊中发送消息，这在go-cqhttp的输出中会有体现（风控 != 封号，若是你的机器人被风控了也不必惊慌，大概过几天就好了，但是这并不代表用自己的大号作为qq机器人就完全没有风险）。目前私信是不受风控影响的，因此比赛中的所有问题都只要求在私信的场景下能正常工作。 2.4 参考资料 以下这些python包或许会有用： asyncio: documentation json: documentation logging: documentation websockets: documentation | github | PyPI httpx: documentation | github | PyPI aioschedule (schedule的异步IO版): github | PyPI | schedule的documentation 还有一些资料： go-cqhttp api文档 onebot-11 协议 stack overflow - Python async: Waiting for stdin input while doing other stuff TenApi （一些有用的公共api） 3 题目 3.1 运行 go-cqhttp 服务端 (5分) 参考go-cqhttp的官方文档的快速开始和配置，下载、配置并在本地（或者你的VPS上）运行一个go-cqhttp服务端。 注：配置时请使用你的QQ号或者你的小号，servers部分选择“正向ws”模式。 3.1.1 测试程序 以下是一个测试程序，它可以通过ws协议连接go-cqhttp服务器（正向ws），并实时输出它发送的信息，其中地址和&lt;port&gt;要替换为你在本地运行的go-cqhttp服务器的地址和端口，&lt;access-token&gt;替换为你在go-cqhttp的设置文件中设定的值。 123456789import asyncioimport websocketsasync def main(): async with websockets.connect(&quot;ws://localhost:&lt;port&gt;/?access_token=&lt;access-token&gt;&quot;) as websocket: while 1: print(await websocket.recv())asyncio.run(main()) 如果配置没问题，程序会首先收到连接成功的信息，长这个样子： 1&#123;&quot;_post_method&quot;:2,&quot;meta_event_type&quot;:&quot;lifecycle&quot;,&quot;post_type&quot;:&quot;meta_event&quot;,&quot;self_id&quot;:&lt;当前qq号&gt;,&quot;sub_type&quot;:&quot;connect&quot;,&quot;time&quot;:&lt;当前时间戳&gt;&#125; 如果你在cqhttp的设置里打开了心跳，在程序启动后每隔一段时间就能收到来自服务器的heartbeat。如果你试着用别的号给登录机器人的号发送了消息，应该可以在输出中看到go-cqhttp给客户端打包转发的消息。 3.2 复读机 (5分) 以上面的测试程序为基础，参考go-cqhttp的api文档，编写程序实现当某特定的qq号（你或者你的好友，当然要事先联系一下）发来消息时，向该qq号回复相同的消息。 示例对话（其中“我”为该特定的qq号，bot为你编写的机器人）： 1234我&gt; 你好bot&gt; 你好我&gt; 人类的本质就是复读机bot&gt; 人类的本质就是复读机 3.3 天气助手 (15分) 以上一题的复读机为基础，删去复读功能，改为当有人向机器人发送天气 &lt;城市名&gt;时，从公共api（例如 2.4 参考资料 中的TenApi）获得该城市的天气并返回。这个功能应该包含在最终提交的代码内。 示例对话（只是示例，bot回复的模板由你来决定）： 12345678910我&gt; 天气 苏州bot&gt; 苏州今天的天气是：21-29°C 西南风2级 小雨# 或者我&gt; 天气预报 苏州bot&gt; 苏州今天的天气是：21-29°C 西南风2级 小雨明天星期四：21-31°C 东南风 晴后天星期五：……………… 3.4 定时任务 (20分) 利用asyncio的create_task，让机器人可以定时执行任务。这个功能应该包含在最终提交的代码内。 提示：任务循环不应阻塞正常的消息处理，另建议使用aioschedule包简化任务设置的流程。 定时任务由你来决定，例如： 每天晚上8点提醒你去刷leetcode； 工作日12点-16点每隔一个小时发送补水提醒； 每隔五分钟向直播平台的api（这个就需要一些爬虫和抓包的技术了）发送请求获得直播间开播情况。如果某个主播开播，则向你发送开播提醒。 3.5 小游戏 (20分) 以上一题的天气助手为基础，编写一个单人小游戏，要求能做到在私信中与人互动。这个功能应该包含在最终提交的代码内。 如果你想不到什么单人小游戏，可以实现以下样例： 1234567891011121314我&gt; 猜数 100bot&gt; 开始猜数，目标在0-100之间，请输入你的答案我&gt; 50bot&gt; 小了我&gt; 75bot&gt; 大了我&gt; 62bot&gt; 小了我&gt; 68bot&gt; 小了我&gt; 71bot&gt; 小了我&gt; 73bot&gt; 恭喜你在第6次尝试猜对啦！ 3.6 自由开发 (30分) 编写代码为机器人添加功能。 注：什么功能都行。可以参考nonebot2 的插件列表以获取灵感。","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"魔盒挑战 2022.5","slug":"Pandora-22-5","date":"2022-04-28T16:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/04/28/Pandora-22-5/","link":"","permalink":"https://sumsc-caa.github.io/2022/04/28/Pandora-22-5/","excerpt":"","text":"Welcome! 欢迎来到新一期的魔盒挑战（2022年5月期）！ ❓ 什么是魔盒挑战 魔盒挑战（Pandora Challenge）是计算机爱好者协会（微软学生俱乐部）技术组定期举行的大型创意编程挑战赛。这一挑战不同于一般的编程竞赛，各位挑战者将收到一个神秘盒子（不是物理上的盒子），挑战者需要根据魔盒（赛题）的指引一步步解开魔盒。解开的过程需要挑战者们开动脑筋，发散思维，我们欢迎具有创新的解法！挑战成功有机会获得奖品或技术组的邀请函。 🔍 如何参与 本期魔盒挑战的时间为：2022年5月1日 12:00 — 2022年5月7日 23:59，为期一周，限单人参与挑战。 请各位参与本次魔盒挑战的同学加入QQ群，以便我们能更好地了解各位的题目选择情况，并提供相应的技术支持。 你一共有七天时间来完成这个挑战，无论你是提前完成了挑战，还是时限内未能到达终点，最后都请将的成果及时提交。 如果题目给出了具体的提交方式，请以题目的要求为准，否则按照下列要求发送邮件至sumstc@outlook.com。邮件请以 Pandora-2022-[参与题目] [姓名] [学号] 命名，请根据各题目要求上传附件。 🔔 本期主题 本期共有 2 个题目可供你选择（选择的数量不限）。 各题目传送门： 简单LISP解释器 传送门 失物招领登记与查询系统 传送门 🎁 奖品设置 依照各题目给出的评比标准，排名靠前的同学会有神秘礼品！ 奖品由微软亚洲研究院赞助。 📄 参赛协议 参赛者自愿参加本次活动； 我们将于返校后组织参赛获奖者的颁奖活动，地点暂定于俱乐部实验室（天赐庄校区理工楼110）； 参赛者参与本次活动，默认同意本协议的所有内容。 参赛守则 参赛者应承诺： 不对比赛设施（包括但不限于网站、服务器、数据库）进行任何非法操作； 在活动中使用本人真实信息； 独立参赛，不得给予、借鉴、抄袭其他参赛者的成果，不得不加以声明地使用他人的开源成果； 不得出于任何目的采用任何手段攻击比赛设施、其他参与者的设备。 参赛者如有上述违规行为，苏州大学计算机爱好者协会（微软学生俱乐部）有权取消您的参赛成绩和资格。 用户隐私 本次活动可能会收集您的学号用于身份核实与奖品发放。 我们承诺不会收集任何用户隐私信息，您的学号仅用于验证本人的真实信息； 我们承诺活动结束后删除所有用户隐私数据。 活动最终解释权归苏州大学计算机爱好者协会（微软学生俱乐部）所有。 2022 苏州大学计算机爱好者协会（微软学生俱乐部）版权所有 往期回顾：2021年第一期","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Pandora","slug":"Pandora","permalink":"https://sumsc-caa.github.io/tags/Pandora/"}]},{"title":"魔盒挑战 2022.5 失物招领登记与查询系统","slug":"Pandora-22-5-q2","date":"2022-04-28T15:39:39.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/04/28/Pandora-22-5-q2/","link":"","permalink":"https://sumsc-caa.github.io/2022/04/28/Pandora-22-5-q2/","excerpt":"","text":"出题人：孙家扬(git)，李承庚(git) 背景 大学生活中，遗失物品是一个很常见的现象，遗失物品的人通过什么样的途径来查找自己丢失的物品便是一个值得思考的问题；与此同时，对于捡到遗失物品的人来说，如何方便准确地将捡到的物品归还给遗失物品的人，同样是一个值得我们思考的问题。现在把这个问题交给你，请你为遗失物品的人和捡到遗失的物品的人搭建一个桥梁，方便他们查询和登记遗失的物品。 你需要做的 你需要设计一个程序，语言不限。基本要求很简单。首先，这个程序能够帮助捡到遗失物品的人登记他们捡到的遗失物品。每登记一个物品，需要用户提供一张图片，同时提供一些相关的标签，便于后续的查找。其次，这个程序还需要帮助遗失物品的人根据他们的描述来查找已登记的物品，即输入相应的标签，返回包含有这个标签的图片。 我们使用Python的tkinter库写了一个样例程序（见下）。这个样例实现了基本的登记物品和查找物品。如果你不想白手起家，那么你也可以在我们写好的样例程序上面进行升级。升级内容不限，你可以选择改进界面，让界面更加丰富；你也可以选择增加其中的功能，使其更加完善；等等。 提高 到此，这是一个本地的后端的程序。我们知道，这样的登记查询系统如果建立在网站上将会更加有意义。请尝试将该系统建立到网站上。 挑战 这个程序的查询当前还限制在标签的查询。你有没有什么想法或办法，不通过标签，直接输入相关描述，返回相关的图片？ 样例程序 样例程序说明 样例程序包含：__init__.py, main.py, window.py, data __init__.py为Python package管理文件 main.py为主程序 window.py为创建图形用户界面的程序 data为存储照片和相关标签的文件夹，内含picture文件夹和data.dat 评分标准 满分为100分 评分项 分数 功能完善 50 创意性 25 用户操作体验 10 界面美观 10 代码美观 5 程序出现错误 -5 最后更新时间：2022.4.27","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Pandora","slug":"Pandora","permalink":"https://sumsc-caa.github.io/tags/Pandora/"}]},{"title":"魔盒挑战 2022.5 简单LISP解释器","slug":"Pandora-22-5-q1","date":"2022-04-28T15:39:36.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2022/04/28/Pandora-22-5-q1/","link":"","permalink":"https://sumsc-caa.github.io/2022/04/28/Pandora-22-5-q1/","excerpt":"","text":"一份简易的LISP（Scheme）教程 相信不少人对LISP这门编程语言有所耳闻，又常常听说这门语言“抽象难学”。但实际上LISP的语法规则相当简单，甚至只有几个最基本的规则。下面就拿LISP的一种经典方言Scheme举例： 1(+ 1 2) 上面的代码很好理解。(+ a b)在这里是一个表达式，可以理解为一个函数，接受两个参数，并且返回它们之和，(+ 1 2)的结果就是3，同理(* 2 3)的结果是6，(- 1 2)的结果是-1…… 这些表达式也可以组合起来： 1(+ (* 3 5) (- 10 6)) 上面这个表达式的值就是19，这相当于(3 * 5) + (10 - 6)。 我们常常将LISP表达式通过缩进更清晰地表示： 12345(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) 上面这段代码相当于(3 * ((2 * 4) + (3 + 5))) + ((10 - 7) + 6)，值是57. 除了基本的加减乘除外，LISP还有一些特殊的关键字，例如define可以用来定义变量： 12(define size 2)(* 5 size) 这里先定义了一个值为2的变量size，然后将它乘以5，最终结果是10. 更有意思的是，define还可以用来定义自己的函数： 1(define (square x) (* x x)) 这里定义了一个名为square的函数，它接收一个参数x，并返回它的平方。 我们刚才定义的square函数可以这样调用： 12(define size 3)(square size) 这段代码的返回值是9. 下面是define函数定义的一般形式： 1(define (&lt;函数名&gt; &lt;参数1&gt; &lt;参数2&gt; &lt;参数3&gt; ...) &lt;具体实现...&gt;) 下面定义一个稍微复杂的函数sum-of-squares，接收两个参数，返回它们的平方和： 12(define (sum-of-squares x y) (+ (square x) (square y)) 注意到，这里使用了刚才定义的square函数。上面这段代码应该很容易理解。下面我们使用该函数： 1(sum-of-squares 3 4) 这段代码的返回值是25，即(3 * 3) + (4 * 4)的值. 除了define之外，LISP也有类似if ... else ...的条件表达式，在Scheme中它被这样实现： 1234(define (abs x) (cond ((&gt; x 0) x) ((= x 0) 0) ((&lt; x 0) (- x)))) 上面的代码定义了一个abs函数，用来返回某个数的绝对值。这里使用了cond做条件判断。上面的代码应该也不难理解。cond条件表达式的一般形式如下： 1234(cond (&lt;条件1&gt; &lt;返回值1&gt;) (&lt;条件2&gt; &lt;返回值2&gt;) (&lt;条件3&gt; &lt;返回值3&gt;) ...) 同时cond表达式也提供了一个可选的else，用来在所有条件都不成立时返回值： 123(define (abs x) (cond ((&lt; x 0) (- x)) (else x))) 此外，Scheme也提供了简化的cond，即if： 1234(define (abs x) (if (&lt; x 0) (- x) x)) 上面的代码也很好理解。if后面跟的第一个参数是条件，条件应该是一个返回布尔值的函数，这里的(&lt; x 0)表示条件&quot;若x小于0&quot;；第二个参数是当条件成立时的返回值，也就是x小于0时返回-x；第三个参数是当条件不成立时的返回值，也就是当x大于等于0时返回x。 下面是if条件表达式的一般形式： 1(if &lt;条件&gt; &lt;条件成立时的返回值&gt; &lt;条件不成立时的返回值&gt;) 同时，Scheme也包含Python中的and、or、not，而且它们也是惰性求值的： 123(and &lt;e1&gt; &lt;e2&gt; &lt;e3&gt; ...)(or &lt;e1&gt; &lt;e2&gt; &lt;e3&gt; ...)(not &lt;e&gt;) 对于and，Scheme解释器从左到右一个个地求值&lt;e&gt;，如果某个&lt;e&gt;求值得到假，这一and表达式的值就是假，后面那些&lt;e&gt;自然也不用再求值了。如果所有的&lt;e&gt;都求出真值，这一and表达式的值就是最后那个&lt;e&gt;的值。 同理，对于or，Scheme解释器从左到右一个个地求值&lt;e&gt;，如果某个&lt;e&gt;求值得到真，这一or表达式的值就是真，后面那些&lt;e&gt;自然也不用再求值了。如果所有的&lt;e&gt;都求出假值，这一or表达式的值就是最后那个&lt;e&gt;的值。 对于not，如果&lt;e&gt;求出的值是假，not表达式的值就是真，否则其值为假。 作为示例，下面定义大于等于函数&gt;=： 12(define (&gt;= x y) (or (&gt; x y) (= x y))) 或者可以这么定义： 12(define (&gt;= x y) (not (&lt; x y)) 实际上，到此为止，所有基本的Scheme语法就解释完毕了，已经可以开始编写图灵完备的程序了。仅仅掌握这些知识就能写代码了，简直简单到不可思议……但是等一下，循环呢？ 在LISP中，循环的实现方式是递归。Lisp没有常规的for/while循环，一切类似的操作都可以使用递归实现。下面通过已经介绍的这些语法，实现一个计算阶乘的函数factorial： 1234(define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) 可以看到，这里使用了递归的思想：若n是1，则直接返回1，否则返回n乘以factorial(n-1)。计算阶乘就是这么简单。 下面我们尝试着综合运用学到的知识，实现一个求幂的函数。相比于上面实现阶乘的函数，这里的求幂函数使用了迭代的思想，所以会稍微复杂一些，可能需要花一点时间去理解，你也许需要在草稿纸上动手画一画示意图，但这里用到的知识完全没有超出上面介绍的范围： 12345678(define (expt b n) (expt-iter b n 1))(define (expt-iter b counter product) (if (= counter 0) product (expt-iter b (- counter 1) (* b product)))) 不过，这种求幂的方法未免有些低效。我们知道b8b^8b8可以拆分成b4∗b4b^4*b^4b4∗b4，而b4b^4b4又可以继续拆分成b2∗b2b^2*b^2b2∗b2，而b2b^2b2就是b∗bb*bb∗b，只需通过这么三步就可以计算得到结果。而上面的代码如果要计算b8b^8b8，则只是一步步将结果乘以bbb，计算了888次。于是我们可以这样实现一个快速求幂函数： 123456(define (fast-expt b n) (cond ((= n 0) 1) ((even? n) (square (fast-expt b (/ n 2)))) (else (* b (fast-expt b (- n 1))))))(define (even? n) (= (remainder n 2) 0)) 上面代码里的remainder表示求余，相当于Python中的%符号。 题目 好了，通过上面的教程，你应当已经基本理解Scheme的语法了。这些语法本质上非常简单，而且LISP独特的语法使得这些语法解析起来非常简单。你可能会认为实现一个Scheme解释器非常复杂，但实际上如果只需要实现上面这些简单的功能，几十行Python代码就可以做到，你可以试试看。事实上，目前速度最快并且进行高度优化的一个完整Scheme解释器&quot;Chez Scheme&quot;也只用了不到一千行C语言代码，由此可见Lisp的实现是多么简单。 你只需要编写一个Python版本的Scheme解释器（当然，如果你乐意，也可以使用其它语言），这个解释器只需要实现上面提到的最基本的语法。它接受一个字符串，也就是Scheme代码，返回这段代码的执行结果。你的脚本应当可以通过命令行进行交互，例如： 12&gt; python test.py &quot;(define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) (factorial 5)&quot;120 或者，这个Scheme解释器可以读取一个文本文件，执行其中的Scheme代码。例如： 12&gt; python test.py expt.txt256 下面是上面示例中expt.txt的内容： 123456789(define (expt b n) (expt-iter b n 1))(define (expt-iter b counter product) (if (= counter 0) product (expt-iter b (- counter 1) (* b product))))(expt 2 8) 在这里给出一个基本的Python代码框架，它接收一个文件名，读取并解析该文件中的Scheme代码，并打印结果到终端（不过如果你喜欢，自然也可以不按这个框架来写）： 12345678910111213141516171819202122#!/usr/bin/python3# -*-coding:utf-8-*-import reimport sysdef process_code_string(s: str) -&gt; str: ...if __name__ == &#x27;__main__&#x27;: args = sys.argv if len(args) &lt;= 1: raise TypeError(&#x27;interpreter takes exactly one argument (0 given)&#x27;) elif len(args) &gt; 2: raise TypeError(f&#x27;interpreter takes exactly one argument (&#123;len(args) - 1&#125; given)&#x27;) filepath = args[1] with open(filepath, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: s = f.read() print(process_code_string(s)) 解释器的核心代码应该都包括在process_code_string这一函数中。这里省略了该函数的实现，因为这显然是需要你自己去完成的。 具体来说，你需要实现以下Scheme语法： 实现基本的数据类型（数字及布尔值） 基本组合式，例如加减乘除运算、取负数、取余（remainder）、求商（quotient）、开方（sqrt）、判断相等/大于/小于等。如果你愿意实现一个更完善的解释器，可以考虑加入sin、cos、tan、asin、acos、atan、min、max、abs、square、exp、expt、log等内置函数 变量及函数定义（通过define）。或者你也可以通过lambda块的方式实现函数定义（你可以自行了解相关资料） cond条件表达式，需要包含else的实现，并且需要包含and/or/not。你实现的cond表达式应当是惰性求值的 （可选）实现if表达式。由于if表达式实质上是对cond的简化，因此这并不是必须实现的 递归调用函数 下面是详细的评分标准（满分100分）： 实现基本组合式求值与数字类型（例如(+ 1 2)）—— 15分 实现布尔类型（#f和#t） —— 5分 实现常见运算（加减乘除、取余、开方、相等/大于/小于判断等）—— 10分 实现变量定义 —— 15分 实现cond条件表达式（if表达式可不实现）—— 10分 实现函数定义（define或lambda块，可挑选任意一种实现方式） —— 20分 实现函数的递归调用 —— 15分 其他分数（根据实现方式、逻辑结构、代码规范等给出的主观综合评分）—— 10分 你需要在附带的文档中给出你实现Scheme解释器的过程，使用了什么样的思路，并给出示例代码和运行结果。此外，你还需要给出附有适当注释的解释器源代码。 在完成这一题目后（即使你仅仅完成了一小部分也没有关系），请将代码及文档发送到邮箱gaoge011022@163.com，我们会尽快为题目打分，给出结果。当然了，如果你不仅仅满足于此，你也可以考虑继续实现下面的”进阶“甚至“挑战”任务，会有加分。 提示：如果你希望高效地实现这个解释器，可能会需要用到关于抽象语法树(Abstract Syntax Tree)的知识，这是一种简单的树状数据结构，并且与Lisp语法的相性非常好。不过，如果你不愿那么深入，直接用正则表达式甚至通过.replace()和.split()分割字符串也能实现一个不错的Scheme解释器。 提示2：如果你希望能够实际体验一下编写Scheme代码，你可以在Chez Scheme的官方网站上下载安装一个现成的Scheme解释器用来体验一下。在安装完成后，你的电脑上将会出现Chez Scheme的程序，运行之后会弹出一个交互式的命令行窗口，你可以在这里运行你的Scheme代码。 提示3：如果你对如何实现这个解释器毫无头绪，可以通过搜索“Python实现LISP解释器”获得一些信息。不过建议你尽量不要这么做。 注意事项：在Scheme中，布尔值被表示为#f或#t，对应着Python中的False与True，例如(&gt; 1 2)对应的返回值就应该是#f。 注意事项2：在Scheme中，可以使用;表示注释的开头，以换行作为结尾。例如(expt 2 8) ; 256，这后面的; 256会被自动忽略。你可以考虑实现这一特性，也可以选择不实现。 注意事项3：如果你仍感觉实现这些功能比较困难，可以考虑只实现上面提到的一部分功能，例如只实现最简单的(+ 1 2)，变量定义(define x 1)等。 进阶 如果你在实现完这个简单的Scheme解释器后仍有余力，可以考虑实现一些更高级的语法，例如添加对字符串和浮点数的支持、lambda语句块、列表(list)、局部变量(let)甚至闭包。你可以在w3cschool上找到一个完整的Scheme教程(Yet Another Scheme)，并考虑实现这里提到的部分特性。当然，你也可以自己查找其他资料学习Scheme。 这里并不给出一个具体需要实现哪些语法的列表，你可以自由发挥。推荐你先尝试实现列表（cons及list），以及在列表上使用的一些常用函数（car/cdr/filter/map/reduce/for-each等），由于Python本身对这些函数有支持，并且Python的list与Scheme中的list很相似，因此你只需要在之前的代码基础上做一些小小的改进就可以实现。或者你也可以先实现lambda语句块，它本质上不过是另一种更通用的变量定义方式，应当也是很容易实现的。你也可以优先考虑实现let/throw/quote这些简单的语法，这应当也比较轻松。至于实现字符串可能稍微有些困难，这需要运用一些数据结构的思想，例如栈和树，不过你也可以通过简单的循环判断实现。 另外，非常推荐你首先选择实现Scheme内置的(display x)函数，它负责在命令行（终端）中直接打印x的值，很类似于Python中的print函数。这样就可以非常方便地调试Scheme代码了。 你甚至可以考虑实现一些自己的独特想法，甚至是不包含在Scheme语法规范里的语法。例如，你可以实现一个(print-to-file &lt;string&gt; &lt;filepath&gt;)函数，将字符串&lt;string&gt;的值输出到文件。你也可以将一些函数内置，例如上面提到的(square x)函数，使其不需定义就可以直接使用。你可以充分发挥创造力，打造属于自己的LISP方言。 例如，在LISP的另一门方言Clojure中，实现了宏定义(-&gt;&gt; ...)，它可以像下面这样使用： 1234(-&gt;&gt; 1 (+ 1) (* 2) (- 10)) 上面这段代码的值是-6，正好就是((1 + 1) * 2) - 10的结果。在Clojure中，这被称为thread-last宏，它将典型的LISP书写顺序颠倒了过来，重整为更自然的从左到右的阅读顺序，很符合人类的习惯，也更加清晰。 假设你已经实现了list、字符串、lambda块等高级特性，利用上面提到的&quot;-&gt;&gt;&quot;，就可以编写更有意思的代码： 1234567891011121314(define (process-string Alist) (-&gt;&gt; Alist (filter (lambda (x) (&gt; (string-length x) 1))) (map capitalize) (interpose &quot;,&quot;) (reduce str)))(define list-of-employees (list &quot;neal&quot; &quot;s&quot; &quot;stu&quot; &quot;j&quot; &quot;rich&quot; &quot;bob&quot; &quot;aiden&quot;))(process-string list-of-employees); 下面一步一步地演示了list-of-employees的转换过程; (&quot;neal&quot; &quot;s&quot; &quot;stu&quot; &quot;j&quot; &quot;rich&quot; &quot;bob&quot; &quot;aiden&quot;); (&quot;neal&quot; &quot;stu&quot; &quot;rich&quot; &quot;bob&quot; &quot;aiden&quot;); (&quot;Neal&quot; &quot;Stu&quot; &quot;Rich&quot; &quot;Bob&quot; &quot;Aiden&quot;); (&quot;Neal&quot; &quot;,&quot; &quot;Stu&quot; &quot;,&quot; &quot;Rich&quot; &quot;,&quot; &quot;Bob&quot; &quot;,&quot; &quot;Aiden&quot;); &quot;Neal, Stu, Rich, Bob, Aiden&quot; 上面先不讨论filter、map、capitalize、interpose、reduce、str这几个内置函数是怎么实现的，只着眼于代码本身。上面这段代码演示了处理如何处理一个包含公司雇员姓名的列表：先去除所有只有一个字母的错误数据，再对每个雇员的姓名应用capitalize，即将其首字母大写，然后用interpose在两两单词之间插入,作为分隔符，然后通过reduce累加地调用str函数将这些单词组合起来。 上面代码中演示的解决问题的方式被称为函数式编程思想，而LISP就是一种典型的函数式编程语言。函数式编程不关心复杂的数据结构与类继承关系，而是创造一系列通用的函数，将复杂的问题转换为最基本的几个数据结构，然后利用这些通用的函数求解问题，而不是制造更多的数据结构。函数式编程将函数当作”一等公民“，函数也可以被当作变量，可以直接作为参数传入，这被称为高阶函数，例如上面代码中的&quot;filter&quot;就接收了一个lambda函数作为参数。在函数式编程中，很常用的三个操作列表的函数是filter(筛选)、map(映射)、reduce(折叠/化约)，Python中也有这三个函数，你可以了解一下，并考虑在你的Scheme解释器上实现它们（不过你显然需要先实现list）。此外，函数式编程还有不变性、减少副作用等概念，你若感兴趣可以自行了解。 不过，要让你的Scheme解释器支持运行上面提到的代码可能并不容易。这个例子仅仅是展示了LISP的无限可能：即使-&gt;&gt;并不是Scheme的标准语法，你仍可以轻松地实现这个功能（相较于其他语言来说），这意味着你可以充分发挥你的想象力，创造属于自己的LISP方言。 当然了，这一部分不作强制要求，仅仅作为加分项（满分40分，作为附加分）。如果你实现了基本功能之外的功能，需要在附带的文档中指出你实现了哪些Scheme高阶特性，又有哪些是你独创的语法，并给出示例代码和运行结果。此外，你还需要给出附有适当注释的解释器源代码。 为了不束缚想象力，这一部分较为开放，并不包括详细的评分标准。但你可以在下面的推荐里挑选几个实现。当然，你可以实现的功能远不仅限于这个范围。我们会根据你具体的实现情况以及创新点决定你的40分附加分： 实现字符串以及浮点数 实现局部变量（let） 实现高阶函数 实现列表（list和cons）及相关函数（filter/map/reduce/for-each等） 实现内置的哈希表 实现文件输入/输出API 实现引用语法（'） 实现向量（vector） 实现一些独特的内置宏定义（例如上面演示的thread-last宏） 实现一些有趣的独创语法 其他创新点 再次强调，相比于100%还原Scheme语法，我们更希望能够看到一些闪光的创新点。我们的目的并不是复刻一门语言，而是实现一个有趣的解释器。因此，我们会考虑对创新特性进行更多加分，即使是实现起来非常容易的创新点。 注：如果你对此很感兴趣，希望深入学习Scheme，可以在这次活动结束后阅读《计算机程序的构造与解释（SICP）》，这本书从原理入手，通过Scheme解释了编程语言的原理，很有趣但也很需要一定的思维量。不过在这次活动中就不推荐你阅读了，这本书需要很长的时间才能搞明白，而且应当对你在本次活动中的解题过程没什么帮助。 挑战 注意：这一部分仅仅作为“挑战”，即使你完成了这些挑战，给出了很完善的实现，也只能获得很少的加分（满分10分）。建议优先考虑完善上面的基本题目与“进阶”部分。 如果你在完成进阶任务后仍有余力，可以考虑完成这里的一部分“挑战”。完成这些挑战有助于将你的Scheme解释器变成一个真正具有实用价值的解释器，可以真正方便地运行各种代码，并且具有简单的调试功能。 以下是挑战列表。当然，如果你不满足于这些挑战，也可以自己完成想做的挑战： 实现一个简单的REPL（交互式运行环境），就像Python自带的IDLE一样。实现这一功能可能远比你想象的简单许多，甚至只需要十数行代码 输出更好的报错信息，当代码出现语法错误时猜测可能是哪里出了问题 实现尾递归优化 实现垃圾回收（你可以考虑最简单的引用计数法，当然也可以挑战自己选择使用更复杂的算法实现） 考虑完全不使用eval实现解释器。注意：较难 为LISP添加面向对象支持，例如加入class关键字。如果你对如何添加类似Java/Python中传统的面向对象支持没有头绪，可以考虑实现JavaScript中的原型链继承。一个更简单的主意是先考虑实现C语言中的结构体（struct）。注意：这可能非常困难！尝试完成这一挑战时请务必谨慎 值得注意的是，“挑战”与“进阶”的区别在于“进阶”仅限于语法层面，而“挑战”部分的内容范围更广，并且不集中于语法层面，且难度大得多。例如你在语法之外实现了解释器速度上的优化，那么这些工作就算在“挑战”中。“挑战”的加分很少（仅10分），因此推荐你不优先考虑解释器的效率问题。 如果你尝试着完成了这些挑战的一部分，可以将你通过Scheme实现解释器的心路历程、实现了哪些语法、又实现了哪些自创语法、示例代码和运行结果写在文档里，并给出解释器的源代码。再次强调，这一部分仅仅是一个“挑战”，即使你给出了很完善的实现，也只会有很少的加分，仅建议你在有余力的情况下考虑挑战这个任务。","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Pandora","slug":"Pandora","permalink":"https://sumsc-caa.github.io/tags/Pandora/"}]},{"title":"2021 魔盒挑战第一期-网页迷宫篇 解题流程与说明","slug":"pandora-2021-1-maze-solution","date":"2021-12-03T10:44:25.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/12/03/pandora-2021-1-maze-solution/","link":"","permalink":"https://sumsc-caa.github.io/2021/12/03/pandora-2021-1-maze-solution/","excerpt":"","text":"Level 00 略。 Level 01 | HelloMaze.html 用鼠标选中色块中的文字即可，得到答案eA5JlOGrq0AFEPy6IJT。 Level 010 | eA5JlOGrq0AFEPy6IJT.html 根据提示打开审查元素，在元素/Inspector一栏用元素选择器选择带边框的div，展开标签看到hiddentext：UDZvYvFch，即为答案。 Level 011 | UDZvYvFch.html 根据提示打开审查元素的控制台，此时点击按钮可以看到控制台输出EiuOOcxCOKzEyXLL，即为答案。 Level 0100 | EiuOOcxCOKzEyXLL.html Method 1 根据提示打开审查元素的控制台，输入指令answer或console.log(answer)即可看到答案：rMhsaAmoDVeRXBcdoN。 Method 2 在审查元素的元素一栏中查找script标签，看到 1&lt;script&gt;var answer=&quot;rMhsaAmoDVeRXBcdoN&quot; &lt;/script&gt; 一行，说明answer的值为rMhsaAmoDVeRXBcdoN。 Level 0101 | rMhsaAmoDVeRXBcdoN.html 按照题目要求写出程序并运行即可得到答案。两个样例程序如下： python 1234567891011121314151617181920212223242526import mathdef proc(st): nums = list(map(ord, st)) avg = sum(nums)/len(nums) var = sum(map(lambda x: x**2, nums))/len(nums)-avg**2 avg, var = math.ceil(avg), math.ceil(var) return avg, vardef proc2(num): while not(48 &lt;= num &lt;= 57 or 65 &lt;= num &lt;= 90 or 97 &lt;= num &lt;= 122): num = (num+7) % 129 return chr(num)lst = [ &quot;HelloMaze&quot;, &quot;eA5JlOGrq0AFEPy6IJT&quot;, &quot;UDZvYvFch&quot;, &quot;EiuOOcxCOKzEyXLL&quot;, &quot;rMhsaAmoDVeRXBcdoN&quot;]print(&#x27;&#x27;.join([proc2(j) for i in lst for j in proc(i)])) JavaScript 1234567891011121314151617181920212223242526272829303132function processNum(n)&#123; n=Math.ceil(n) while(n&lt;48|57&lt;n&amp;n&lt;65|90&lt;n&amp;n&lt;97|n&gt;122)&#123; n=(n+7)%129; &#125; return String.fromCharCode(n);&#125;function processStr(s)&#123; let sum=0,squaredsum=0; for(let i=0;i&lt;s.length;i++)&#123; let n=s.charCodeAt(i); sum+=n; squaredsum+=n*n; &#125; let avg=sum/s.length; let variance=squaredsum/s.length-avg*avg; return processNum(avg)+processNum(variance);&#125;let answer=&quot;&quot;;let lst=[ &quot;HelloMaze&quot;, &quot;eA5JlOGrq0AFEPy6IJT&quot;, &quot;UDZvYvFch&quot;, &quot;EiuOOcxCOKzEyXLL&quot;, &quot;rMhsaAmoDVeRXBcdoN&quot;];lst.forEach((value)=&gt;&#123; answer+=processStr(value);&#125;)console.log(answer); Level 0110 | dkPBe3b2d3.html 根据提示打开审查元素，找到check的源代码（注释是后加的）： 12345678910function check(m,n,o,p)&#123; let ns = [m,n,o,p].sort((a,b)=&gt;b-a); // 将[m,n,o,p]逆序排序后存入ns内，说明参数的顺序不会对影响结果 let nums = []; for(let i=2; i&lt;5; i++)&#123; // i从2到4迭代 ns.forEach((value)=&gt;&#123; // 对列表ns迭代 nums.push(value*i); // 将value*i加到nums末尾 &#125;) &#125; return String.fromCharCode(...nums); // 将nums转换为字符串并返回&#125; 分析后可知check函数负责将四个数字，m、n、o、p，倒序排序后都乘以2、3、4，将结果依次加入数组nums内。随后将nums的各项按照ascii码转换为字符串。 这里再结合提示“联系上一题”，为了确保整数对应的字符是合规的答案，整数n必须满足如下约束： 2n,3n,4n∈Z∩{[48,57]∪[65,90]∪[97,122]}2n,3n,4n\\in \\mathbb Z\\cap\\{[48,57]\\cup[65,90]\\cup[97,122]\\} 2n,3n,4n∈Z∩{[48,57]∪[65,90]∪[97,122]} 即 24.25=max⁡{24,653,974}≤n≤min⁡{572,903,1224}=28.524.25=\\max\\{24,\\frac{65}{3},\\frac{97}{4}\\}\\leq n \\leq \\min\\{\\frac{57}{2},\\frac{90}{3},\\frac{122}{4}\\}=28.5 24.25=max{24,365​,497​}≤n≤min{257​,390​,4122​}=28.5 又因为题目中规定了check的输入都是整数，所以满足条件的只有25,26,27,28四个数，共有35种情况。可以写程序穷举也可以手工穷举，不过在穷举之前应该能想到把四个数都填进去试试看，正好就能得到答案8642TQNKplhd。 穷举程序（python）： 123456789101112131415161718192021222324252627282930313233import requests as r # python中著名的网络请求库，需通过pip安装from time import sleepdef check(*args): # 页面中的check函数的复刻 return &quot;&quot;.join([chr(i*j) for j in range(2, 5) for i in sorted(args, reverse=True)])nums = [25, 26, 27, 28]conditions = ( (nums[i], nums[j], nums[k], nums[l]) for i in range(0, 4) for j in range(i, 4) for k in range(j, 4) for l in range(k, 4)) # 列举所有情况for cond in conditions: answer = check(*cond) url = f&quot;http://10.10.65.208:8080/maze/&#123;answer&#125;.html&quot; response = r.get(url, timeout=1) if response.status_code == 200: # 页面存在时状态码为200 print(f&#x27;&#123;cond&#125; =&gt; &#123;url&#125; exist.&#x27;) print(&quot;\\n======================&quot;) print(f&quot;The answer: &#123;answer&#125;\\nLink to next level: &#123;url&#125;&quot;) print(&quot;======================\\n&quot;) elif response.status_code == 404: # 页面不存在时状态码为404 print(f&#x27;&#123;cond&#125; =&gt; &#123;url&#125; not exist.&#x27;) else: # 如果状态码不是上述二者说明服务器出问题或者访问过于频繁，抛出异常 raise BaseException( f&quot;unknown status code: &#123;response.status_code&#125; while accessing &#123;url&#125;.&quot;) sleep(0.5) # 控制访问间隔，防止对服务器造成压力 Level 0111 | 8642TQNKplhd.html 题目中的色块共有6行8列，且只有8种颜色，结合提示猜测通关的信息可能被编码成颜色，因此先按顺序提取出色块中的所有颜色，发现颜色的rgb值中各分量只有00与ff两种值，若是将00记为0，将ff记为1，即可得到一个仅由0与1组成的二进制串： 1011100100101001000110000010100100100100101010110010110100011000101010100001110010011010101100100001101000111010001111000011100000110100101100101 因为1 byte=8 bits，所以将上述二进制串每八位分为一组，再将每组转化为十进制，得到一个长度为18的数组： 1[114, 82, 48, 82, 73, 86, 90, 49, 84, 57, 53, 100, 52, 116, 120, 112, 105, 101] 注意到数组内每个数都在128以内，猜测这可能是ascii码值，于是将数组转化为字符串，得到rR0RIVZ1T95d4txpie，即本题的答案。 完整代码（javascript）如下（在审查元素的控制台中运行）： 123456789101112131415161718192021222324252627(function () &#123; // 用正则表达式按顺序获取table中的所有颜色 const text = document.getElementsByClassName(&quot;colormatrix&quot;)[0].innerHTML; let colors = [...text.matchAll(/#([0-9a-f]&#123;2&#125;)([0-9a-f]&#123;2&#125;)([0-9a-f]&#123;2&#125;)/g)]; // 转换为比特 let bits = []; colors.forEach((value) =&gt; &#123; bits.push(value[1] === &quot;00&quot; ? 0 : 1, value[2] === &quot;00&quot; ? 0 : 1, value[3] === &quot;00&quot; ? 0 : 1); &#125;) console.log(bits); // 转换为字符串 let nums = []; let n = 0; while (n &lt; bits.length) &#123; let num = 0; for (let i = 0; i &lt; 8; i++, n++) &#123; num = num * 2 + bits[n] &#125; nums.push(num); &#125; const answer = String.fromCharCode(...nums); // 输出结果 console.log(answer);&#125;)(); Level 01000 | rR0RIVZ1T95d4txpie.html 提示中已经给出这一题是上一题的强化版，因此我们仿照上一题，先提取出表中的所有颜色代码。 从页面获得二进制串 但需要注意的是，上一题所用的使用正则表达式#[0-9a-fA-F]&#123;6&#125;提取颜色代码的方式在这里并不适用，因为表中存在有以下三种形式的单元格： 123&lt;td style=&quot;background:#102024&quot;&gt;&lt;/td&gt;&lt;td style=&quot;background:#040&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; 其中第一种我们在上一题遇到过了，第二种里#040是#004400的简写形式，而第三种，结合.colormatrix上方的样式表： 12345.colormatrix td&#123; width: .5em; height: .5em; background-color: black;&#125; 可知是黑色，即#000000。 因此我们在提取颜色的时候需要兼顾此三种，提取颜色后我们要将其转换为二进制串，完整代码如下（在审查元素的控制台中运行）： 1234567891011121314151617181920212223function getbits()&#123; const blocks=document.getElementsByTagName(&quot;td&quot;); let bits=[]; const black=[0,0,0]; const digits=[7,6,5,4,3,2,1,0]; for(let i=0;i&lt;blocks.length;i++)&#123; let color; if(blocks[i].style.background===&quot;&quot;)&#123; color=black; &#125;else&#123; let c=blocks[i].style.backgroundColor.match(/\\d+/g); color=c.map((value)=&gt;&#123;return Number.parseInt(value)&#125;) &#125; color.forEach((value)=&gt;&#123; bits.push(...digits.map((i)=&gt;&#123; return (value&gt;&gt;i)&amp;1; &#125;)) &#125;) &#125; return bits;&#125;const bits=getbits(); 从bmp文件获得二进制串 在colormatrix的下方有一条注释： 1&lt;!-- http://localhost:4580/PtdqW.bmp --&gt; 这个url（实际线上版本与此不同）指向一张bmp图片，其内容与上方表格相同，因此我们也可以从这里提取颜色。 下载图片后我们用python的Pillow库与numpy库（需要用pip安装）来处理图片： 12345678from PIL import Imageimport numpy as npwith Image.open(&quot;./PtdqW.bmp&quot;, mode=&#x27;r&#x27;) as im: ar = np.array(im)ar = ar.reshape((20*89*3, 1))bits = np.hstack([(ar &gt;&gt; i) &amp; 1 for i in range(7, -1, -1)]) 将二进制串转化为图片 经过上述两个操作的任一个我们都能得到一个含有42720个比特的数组。再结合第二条提示267x160，发现267*160=42720，因此我们只需将数组填入宽160高267的矩阵中即可。 python的完整程序如下： 12345678910111213from matplotlib import pyplot as pltfrom PIL import Imageimport numpy as npwith Image.open(&quot;./PtdqW.bmp&quot;, mode=&#x27;r&#x27;) as im: ar = np.array(im)ar = ar.reshape((20*89*3, 1))bits = np.hstack([(ar &gt;&gt; i) &amp; 1 for i in range(7, -1, -1)])bits = bits.reshape((267, 160))plt.imshow(bits)plt.savefig(&quot;./output.jpg&quot;) 输出的图片如下： 在js中的处理如下（接上个程序，在审查元素的控制台中运行）： 123456789101112131415161718192021222324252627282930function showimg(bits)&#123; const el=document.createElement(&quot;table&quot;); el.className=&quot;colormatrix2&quot;; let k=0; while(k&lt;bits.length)&#123; let tr=document.createElement(&quot;tr&quot;) let t=&#x27;&#x27;; for(let i=0;i&lt;160;i++,k++)&#123; t+=bits[k]?&quot;&lt;td&gt;&lt;/td&gt;&quot;:`&lt;td class=&quot;white&quot;&gt;&lt;/td&gt;`; &#125; tr.innerHTML=t; el.appendChild(tr); &#125; const style=document.createElement(&quot;style&quot;) style.innerHTML=` .colormatrix2 td&#123; width: .1em; height: .1em; background-color: black; &#125; .colormatrix2 td.white&#123; background-color: white; &#125; ` const parent=document.getElementsByClassName(&quot;flexbox&quot;)[0]; parent.appendChild(style); parent.appendChild(el);&#125;showimg(bits); 可以在页面中看到如下图像： 亦可将上面的python程序的后两行改为： 123with open(&quot;a.txt&quot;,&quot;w&quot;) as f: for r in bits: print(*(&quot;*&quot; if i else &#x27; &#x27; for i in r),sep=&quot;&quot;,file=f) 运行程序后，打开a.txt，在合适的字体、字号与行距下可以看到由字符组成的图片。 通过图片我们可以看出这张图中的是埃菲尔铁塔，其英文名是The Eiffel Tower或Eiffel Tower，又因为题目要求“答案为由驼峰命名法（首字母小写）结合而成的三个单词”，所以答案是theEiffelTower。 注：图片来源：https://commons.wikimedia.org/wiki/File:Eiffel_Tower_1945.jpg 原图属于公有领域，在引用时做了亿点点处理以压缩体积。 Level 01001 | theEiffelTower.html Base64解码 首先观察题目给的数据，根据提示得知这是使用base64编码的二进制数据，因此首先使用base64对其解码。 1234from base64 import b64decodedata = b64decode(&quot;ASJcDiBgWReEMk5KyjCGSOi0OQNT&quot;)print(data) 得到一串二进制数据： 1b&#x27;\\x01&quot;\\\\\\x0e `Y\\x17\\x842NJ\\xca0\\x86H\\xe8\\xb49\\x03S&#x27; 校验 根据提示，接下来要用汉明码进行校验，因此先将其转化为仅含0与1的数组： 123bits = [i for n in data for i in map( lambda power:(n &gt;&gt; power) &amp; 1, range(7, -1, -1))]print(*bits,sep=&quot;&quot;) 输出 1000000010010001001011100000011100010000001100000010110010001011110000100001100100100111001001010110010100011000010000110010010001110100010110100001110010000001101010011 然后校验： 1234567891011from functools import reducepow = 1while (1 &lt;&lt; pow)-1 &lt; len(bits): pow += 1parities = [0]*powfor digit in range(pow): parities[-digit-1] = reduce(lambda x, y: x ^ y, (v for i, v in enumerate(bits) if (i+1 &gt;&gt; digit) &amp; 1), 0)print(parities) 输出：[0, 0, 0, 1, 1, 0, 0, 0]，(00011000)2=24(00011000)_2=24(00011000)2​=24，说明从1开始数的第24位发生了翻转（当然也可能有多位发生了翻转，不过那样题目就做不下去了，故不在考虑范围内），因此对数组的第23位进行修正： 1bits[23]=0 if bits[23] else 1 然后剔除数据中的校验位： 12checkedbits = [v for i, v in enumerate(bits) if i &amp; (i+1)]print(*checkedbits,sep=&quot;&quot;) 得到： 10000001000101011101000011100100000011000000101100100010111000010000110010010011100100101011001010001100001000011001001001110100010110100001110010000001101010011 解码 根据提示的第三条Zeckendorf定理我们可以在搜索引擎中找到其在编码领域的应用，即斐波那契编码。斐波那契编码仅有0与1组成，其中每一位的位值都对应一个斐波那契数，将斐波那契编码中为1的位对应的位值求和即可得到编码表示的十进制数，例如(1010101)fib=21+8+3+1=33(1010101)_{fib}=21+8+3+1=33(1010101)fib​=21+8+3+1=33。Zeckendorf定理能确保在合适的条件下，一个数在斐波那契编码中不会出现两个连续的1。若是在每个数的末尾补充一个1，这个1与下一个数首位的1连在一起形成“11”，我们可以据此区分编码串中相邻的两个数： 若出现连续的两个1，则上一个数以0结尾，以第一个1作为分隔符； 若出现连续的三个1，则上一个数以1结尾，以第二个1作为分隔符。 上面的二进制串可以依此法分为： 1000000100010101 10100001 1001000000 100000010 1001000101 1000010000 1001001001 1001001010 100101000 1000010000 1001001001 10100010 10100001 1001000000 10101001 然后将斐波那契编码转换为十进制，得到： 167 48 110 57 114 97 116 117 73 97 116 49 48 110 53 最后按ascii码表转换为字符，得到答案：C0n9ratuIat10n5 解码的代码如下： 12345678910111213141516171819202122# 斐波那契数列fib = [1, 1]while fib[-1] &lt;= 1024: fib.append(fib[-2]+fib[-1])checkedbits.pop() # 忽略最后一个数末尾添的1nums = []n, lastbit, p = 0, 0, 1for i in reversed(checkedbits): if i and lastbit: nums.append(n) n, lastbit, p = 0, 0, 1 else: if i: n += fib[p] lastbit = i p += 1if n: nums.append(n)answer = &#x27;&#x27;.join(map(chr, reversed(nums)))print(answer) Bonus的获取方法 Bonus 0: iWNDvqJY 在Level 0打开审查元素，发现在文字的第二、三段之间隐藏了一个元素： 1&lt;p style=&quot;display: none;&quot;&gt;Bonus0: iWNDvqJY&lt;/p&gt; Bonus 1: 8864TTQNpplh 在Level 6中穷举时可以得到两个存在的页面，其中8642TQNKplhd指向Level 7，另一个8864TTQNpplh即为Bonus 1。 Bonus 2: laTourEiffel 在Level 8得到答案前的最后一步，法文单词怎么能不算单词呢（逃）。","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Pandora","slug":"Pandora","permalink":"https://sumsc-caa.github.io/tags/Pandora/"},{"name":"前端","slug":"前端","permalink":"https://sumsc-caa.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"2021 魔盒挑战 第一期","slug":"Pandora-2021-1","date":"2021-11-25T00:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/11/25/Pandora-2021-1/","link":"","permalink":"https://sumsc-caa.github.io/2021/11/25/Pandora-2021-1/","excerpt":"","text":"Welcome! 欢迎来到 2021 年魔盒挑战第一期！ ❓ 什么是魔盒挑战 又到了技术组招新的时候了。 我们决定发布一项 魔盒挑战 来挑选与我们同行的勇士们！ 各位挑战者将收到一个装有通往技术组“钥匙”的 神秘盒子，挑战者需要运用自己的渊博知识 打开魔盒，完成的挑战者将会获得前往技术组的邀请函。 🔍 如何参与 本期魔盒挑战的时间为：2021年11月25日 12:00 —— 2021年12月2日 23:59，为期一周。 请各位参与本次魔盒挑战的同学在QQ群（497516494）中参与群投票，以便我们能更好地了解各位的题目选择情况。 你一共有七天时间来完成这个挑战，无论你是提前完成了挑战，还是时限内未能到达终点，最后都请将你得到的所有答案按照下列要求发送邮件至sumstc@outlook.com。邮件请以 Pandora-2021-1-[参与题目] [姓名] [学号] 命名，请根据各题目要求上传附件。 🔔 本期主题 本期的主题是【Web前端技术】，共有三个题目可供你选择（数量不限）。 各题目传送门：【各题目链接需要在 SUDA_WIFI 环境下访问】 网页迷宫篇：10.10.65.208:8080/maze Web备忘录篇：10.10.65.208:8080/memo 论CSS的妙用：10.10.65.208:8080/css 🔑 考察点 HTML 超文本标记语言 CSS 层叠样式表 JavaScript 解释型语言 🎁 奖品设置 前 5 名完整解决的同学会有神秘礼品！ 奖品由微软亚洲研究院赞助。 📄 参赛协议 参赛者自愿参加本次活动； 参赛获奖者请在获悉中奖信息后尽快联系活动主办方或直接前往俱乐部实验室（理工楼110）领取奖品； 参赛者参与本次活动，默认同意本协议的所有内容。 参赛守则 参赛者应承诺： 不对比赛设施（包括但不限于网站、服务器、数据库）进行任何非法操作； 在活动中使用本人真实信息； 独立参赛，不得给予、借鉴、抄袭其他参赛者的成果；不得出于任何目的采用任何手段攻击比赛设施、其他参与者的设备。 参赛者如有上述违规行为，苏州大学计算机爱好者协会（微软学生俱乐部）有权取消您的参赛成绩和资格。 用户隐私 本次活动可能会涉及到您的学号。 我们承诺不会收集任何用户隐私信息，您的学号仅用于验证本人的真实信息； 我们承诺活动结束后删除所有用户隐私数据。 活动最终解释权归苏州大学计算机爱好者协会（微软学生俱乐部）所有。 2021 苏州大学计算机爱好者协会（微软学生俱乐部）版权所有","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Pandora","slug":"Pandora","permalink":"https://sumsc-caa.github.io/tags/Pandora/"},{"name":"前端","slug":"前端","permalink":"https://sumsc-caa.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"2021 Hackathon：Pygame and Turtle","slug":"hackathon2021","date":"2021-11-05T22:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/11/05/hackathon2021/","link":"","permalink":"https://sumsc-caa.github.io/2021/11/05/hackathon2021/","excerpt":"","text":"苏州大学计算机爱好者协会 Hackathon 2021 赛题 以下两题任选一题完成即可。 Q1： 贪吃蛇、俄罗斯方块、吃豆人、太空侵略者、打砖块……这些都是在街机游戏的黄金年代涌现出的风靡西方世界的小游戏[ref:1]，它们规则简单但是乐趣无穷，成为了一代西方人的童年回忆。现如今，随着计算机性能的飞速发展和智能手机的普及，电子游戏日新月异，这些小游戏也早已成为历史。 现在请你们运用自己的编程知识，让这些小游戏重获新生。有以下四个方向供你们选择： 实现一个命令行小游戏。demo：贪吃蛇demo 用pygame库实现一个小游戏。demo：俄罗斯方块demo 以我们在(1)或(2)中提供的demo为基础，在此之上试着增加游戏规则，从而让它更富有游戏性和挑战性。 例如：增加障碍物，随着得分的增长增加蛇的速度 以(1)或(2)为基础（我们提供的demo也可以），为小游戏中的玩家角色添加AI。 提示 实现的小游戏不必局限于街机游戏和上世纪七八十年代，你能想到的玩法简单的小游戏，例如井字棋、五子棋、flappy bird或者文字冒险游戏都可以作为目标。 关于pygame库的安装 Windows 按Win+R，在弹出的窗口中输入cmd，按确定，在命令提示符中输入 1pip install pygame 然后回车执行。 若提示'pip' 不是内部或外部命令，也不是可运行的程序，请检查是否安装python和pip，并已经将python所在路径加入环境变量Path。 Q2： 在信息技术与社交网络的不断发展中，人们之间的交流方式也从单纯的文字变得越来越丰富多彩，逐步演变为多元的表情文化。后来随着P图、截图技术平民化，越来越多的人开始使用一些自制的图片来进行沟通。这类图片构图夸张，内容丰富，以搞笑居多，或迎合网络文化，或表达共鸣情感。我们通过收藏和分享此类图片，让沟通变得更丰富有趣。[ref:2] 请在python中使用小海龟（turtle库）绘制一幅或几幅你喜欢的表情或图片。 demo：（请右键另存为） 滑稽：huaji.py 捂脸：wulian.py 提示 请确保你绘制的图片适合在公共场合公开展示。 可能有用的网址 python 3.10.0 官方文档：https://docs.python.org/zh-cn/3/ python官方教程：https://docs.python.org/zh-cn/3/tutorial/index.html turtle库参考文档：https://docs.python.org/zh-cn/3/library/turtle.html pygame官方文档（英文）：https://www.pygame.org/docs/ References Arcade game - Wikipedia 表情包 - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn)","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"2021 Hackathon | Tetris","slug":"hackathon2021-q2-tetris","date":"2021-11-05T21:57:23.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/11/05/hackathon2021-q2-tetris/","link":"","permalink":"https://sumsc-caa.github.io/2021/11/05/hackathon2021-q2-tetris/","excerpt":"","text":"Tetris0.0.2 简介 返回比赛题目 demo作者：苏州大学计算机爱好者协会（微软学生俱乐部）- 技术组 - 邓宏灿 这是一个使用 pygame 制作的一个俄罗斯方块游戏(Tetris) 主要运用了面向结构的编程思想 游戏结束时会显示结束语和当前分数 操作 基本按键 A ,D 左右移动方块 S 加快方块下落 J 旋转方块 速度调节 修改代码开头的SPEED变量，注意数字越小速度越快。 下载 tetris.py （请右键另存为） 有待改进之处 没有对旋转行为进行判定，在方块密集的地方旋转会出现问题 长按时作出多次响应 为方块添加颜色 在游戏界面内显示分数 在游戏界面内显示之后方块的顺序 提供切换方块的功能 随着时间逐渐增加游戏速度 ……","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"2021 Hackathon | 贪吃蛇","slug":"hackathon2021-q1-snake","date":"2021-11-05T21:57:14.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/11/05/hackathon2021-q1-snake/","link":"","permalink":"https://sumsc-caa.github.io/2021/11/05/hackathon2021-q1-snake/","excerpt":"","text":"贪吃蛇demo 说明 返回比赛题目 demo作者：苏州大学计算机爱好者协会（微软学生俱乐部）- 技术组 - 王嘉睿 用python制作的在命令行中运行的贪吃蛇小游戏。 在cmd/powershell或linux/MacOS的终端（建议将终端的字体设为等宽字体）中输入 1&gt; python snake.py 随后程序会立即开始运行。 操作 w：向上运动 a：向左运动 s：向下运动 d：向右运动 下载 snake.py （请右键另存为） 有待改进之处 随着分数增加游戏速度 增加障碍物 为蛇和食物添加不同颜色（见 https://pypi.org/project/colorama/ ） 从命令行参数获取游戏地图的设置。例如运行python snake.py 30 20 -f 2得到的游戏地图的长宽分别为30，20，其中有2个食物（见 https://docs.python.org/zh-cn/3/library/argparse.html ） ……","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"Python 指南 (1)","slug":"python2021-1","date":"2021-10-02T07:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/10/02/python2021-1/","link":"","permalink":"https://sumsc-caa.github.io/2021/10/02/python2021-1/","excerpt":"","text":"推荐大家6本Python入门书籍 前言 我在逛各大媒体的时候，发现大家都有一个问题，就是不知道入门看什么书籍好，总是在问答上要大家推荐书籍，这些人推荐的质量都是参差不齐， 本节为大家推荐6本高效率的书籍（总有一本适合你），非常适合初学者，我们一边看书籍一边结合视频来看， 你的进步会神速。 1.Python编程快速上手 现在，人们面临的大部分任务都可以通过编写计算机软件来完成。Python是一种解释性、面向对象、动态数据类型的高级编程语言。通过python编程，我们可以解决现实生活中的许多任务。 本书是一本实用的Python编程实践指南。本书的目的不仅是介绍Python语言的基本知识，而且通过项目实践来教读者如何应用这些知识和技能。本书的第一部分介绍了基本的Python编程概念。第二部分介绍了一些不同的任务。通过编写python程序，计算机可以自动完成它们。第二部分的每一章都有一些项目程序供读者学习。在每章的最后，提供一些练习和深入的实践项目，以帮助读者巩固他们的知识。附录提供了所有练习的答案。 本书适用于任何想通过Python学习编程的人，尤其是那些缺乏编程基础的初学者。 2.笨办法学Python 这本书是一本python入门书。它适用于对计算机知之甚少、未学过编程，但对编程感兴趣的读者。本书以练习的方式指导读者逐步学习编程，从简单的打印到整个项目的实现，使初学者能够从基本的编程技术入手，最终体验到软件开发的基本过程。 这本书的结构很简单。它包括52个练习，其中26个涉及三个主题：输入/输出、变量和函数。其他26个主题涉及更高级的主题，例如条件判断、循环、类和对象、代码测试和项目实现。每章的格式基本相同。从代码练习开始，按照说明编写代码，运行并检查结果，然后再做其他练习。 3.python编程初学者指南 Python是一种解释性、面向对象、动态数据类型的高级编程语言。从科学计算到游戏开发，python可以用于许多领域。 小编推荐一个学python的学习qun 740,3222,34 无论你是大牛还是小白，是想转行还是想入行都可以来了解一起进步一起学习！裙内有开发工具，很多干货和技术资料分享！ 《Python编程入门指南》试图帮助初学者轻松有趣地掌握Python语言和编程技能。 《Python编程入门指南》共有12章，每章将用一个完整的游戏来演示关键知识点，并通过编写有趣的小软件来学习编程，激发读者的兴趣，降低学习难度。在每一章的结尾，将对本章的知识点进行总结，并给出一些练习，供读者试一试。作者巧妙地将所有的编程知识嵌入到这些例子中，真正达到了教学和欣赏的目的。”《python programming初学者指南》是一本易懂、简单生动的示例，是国际上最畅销的python初学者指南，适合对python学习感兴趣的初级和中级读者参考。 4.Python3程序开发指南（第二版） 《python 3程序开发指南》描述了python语言的八个关键元素，分别在不同的章节中阐述，包括数据类型、控制结构和功能、模块、文件处理、调试、进程和线程、网络、数据库、正则表达式、GUI编程等。这本书的主要内容是举例说明。练习题附在每一章的后面，可以帮助读者更好地理解和掌握内容。它非常适合使用Python语言教科书，对Python程序员有一定的参考价值。 5.pythonCookBook 本书介绍了Python在各个领域的一些技术和方法，从基本字符、文件序列、字典和排序到高级面向对象编程、数据库和数据持久性、XML处理和Web编程，到高级和抽象的描述符、修饰器、元类、迭代器和生成器。但是这本书很重，你可以把它放在你的手上阅读，书中有很多经验，当你的思想被阻塞时会给你灵感。 6.爱上Python一日精通Python 本书将复杂的概念分解为简单的步骤，以确保没有编程经验的读者能够轻松掌握Python。本书中讨论的所有概念都通过精心选择的Python示例进行了说明。 其实不论什么书籍，只要你多练多写项目多思考就一定能进步，不同的书籍适合不同人，总之一句话我们要付出努力才能有收获。 Python 学习路线 前言 一直以来都有很多想学习Python的朋友们问我，学Python怎么学？爬虫和数据分析怎么学？web开发的学习路线能教教我吗？ 我先告诉大家一个点，不管你是报了什么培训班，还是自己在通过各种渠道自学，你一定要注重一个东西：完整的知识体系。 感觉很迷茫？学了一段时间还是不入流？很大一部分原因是因为你没有一个完整的知识体系，你不知道自己现在的进度、未来的方向。 端午三天，虽然回了乡下，但还是抽时间去做了Python所有方向的学习路线，今天分享给大家。 一、Python入门 初学者都会比较好奇，学了这么久Python，什么程度才叫入门了呢？ 每个人对技术的认知都不尽相同，在我个人看来，你学完以下这些东西就可以算是入门了，为什么？因为以下这些东西是Python进阶各个方向都必备的基础知识，你进阶去学爬虫或者web开发等方向，你都得先学会它们。 因为知识点放在一起比较多，我把它们稍加区分成基础和高级编程两块，对于每一个自学的人，按照这个体系去打好基础，你未来的路会走得更稳重。 适用人群：零基础/基础不扎实者，学Python都从这里开始 二、爬虫 爬虫作为一个热门的方向，不管是在自己兼职还是当成辅助技能提高工作效率，都是很不错的选择，当然了，还有一些以此为主职业的爬虫工程师。 那么爬虫怎么学习才能成体系？中级水平的爬虫所需要的东西不是很多，参考这个体系去学习，如果能掌握90%,你可以很自信地说你已经精通爬虫。 适用人群：爬虫方向/数据分析方向/非程序员加薪 三、数据分析 谁都知道数据是这个时代最为宝贵的东西，但有一个前提就是，你拿到的数据你得懂，一切发挥不出应有功效的数据都是垃圾数据。 数据分析的使命就是发挥数据应有的作用：直接作用和间接作用。 如果你是从事大数据相关工作的IT人士，我建议你掌握但不要止步于下面的数据体系，不要以为会了Numpy、Pandas、Matplotlib就是会了数据分析，真正强大的东西还在后面。 如果你是把数据分析当成一个辅助技能，那么学完下面这些就差不多，它们能满足你大多数的需求。有些小伙伴可能还是非计算机专业且从事非IT类的工作，比如说运营之类的岗位，那么我建议大家学Python入门+爬虫+数据分析就可以了，它们足以提升你在职场的工作效率，不用去全栈、测试等方向浪费时间，对你没什么大的帮助。 适用人群：爬虫方向/数据分析方向/非程序员加薪 四、web开发（前/后端） web开发是程序员职业中的热门，目前来讲，人才缺口依然很大。web开发分为前端、后端、全栈3个方向，目前国内主流的还是前后端分离，前端主要考虑用户体验，后端主要考虑底层业务逻辑、平台稳定和性能，最主要是要看你想做哪一部分？你是喜欢做用户看得见的部分，还是考虑用户看不见的部分。 至于全栈，舆论一直很大，褒贬不一，我的建议是如果时间和精力允许，在技术上追求更全面是不会错的。 适用人群：前端/后端/全栈工程师 五、自动化测试 自动化测试已是未来的一种趋势，现在很多的企业都要求程序员具备自动化测试的能力，而对于自动化测试这个领域来讲，Python是目前最合适的语言。 适用人群：程序员/测试工程师 六、机器学习 机器学习是通往人工智能的必经之路，难度也比前面的大很多，与算法打交道是家常便饭，高付出也会带来高回报，薪资待遇很不错。虽然Python在这方面确实很强，但提醒大家一点，这个领域的门槛比较高，本科生基本无缘，建议上了硕士以上学历再考虑进入这个行业。 寄语 上面就是Python所有方向的学习路线了，把你感兴趣的方向掌握了90%之后，你去找工作不是什么问题的。 有些细心的朋友可能会发现，我没放人工智能的学习路线。说实在的，人工智能比机器学习要广泛很多，它已经不是某一门语言就能单独完成的事情了，所以这里不做推荐。 同样的，网络安全工程师我也没有放进去谈，虽然Python也能做网络安全方面的事情，但对于一个成熟的网络安全工程师甚至红、H客而言，你需要精通的语言可不止1门而已了，又或者说，这已经不是语言工具层面的问题了。 参考资料 CSDN. python爬虫学习: 推荐大家6本Python入门书籍. https://blog.csdn.net/qq_39363022/article/details/87949392 CSDN. 退休的龙叔: Python所有方向的学习路线，你们要的知识体系在这，千万别做了无用功. https://blog.csdn.net/zhiguigu/article/details/117924606","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"}]},{"title":"Python 指南 (turtle)","slug":"python2021-turtle","date":"2021-10-02T07:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/10/02/python2021-turtle/","link":"","permalink":"https://sumsc-caa.github.io/2021/10/02/python2021-turtle/","excerpt":"","text":"Python turtle 参考资料 入门 实例 色彩模式 RGB色彩模式","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"}]},{"title":"Python 指南 (2)","slug":"python2021-2","date":"2021-10-02T07:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/10/02/python2021-2/","link":"","permalink":"https://sumsc-caa.github.io/2021/10/02/python2021-2/","excerpt":"","text":"什么是 Python Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。 Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子： 123456# print absolute value of an integer:a = 100if a &gt;= 0: print(a)else: print(-a) 以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。 缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的惯例，应该始终坚持使用4个空格的缩进。 缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。 缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。 最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。 数据类型 计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种： 整数 Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。 浮点数 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串 字符串是以单引号'或双引号&quot;括起来的任意文本，比如'abc'，&quot;xyz&quot;等等。请注意，''或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I'm OK&quot;包含的字符是I，'，m，空格，O，K这6个字符。 如果字符串内部既包含'又包含&quot;怎么办？可以用转义字符\\来标识，比如： 1&#x27;I\\&#x27;m \\&quot;OK\\&quot;!&#x27; 表示的字符串内容是： 1I&#x27;m &quot;OK&quot;! 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看： 12345678&gt;&gt;&gt; print(&#x27;I\\&#x27;m ok.&#x27;)I&#x27;m ok.&gt;&gt;&gt; print(&#x27;I\\&#x27;m learning\\nPython.&#x27;)I&#x27;m learningPython.&gt;&gt;&gt; print(&#x27;\\\\\\n\\\\&#x27;)\\\\ 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试： 1234&gt;&gt;&gt; print(&#x27;\\\\\\t\\\\&#x27;)\\ \\&gt;&gt;&gt; print(r&#x27;\\\\\\t\\\\&#x27;)\\\\\\t\\\\ 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试： 123456&gt;&gt;&gt; print(&#x27;&#x27;&#x27;line1... line2... line3&#x27;&#x27;&#x27;)line1line2line3 上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入，注意...是提示符，不是代码的一部分： 123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - python _ □ x │├────────────────────────────────────────────────────────┤│&gt;&gt;&gt; print(&#x27;&#x27;&#x27;line1 ││... line2 ││... line3&#x27;&#x27;&#x27;) ││line1 ││line2 ││line3 ││ ││&gt;&gt;&gt; _ ││ ││ ││ │└────────────────────────────────────────────────────────┘ 当输入完结束符`````和括号)后，执行该语句并打印结果。 如果写成程序并存为.py文件，就是： 123print(&#x27;&#x27;&#x27;line1line2line3&#x27;&#x27;&#x27;) 布尔值 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来： 12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为True，and运算结果才是True： 12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True or运算是或运算，只要其中有一个为True，or运算结果就是True： 12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3True not运算是非运算，它是一个单目运算符，把True变成False，False变成True： 123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True 布尔值经常用在条件判断中，比如： 1234if age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;teenager&#x27;) 空值 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。 变量 变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如： 1a = 1 变量a是一个整数。 1t_007 = &#x27;T007&#x27; 变量t_007是一个字符串。 1Answer = True 变量Answer是一个布尔值True。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： 12int a = 123; // a是整数类型变量a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 请不要把赋值语句的等号等同于数学的等号。比如下面的代码： 12x = 10x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 最后，理解变量在计算机内存中的表示也非常重要。当我们写： 1a = &#x27;ABC&#x27; 时，Python解释器干了两件事情： 在内存中创建了一个'ABC'的字符串； 在内存中创建了一个名为a的变量，并把它指向'ABC'。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据。 最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'，让我们一行一行地执行代码，就可以看到到底发生了什么事： 执行a = 'ABC'，解释器创建了字符串'ABC'和变量a，并把a指向'ABC'： 执行b = a，解释器创建了变量b，并把b指向a指向的字符串'ABC'： 执行a = 'XYZ'，解释器创建了字符串’XYZ’，并把a的指向改为'XYZ'，但b并没有更改： 所以，最后打印变量b的结果自然是'ABC'了。 常量 所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量： 1PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/： 12&gt;&gt;&gt; 10 / 33.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数： 12&gt;&gt;&gt; 10 % 31 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 字符编码 我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件： 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器： 所以你看到很多网页的源码上会有类似&lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的UTF-8编码。 Python的字符串 搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。 在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如： 12&gt;&gt;&gt; print(&#x27;包含中文的str&#x27;)包含中文的str 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord(&#x27;A&#x27;)65&gt;&gt;&gt; ord(&#x27;中&#x27;)20013&gt;&gt;&gt; chr(66)&#x27;B&#x27;&gt;&gt;&gt; chr(25991)&#x27;文&#x27; 如果知道字符的整数编码，还可以用十六进制这么写str： 12&gt;&gt;&gt; &#x27;\\u4e2d\\u6587&#x27;&#x27;中文&#x27; 两种写法完全是等价的。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b&#x27;ABC&#x27; 要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12345678&gt;&gt;&gt; &#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)b&#x27;ABC&#x27;&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;ascii&#x27;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)&#x27;ABC&#x27;&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;.decode(&#x27;utf-8&#x27;)&#x27;中文&#x27; 如果bytes中包含无法解码的字节，decode()方法会报错： 1234&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xff&#x27;.decode(&#x27;utf-8&#x27;)Traceback (most recent call last): ...UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 3: invalid start byte 如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节： 12&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)&#x27;中&#x27; 要计算str包含多少个字符，可以用len()函数： 1234&gt;&gt;&gt; len(&#x27;ABC&#x27;)3&gt;&gt;&gt; len(&#x27;中文&#x27;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： 123456&gt;&gt;&gt; len(b&#x27;ABC&#x27;)3&gt;&gt;&gt; len(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)6&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码： 如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文： 格式化 最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似'亲爱的xxx你好！你xx月的话费是xx，余额是xx'之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 1234&gt;&gt;&gt; &#x27;Hello, %s&#x27; % &#x27;world&#x27;&#x27;Hello, world&#x27;&gt;&gt;&gt; &#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)&#x27;Hi, Michael, you have $1000000.&#x27; 你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 常见的占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 12print(&#x27;%2d-%02d&#x27; % (3, 1))print(&#x27;%.2f&#x27; % 3.1415926) 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串： 12&gt;&gt;&gt; &#x27;Age: %s. Gender: %s&#x27; % (25, True)&#x27;Age: 25. Gender: True&#x27; 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： 12&gt;&gt;&gt; &#x27;growth rate: %d %%&#x27; % 7&#x27;growth rate: 7 %&#x27; format() 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符&#123;0&#125;、&#123;1&#125;……，不过这种方式写起来比%要麻烦得多： 12&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125)&#x27;Hello, 小明, 成绩提升了 17.1%&#x27; f-string 最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含&#123;xxx&#125;，就会以对应的变量替换： 1234&gt;&gt;&gt; r = 2.5&gt;&gt;&gt; s = 3.14 * r ** 2&gt;&gt;&gt; print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;)The area of a circle with radius 2.5 is 19.62 上述代码中，&#123;r&#125;被变量r的值替换，&#123;s:.2f&#125;被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，&#123;s:.2f&#125;的替换结果是19.62。 list Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 123&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 变量classmates就是一个list。用len()函数可以获得list元素的个数： 12&gt;&gt;&gt; len(classmates)3 用索引来访问list中每一个位置的元素，记得索引是从0开始的： 12345678910&gt;&gt;&gt; classmates[0]&#x27;Michael&#x27;&gt;&gt;&gt; classmates[1]&#x27;Bob&#x27;&gt;&gt;&gt; classmates[2]&#x27;Tracy&#x27;&gt;&gt;&gt; classmates[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： 12&gt;&gt;&gt; classmates[-1]&#x27;Tracy&#x27; 以此类推，可以获取倒数第2个、倒数第3个： 12345678&gt;&gt;&gt; classmates[-2]&#x27;Bob&#x27;&gt;&gt;&gt; classmates[-3]&#x27;Michael&#x27;&gt;&gt;&gt; classmates[-4]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 当然，倒数第4个就越界了。 list是一个可变的有序表，所以，可以往list中追加元素到末尾： 123&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;] 也可以把元素插入到指定的位置，比如索引号为1的位置： 123&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;] 要删除list末尾的元素，用pop()方法： 1234&gt;&gt;&gt; classmates.pop()&#x27;Adam&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置： 1234&gt;&gt;&gt; classmates.pop(1)&#x27;Jack&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： 123&gt;&gt;&gt; classmates[1] = &#x27;Sarah&#x27;&gt;&gt;&gt; classmates[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;] list里面的元素的数据类型也可以不同，比如： 1&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True] list元素也可以是另一个list，比如： 123&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]&gt;&gt;&gt; len(s)4 要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了： 12&gt;&gt;&gt; p = [&#x27;asp&#x27;, &#x27;php&#x27;]&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, p, &#x27;scheme&#x27;] 要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。 如果一个list中一个元素也没有，就是一个空的list，它的长度为0： 123&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0 tuple 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字： 1&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;) 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如： 123&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2) 如果要定义一个空的tuple，可以写成()： 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; t() 但是，要定义一个只有1个元素的tuple，如果你这么定义： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。 最后来看一个“可变的”tuple： 12345&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;&gt;&gt;&gt; t(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;]) 这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？ 别急，我们先看看定义的时候tuple包含的3个元素： 当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为： 表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 dict Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list： 12names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]scores = [95, 75, 85] 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。 如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下： 123&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;&gt;&gt;&gt; d[&#x27;Michael&#x27;]95 为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。 第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。 dict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入： 123&gt;&gt;&gt; d[&#x27;Adam&#x27;] = 67&gt;&gt;&gt; d[&#x27;Adam&#x27;]67 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 123456&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 90&gt;&gt;&gt; d[&#x27;Jack&#x27;]90&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 88&gt;&gt;&gt; d[&#x27;Jack&#x27;]88 如果key不存在，dict就会报错： 1234&gt;&gt;&gt; d[&#x27;Thomas&#x27;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#x27;Thomas&#x27; 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： 12&gt;&gt;&gt; &#x27;Thomas&#x27; in dFalse 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value： 123&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;)&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;, -1)-1 注意：返回None的时候Python的交互环境不显示结果。 要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 1234&gt;&gt;&gt; d.pop(&#x27;Bob&#x27;)75&gt;&gt;&gt; d&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125; 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。 要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key： 12345&gt;&gt;&gt; key = [1, 2, 3]&gt;&gt;&gt; d[key] = &#x27;a list&#x27;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &#x27;list&#x27; set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 要创建一个set，需要提供一个list作为输入集合： 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 注意，传入的参数[1, 2, 3]是一个list，而显示的&#123;1, 2, 3&#125;只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。 重复元素在set中自动被过滤： 123&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; 通过remove(key)方法可以删除元素： 123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。 再议不可变对象 上面我们讲了，str是不变对象，而list是可变对象。 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如： 1234&gt;&gt;&gt; a = [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 而对于不可变对象，比如str，对str进行操作呢： 12345&gt;&gt;&gt; a = &#x27;abc&#x27;&gt;&gt;&gt; a.replace(&#x27;a&#x27;, &#x27;A&#x27;)&#x27;Abc&#x27;&gt;&gt;&gt; a&#x27;abc&#x27; 虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？ 我们先把代码改成下面这样： 123456&gt;&gt;&gt; a = &#x27;abc&#x27;&gt;&gt;&gt; b = a.replace(&#x27;a&#x27;, &#x27;A&#x27;)&gt;&gt;&gt; b&#x27;Abc&#x27;&gt;&gt;&gt; a&#x27;abc&#x27; 要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'： 123┌───┐ ┌───────┐│ a │─────────────────&gt;│ &#x27;abc&#x27; │└───┘ └───────┘ 当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了： 123456┌───┐ ┌───────┐│ a │─────────────────&gt;│ &#x27;abc&#x27; │└───┘ └───────┘┌───┐ ┌───────┐│ b │─────────────────&gt;│ &#x27;Abc&#x27; │└───┘ └───────┘ 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 条件判断 计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现： 1234age = 20if age &gt;= 18: print(&#x27;your age is&#x27;, age) print(&#x27;adult&#x27;) 根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。 也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了： 1234567age = 3if age &gt;= 18: print(&#x27;your age is&#x27;, age) print(&#x27;adult&#x27;)else: print(&#x27;your age is&#x27;, age) print(&#x27;teenager&#x27;) 注意不要少写了冒号:。 当然上面的判断是很粗略的，完全可以用elif做更细致的判断： 1234567age = 3if age &gt;= 18: print(&#x27;adult&#x27;)elif age &gt;= 6: print(&#x27;teenager&#x27;)else: print(&#x27;kid&#x27;) elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是： 12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager： 1234567age = 20if age &gt;= 6: print(&#x27;teenager&#x27;)elif age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;kid&#x27;) if判断条件还可以简写，比如写： 12if x: print(&#x27;True&#x27;) 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。 再议 input 最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思： 12345birth = input(&#x27;birth: &#x27;)if birth &lt; 2000: print(&#x27;00前&#x27;)else: print(&#x27;00后&#x27;) 输入1982，结果报错： 123Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unorderable types: str() &gt; int() 这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情： 123456s = input(&#x27;birth: &#x27;)birth = int(s)if birth &lt; 2000: print(&#x27;00前&#x27;)else: print(&#x27;00后&#x27;) 再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息： 123Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#x27;abc&#x27; 原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。 循环 要计算1+2+3，我们可以直接写表达式： 12&gt;&gt;&gt; 1 + 2 + 36 要计算1+2+3+…+10，勉强也能写出来。 但是，要计算1+2+3+…+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 123names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names: print(name) 执行这段代码，会依次打印names的每一个元素： 123MichaelBobTracy 所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。 再比如我们想计算1-10的整数之和，可以用一个sum变量做累加： 1234sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] range(101)就可以生成0-100的整数序列，计算如下： 123456789sum = 0for x in range(101): sum = sum + xprint(sum)&#x27;&#x27;&#x27;output:5050&#x27;&#x27;&#x27; 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 break 在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字： 12345n = 1while n &lt;= 100: print(n) n = n + 1print(&#x27;END&#x27;) 上面的代码可以打印出1~100。 如果要提前结束循环，可以用break语句： 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print(&#x27;END&#x27;) 执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。 可见break的作用是提前结束循环。 continue 在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。 1234n = 0while n &lt; 10: n = n + 1 print(n) 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环： 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。 参考资料 廖雪峰的Python教程. https://www.liaoxuefeng.com/wiki/1016959663602400/","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"}]},{"title":"计算机爱好者协会2021招新宣传文案","slug":"caa2021","date":"2021-09-29T16:32:49.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/09/29/caa2021/","link":"","permalink":"https://sumsc-caa.github.io/2021/09/29/caa2021/","excerpt":"","text":"又到了开学季，小21们就要来到美丽的苏大校园啦~ 别急，俱乐部宣传这就来啦~ 自我介绍 我们是苏州大学计算机爱好者协会——苏州大学计算机科学与技术学院的学术性社团，成立于2004年，原苏州大学微软学生俱乐部（2015年苏计算机科学与技术学院与微软亚洲研究院联合成立），现为微软开源学习社群的联络社团。 我们是一个充满热情，富有开拓精神的新锐团体，在对技术保持的严谨的同时也不缺乏乐观活泼的生活态度。 我们的理念 我们本着“学习先进技术，开拓创新思维，体验多元文化，成就一流人才”的宗旨，线上开源社群与线下技术学习相结合，线上通过课程共建、知识共享、团队共创，培养社团成员的开源思想、创新头脑、实践能力和组织能力，助力所有学生从开源社区同获益、共成长；线下通过学术讲座、技术沙龙、兴趣小组、大型比赛、参观访问等活动，为会员提供开阔视野，探索前沿IT技术，接触最新学术成果，培养管理能力的机会，培养会员的创新头脑、实践能力和组织能力，让来自不同领域的同学得以展现才华，共同成长。我们的使命是为学生的成长提供良好的平台，为高校顶尖人才培养贡献一份力量。 “予力每一位俱乐部成员，成就非凡！” 精彩回顾 在这里，你们可以学到许许多多课本以外的知识，可以提升实际工程能力，还可以探讨学术问题，无论是coding，还是科研，亦或是美工，甚至是团建……在这里，你总能发现不一样的你。 精彩活动 Python讲座 Python是当前最流行的计算机编程语言之一，也是我们学校计算机相关专业同学的大一必修课程。但初入大学校园的你对这门课程是不是有着一丝疑虑？ 别担心，我们为大家准备了一份开学大礼。Python讲座由计算机学院精通编程之道的高年级学长学姐主讲，不仅会系统性的为大家讲解Python这门语言，而且会与同学们深入交流学习计算机语言的过程中遇到的问题，为大家答疑解惑。 Hackathon（编程马拉松） Hackathon是流传于电脑迷中的一种活动，你需要做的是和你的队友在有限的时间内，将一个个奇思妙想以编程的方式来实现，最令人兴奋的是，整个编程的过程几乎没有任何限制或者方向。在Hackathon中，享受不断挑战自己，超越自己的快感吧！ 技术沙龙&amp;技术分享会 你是否对最新IT技术、前沿学术成果充满向往？今年开始，计算机爱好者协会将进一步拓宽技术沙龙与技术分享会的领域范围。在这里，你可以与高年级/研究生学长学姐、各高校微软学生俱乐部大佬、微软亚研院科研大牛探讨学术问题，助力同学们的工程能力与科研水平的提升！ MOSC 开源讲座 微软开源学习社群（Microsoft Open-source Study Community）脱胎于原微软学生俱乐部，是微软亚洲研究院对高校人才培养的进一步探索。在这里，你可以参与到双一流高校高年级学生的直播中来，参与学习由社群共创的课程，分享自己的技术与感受…… 其他活动 除此之外，俱乐部还会定期举办其他精彩的活动，比如破冰行动，编程挑战赛，魔盒挑战，假期充电站，参观苏州微软，前往其它高校交流学习，甚至与南航开展王者荣耀友谊赛。优秀的你也有机会获得微软亚研院内推的名额~ 组织架构 俱乐部共有三个部门，以及若干技术大佬。俱乐部各部门内采用工作组制度，每位同学可以选择加入至少一个部门（工作组）。 运营部主要负责活动的准备和执行、调动社团积极性和活跃度，也负责人员培训与考核工作，包括准备活动所需要的物资等等。同时运营部还负责社团的财务工作。 市场部负责社团对外形象的树立和宣传推广，设计并执行品牌运营方案，在社团的各项活动中进行品牌把关。同时进行公众号运营等宣传工作。 行政部主要职能为策划和组织社团内的各种活动，协调各部门促进活动的完满成功，同时也负责对实验室的日常管理工作，以及运营俱乐部Bilibili官方账号。 技术组主持社团技术分享，承担社团项目开发，为社团举办活动提供相关技术支持。既是计算机爱好者协会的核心，也是我们的灵感来源。 关于我们 听说有童鞋担心自己零基础？ 没事！无论你来自哪个年级，哪个专业，只要你 有创意 有兴趣 会学习 就能加入我们！ 在百团大战后，我们将会举办技术交流会（Hackathon）。同学们会在交流会中对我们的定位和性质有一个更深的了解，我们也能从交流会中，发现一批优秀的同学，邀请他们加入社团，与我们一起挑战自我，共同成长。 在这里，让我们一起用双手将一个个天马行空的想法变成现实！ 在这里，你可以在破冰活动中结识更多志同道合的朋友，在欢笑中增进彼此友谊；你可以在Hackathon中挑战自我，感受头脑风暴的深邃魅力；还可以与全国顶尖高校的同学们切磋学习；还可以参与到微软亚研院组织的学术活动，与科研大牛面对面交流。 欢迎加入我们的交流QQ群：497516494 这里有优质学长学姐 随时为你解答问题！ 在百团大战开始后，我们会在群中开展招新活动。 欢迎关注SUMSTC微信公众号，以及社团Bilibili“苏大微软俱乐部”，获取我们的最新消息~","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[]},{"title":"2021 Python 讲座","slug":"python2021","date":"2021-09-23T13:03:36.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/09/23/python2021/","link":"","permalink":"https://sumsc-caa.github.io/2021/09/23/python2021/","excerpt":"","text":"2021 Python 讲座。 https://mp.weixin.qq.com/s/YjsUm3AVi2pG_Uxk-vSqMg https://mp.weixin.qq.com/s/UYdl57MdWl5PRpTBA0DbHA","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[]},{"title":"博客帮助文档","slug":"help","date":"2021-09-23T13:02:44.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2021/09/23/help/","link":"","permalink":"https://sumsc-caa.github.io/2021/09/23/help/","excerpt":"","text":"SUMSC 的博客系统终于更新了（ 系统架构升级，使用了更为轻量的 Hexo.js 框架。如果你不折腾的话，甚至都不需要写前端就可以愉快地写博客啦！ 使用说明 1 加入 GitHub SUMSC 组织：SUMSC 2 clone 博客源代码(此前需配置 SSH 公钥) 1$ git clone git@github.com:SUMSC/OfficialWebsiteSource.git 3 安装依赖 1$ npm i 4 使用如下命令新建一篇博文： 1$ hexo new file-name 新建的 markdown 文件会保存在 source/_posts 目录下。需设置顶部的 formatter： 1234title: 博文标题date: 时间categories: - 技术博客 或 活动 之后可以使用 markdown 写博客了。 5 使用如下命令打包，发布： 1234$ hexo cl # 清理$ hexo g # 打包$ hexo s # 预览$ hexo d # 发布（git push） 6 将源代码的修改推送至本仓库： 1234$ git pull # push前先pull$ git add .$ git commit -m &quot;commit_message&quot;$ git push origin main","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[]},{"title":"2020 Hackathon：Python Turtle","slug":"hackathon2020","date":"2020-10-23T13:03:36.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2020/10/23/hackathon2020/","link":"","permalink":"https://sumsc-caa.github.io/2020/10/23/hackathon2020/","excerpt":"","text":"10.23 Python Turtle Lecture 主讲：黄学文 Turtle 是什么，能做什么 Turtle 库是 Python 的基础绘图库，其主要是用于程序设计入门，是标准库之一，利用 Turtle 可以制作很多复杂的绘图。 想象一个小乌龟，在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始，它根据一组函数指令的控制，在这个平面坐标系中移动，从而在它爬行的路径上绘制了图形。 举个例子：先执行 import turtle，再执行 turtle.right(45)，它将原地右转 45 度。再执行 turtle.forward(150)，它将(在屏幕上)朝所面对的 x 轴正方向前进 150 像素，随着它的移动画出一条线段。 1234import turtleturtle.right(45)turtle.forward(150) Turtle 的安装（避坑） 大家应该都装好 Python3 了吧。 安装好 Python 3.8，turtle 模块就可以使用了，即 turtle 是 Python 的内置模块。 可以尝试用 import turtle 导入，如果没有异常（ModuleNotFoundError）抛出，turtle 就已经装好了。 但是如果没有安装 turtle（导入时报错了），就需要我们手动安装。 通常的做法是：pip install turtle 但是会报错： 通过阅读错误信息我们可以知道：错误的来源是 setup.py 第40行存在语法错误（这个语法是 Python2 的语法，在 Python3 环境下会报错），需要我们手动修改并安装。 解决办法： 下载 turtle 源码：https://pypi.org/project/turtle/#files 解压，并记住解压的文件夹路径（路径中不要出现空格和中文） 打开 setup.py 修改第40行，从 except ValueError, ve: 改成 except (ValueError, ve): 打开命令提示符（cmd）运行 pip install -e &lt;turtle文件夹路径&gt; 如：pip install -e C:\\Python_turtle\\turtle-0.0.2 即可完成安装。 如果遇到错误 建议手动安装 twisted ： 下载对应 python 版本（如python3.8 对应 cp38）的 twisted 安装包：https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted 比如说我的是 32 位 python3.8，下载 “Twisted‑20.3.0‑cp38‑cp38‑win32.whl” 存放路径中不要出现空格和中文 命令提示符执行 pip install &lt;下载文件路径&gt; 比如我存放在了C盘根目录，就需要执行 pip install C:\\Twisted‑20.3.0‑cp38‑cp38‑win32.whl 之后再执行 pip install -e &lt;turtle文件夹路径&gt; 即可。 Turtle 的基础功能使用简介 使用海龟画笔，获取和修改状态 当我们开始作图时，确切的说是我们调用了画图的函数时，我们就有了一个小海龟 turtle。 position() | pos() 位置 distance() 距离 degrees() 角度，radians() 弧度 可见性：showturtle() | st() 显示海龟；hideturtle() | ht() 隐藏海龟 移动和绘制，颜色控制和填充 海龟的动作 forward() | fd() 前进；backward() | bk() | back() 后退 right() | rt() 右转；left() | lt() 左转 goto() | setpos() | setposition() 前往/定位 setheading() | seth() 设置朝向 home() 返回原点 circle() 画圆；dot() 画点 speed() 速度 绘图 pendown() | pd() | down() 画笔落下；penup() | pu() | up() 画笔抬起 reset() 重置；clear() 清空 write() 书写 颜色控制 pencolor() 画笔颜色；fillcolor() 填充颜色；color() 颜色 填充 begin_fill() 开始填充；end_fill() 结束填充 窗口控制 bgcolor() 背景颜色；bgpic() 背景图片 clear() | clearscreen() 清屏 reset() | resetscreen() 重置 screensize() 屏幕大小 turtle 库的其他使用方法参考官方文档：https://docs.python.org/zh-cn/3/library/turtle.html 例1：太阳花 12345678910import turtle turtle.color(&#x27;red&#x27;, &#x27;yellow&#x27;)turtle.begin_fill()while True: turtle.forward(200) turtle.left(170) if abs(turtle.pos()) &lt; 1: breakturtle.end_fill()turtle.done() 例2：彩虹线 123456789import turtlefrom random import randintturtle.pensize(5)turtle.colormode(255)for x in range(700): turtle.color(randint(0, 255), randint(0, 255), randint(0, 255)) turtle.circle(2 * (1 + x / 4), 5) turtle.speed(30) 例3：绘制蟒蛇 12345678910111213141516import turtleturtle.penup()turtle.pencolor(&quot;red&quot;)turtle.forward(-250)turtle.pendown()turtle.pensize(10)turtle.right(45)for i in range(4): turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80 / 2)turtle.fd(40)turtle.circle(16, 180)turtle.fd(40 * 2 / 3)turtle.done() 这个留给大家自己去执行看看效果。 补充 官方文档中提到了面向对象的概念，简单的理解就是：把我们刚才画图用的海龟和用这个海龟画画的各种函数看作一个整体，作为现实中的笔这一事物在程序中的抽象，我们把这种抽象叫做类，起名 Turtle。同样的，把画画用的窗口和控制它的函数这一类看作是现实中纸张，称作 Screen 类。 Screen 和 Turtle 可以看做是真实的纸、笔来比喻。看不懂也没关系，程序中使用过程化的方法更多。（看不懂就跳过这一部分吧~） 任务布置与 turtle 小程序演示 文件链接已失效，暂不提供下载。 子任务 [熟悉 turtle 的使用] 我们给每个队都准备了一块白板和若干水彩笔，大家可以愉快地在白板上画画；所以这个任务是将这块白板数字化，大家可以在上面用小海龟画画（不一定要和实物白板一模一样）。 主任务 在下面几个选题中任选一个，在 Hackathon 结束时各小组进行展示。 以下选题提供供参考的示例程序。 选题1 分形几何——分形树的绘制 扩展：科赫曲线（雪花曲线）的绘制 如果让你去测量中国的海岸线总长度，该如何测量呢？ 资料显示：我国海岸线长度为3.2万公里 米尺：得到的结果可能会是10万千米 精度再高：结果会更大 分形就是将一个东西按照某种方式不断分割下去，形成的一种不断迭代的自相似结构。迭代次数越多，总长度等越大，形状也就更加复杂。 分形几何的一个简单的实例即为分形树。 通过控制笔的起始位置、方向、颜色、粗细，画出颜色和粗细不同的树干构成的分形树，且自下向上树干越来越细。 所以，这个任务是：画分形树（或科赫曲线等类似图形）。 参考资料： 分形概述：下载地址，备用下载地址，百度云链接 百度百科：分形几何 示例代码：下载地址，备用下载地址，百度云链接 选题2 表白小程序——画樱花树 扩展：画出更漂亮的画 当然，你也许不会满足于画这些看起来比较简单的图画。下面是更漂亮也更具有挑战性的项目，而且也有了更丰富的用途。 比如说，画一篇樱花树送给你的npy…… 所以，这个任务很简单，就是——画出更漂亮的画（包括但不限于樱花树）。 参考资料： 示例代码：下载地址，备用下载地址，百度云链接 代码详解：下载地址，备用下载地址，百度云链接 选题3 算法的演示程序——以冒泡排序算法为例 扩展：机器学习knn算法等的演示 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从 Z 到 A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。 算法的描述给人的感觉是枯燥的，但是将其演示出来能让我们更好地理解它。 如果你想变强，来试试这个选题：算法的演示程序。这个范围很大，你可以挑你感兴趣的。 推荐可以了解一下机器学习 knn 算法，并用 turtle 来演示其过程。 我们提供一些简单的有关算法的资料，你也可以上网搜索。 参考资料： 有关排序的简介（冒泡排序、选择排序）：下载地址，备用下载地址，百度云链接 冒泡排序演示的示例代码：下载地址，备用下载地址，百度云链接 机器学习简介：下载地址，备用下载地址，百度云链接 机器学习与 knn 算法介绍（视频）：下载地址，备用下载地址，百度云链接 选题4 挑战——铺瓷砖 扩展：用 turtle 来解决实际问题/实现一个小游戏 题目：有一面墙，规格为长n宽m的长方形，现在要把规格为长a宽b的长方形瓷砖铺满该墙面，请问有多少种铺法?请输出所有的铺法，用户可以选定某种铺法，输出对应的 turtle 图形进行可视化。【题目来源：2019·PKU 非计算机类 Python大作业】 挑战：大家可以思考这道题的完整做法。（虽然这超出了本次 Hackathon 的要求） 对于选本题的小组，我们考虑给出“输出所有的铺法”的程序，由小组成员来实现可视化功能。（如果能完整实现本程序更好） 或者，用 turtle 来解决实际问题/实现一个小游戏，我们欢迎更好的想法。 参考资料： 题目与题解：下载地址，备用下载地址，百度云链接 代码模板（可以直接在原代码上添加功能）：下载地址，备用下载地址，百度云链接 完整实现代码示例：下载地址，备用下载地址，百度云链接","categories":[{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"}]},{"title":"使用 Python3 urllib 模拟 HTTP 请求","slug":"python3-urllib-http","date":"2019-05-19T07:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2019/05/19/python3-urllib-http/","link":"","permalink":"https://sumsc-caa.github.io/2019/05/19/python3-urllib-http/","excerpt":"","text":"使用 Python3 Built-in 的 urllib 可以发送 HTTP 请求，虽然不如 requests 方便，但是用来做一些 parse 工作还是相当不错的。 urllib urllib有四个模块： request，处理请求； error，处理错误； parse，对请求内容解码和编码； robotparser，检查robot.txt。 发送请求 request用于发送请求。 urlopen() 示例： 12345678import urllib.requestres = urllib.request.urlopen(&quot;https://www.python.org/&quot;)print(res.read().decode(&#x27;utf8&#x27;)) # get htmlprint(type(res)) # &lt;class &#x27;http.client.HTTPResponse&#x27;&gt;print(res.getheader(&quot;Server&quot;)) # &#x27;nginx&#x27;print(res.getheaders()) # Response Headersprint(res.status) # 200 这个方法也支持表单提交。 123456import urllib.requestimport urllib.parsedata = bytes(urllib.parse.urlencode(&#123;&quot;word&quot;: &quot;hi&quot;&#125;), encoding=&#x27;utf8&#x27;)res = urllib.request.urlopen(&quot;https://httpbin.org/post&quot;, data=data)print(res.read().decode(&#x27;utf8&#x27;)) Request Request类可以生成完整的请求实例，添加 Headers，指定 Method。 12345678910url = &quot;http://httpbin.org/post&quot;headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6)&quot;, &quot;Host&quot;: &#x27;httpbin.org&#x27;&#125;dict = &#123;&#x27;name&#x27;: &#x27;Amber&#x27;&#125;data = bytes(urllib.parse.urlencode(dict), encoding=&#x27;utf8&#x27;)req = urllib.request.Request(url=url, data=data, headers=headers, method=&#x27;POST&#x27;)res = urllib.request.urlopen(req)print(res.read().decode(&#x27;utf-8&#x27;)) 高级用法 生成一个请求，不仅仅会需要 URI、参数、方法和请求头，还需要处理 Cookie、代理等等。生成这样的高级请求就要用到Handler。urllib.request.BaseHandler提供了最基本的方法，可以集成它来自己创建Handler，有一些内置的： HTTPDefaultErrorHandler HTTPRedirectHandler HTTPCookieProcessor ProxyHandle HTTPPasswordMgr HTTPBasicAuthHandler 还有一些其他的，可以查看文档。 另外一个重要的类是OpenerDirector，简称Opener。Opener可以使用open()方法，返回response。我们需要利用Handler来构建Opener。 Cookie 下面是一个利用HTTPCookieProcessor读写 Cookie 的例子： 1234567891011121314151617181920212223def build_cookie(cookie_file, login_req=None, override=False): &quot;&quot;&quot; 将 Cookies 写入 cookie_file，或从其中读出 Cookies :param cookie_file: Cookie 文件路径 :param login_req: 建立 Cookie 的请求 :param override: 是否覆盖原先的 Cookie 文件 :return: cookie_opener &quot;&quot;&quot; import os from http.cookiejar import LWPCookieJar from urllib.request import HTTPCookieProcessor, build_opener if (not os.path.exists(cookie_file)) or override: if login_req is None: raise Exception(&quot;请给出登陆请求！&quot;) cookie = LWPCookieJar(cookie_file) cookie_opener = build_opener(HTTPCookieProcessor(cookie)) cookie_opener.open(login_req) cookie.save(ignore_expires=True, ignore_discard=True) else: # 直接读取 cookie = LWPCookieJar() cookie.load(cookie_file, ignore_discard=True, ignore_expires=True) cookie_opener = build_opener(HTTPCookieProcessor(cookie)) return cookie_opener 代理 下面是一个利用ProxyHandler实现代理访问的方法： 12345678def build_proxy(proxy): &quot;&quot;&quot; 根据 proxy 参数获取代理访问 :param proxy: dict，key 为协议，value 为代理地址 :return: proxy_opener &quot;&quot;&quot; from urllib.request import ProxyHandler, build_opener return build_opener(ProxyHandler(proxy)) 处理异常 urllib提供了URLError和HTTPError，所有request返回的异常都在URLError中。 12345678910from urllib import request, errortry: response = request.urlopen(&#x27;https://xxx.com/&#x27;)except error.HTTPError as e: print(e.reason, e.code, e.headers)except error.URLError as e: print(e.reason)else: print(&#x27;Request Successfully&#x27;) 解析链接 URL 中有一些很重要的信息，包括协议、域名、资源地址、参数、查询以及分段。使用parse模块可以对 URL 进行解析。 urlparse可以将 URL 分为协议、域名、资源地址、参数、查询以及分段六块，urlunparse可以将一个六元素列表组织成一个 URL。 urlsplit无视参数项，分解为协议、域名、资源地址、查询以及分段五块，urlunsplit将一个五元素列表组织成一个 URL。 urlencode将一个字典编码为一个 GET 查询字符串。parse_qs将一个 GET 查询字符串解码为字典。 quote将字符串进行 URL 序列化，unquote反之。 分析Robots协议 robotparse模块解析robots.txt，判断爬虫是否有权限对某个页面进行爬取。 123456789101112def can_fetch(ua, url, robots_url): &quot;&quot;&quot; 查看 UA 是否可以爬取该 URL :param ua: 爬虫 User-Agent :param url: 需要爬取的页面地址 :param robots_url: 主站的 robots.txt :return: Bool &quot;&quot;&quot; from urllib import parse, robotparser robots = robotparser.RobotFileParser(robots_url) robots.read() return robots.can_fetch(ua, url) requests 基本用法 requests可以直接发起对应的 HTTP Method 请求： 1234567import requestsurl = &quot;https://www.baidu.com/&quot;requests.get(url)requests.post(url)requests.put(url)requests.delete(url)requests.options(url) GET 对于 GET 参数，可以直接将字典附加到requests.get()的params参数。对于 API 返回的 JSON，可以直接调用response.json()。可以直接附加 Headers。response的text属性是 Unicode 解码，content属性是二进制。封装的response中还可以获取 Cookies，History，URL，Status_Code 12345import requestsheaders = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;&#125;res = requests.get(&#x27;https://www.zhihu.com/&#x27;, headers=headers) POST 12345import requestsdata = &#123;&#x27;name&#x27;: &#x27;germey&#x27;, &#x27;age&#x27;: &#x27;22&#x27;&#125;r = requests.post(&quot;http://httpbin.org/post&quot;, data=data)print(r.json()) 高级用法 文件上传 12345import requestsfiles = &#123;&#x27;file&#x27;: open(&#x27;favicon.ico&#x27;, &#x27;rb&#x27;)&#125;r = requests.post(&quot;http://httpbin.org/post&quot;, files=files)print(r.text) Cookie 123456import requestsres = requests.get(&quot;https://www.baidu.com/&quot;)print(res.cookies)for k, v in r.cookies.items(): print(k, &#x27;=&#x27;, v) 在requests中使用 Cookie，可以像往常一样直接放在 Headers 中，不过稍微有些难看，下面是完整的使用 Cookie 的方式： 12345678import requestsfrom http.cookiejar import LWPCookieJarjar = requests.cookies.RequestsCookieJar()cookie = LWPCookieJar()cookie.load(&quot;cookie.txt&quot;)for i in cookie: jar.set(i.name, i.value) Session 上面的维持 Cookie 发起访问的方式相当麻烦，所以requests提供了更好的方法：Session。对于浏览器来说，会话（Session）是无比平常的东西。如果留心的话，在解析网络时经常能发现 Request Headers 总会有keep-alive。事实上，会话是依赖于 Cookie 的，由于 HTTP 是无状态协议，所以使用 Cookie 来标记长连接，也就是会话。 1234import requestss = requests.Session()s.get(&quot;https://www.baidu.com&quot;) 会话可以看作是urllib的一个 Opener，在一次会话中，会保留 Cookie、代理，因而非常方便。 SSL 证书 requests提供了 SSL 证书验证的功能，如果遇到无法验证的 SSL 证书，可以添加verify=False跳过验证。 代理 12345678910111213import requestsproxies = &#123; &#x27;http&#x27;: &#x27;http://127.0.0.1:1087&#x27;, &#x27;https&#x27;: &#x27;https://127.0.0.1:1087&#x27;&#125;proxies_socks = &#123; &#x27;http&#x27;: &#x27;socks5://127.0.0.1:1086&#x27;, &#x27;https&#x27;: &#x27;socks5://127.0.0.1:1086&#x27;&#125;requests.get(&quot;https://www.google.com&quot;, proxies=proxies) Prepared Request 有可能我们需要一个结构化的请求来多次复用，这时候我们可以使用Request类来生成一个底层的请求对象。一个请求对象可以自己与处理，但是当使用Session时，就需要使用Session去预处理。 123456789101112131415from requests import Request, Sessionurl = &#x27;http://httpbin.reg/post&#x27;data = &#123; &#x27;name&#x27;: &#x27;germey&#x27;&#125;headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;&#125;s = Session()req = Request(&#x27;POST&#x27;, url, data=data, headers=headers)# pre_req = req.prepare()pre_req = s.prepare_request(req)res = s.send(pre_req)print(res.text) 正则 完整讲述正则表达式过于复杂，不如自己理解。常用的正则表达式工具列在下方： 正则表达式测试——开源中国 正则表达式手册——开源中国 正则表达式入门教程 这里我们来说一些 Python3 re 模块的一些使用。 常用函数 修饰符 re.S：使.匹配换行符在内的所有字符； re.I：大小写不敏感； re.M：多行匹配，影响^和$； re.L：本地化识别匹配； re.U：根据 Unicode 解析字符； re.X：可以更灵活地写正则表达式。 一般常用re.S和re.I。 match() 从字符串起始处开始匹配，返回一个match对象，可以使用.group()获取匹配到的内容。 1234import reurl = re.match(&quot;.*?&lt;title&gt;(.*?)&lt;/title&gt;&quot;, res.text)print(url.group(1)) # Google search() 和match()很像，区别是不是固定从开头开始查找。 1234import reres = re.search(&#x27;&lt;title&gt;(.*?)&lt;/title&gt;&#x27;, res.text)print(url.group(1)) findall() 获取所有正则能匹配到的内容。 1234import reres = re.findall(&#x27;&lt;a.*?href=&quot;(.*?)&quot;&#x27;, res.text)print(res) sub() 用正则表达式统一替换。 12345import recontent = &#x27;123abc456&#x27;content = re.sub(&#x27;\\d+&#x27;, &#x27;&#x27;, content)print(content) # abc compile() 获取一个组织完成的正则表达式对象，便于复用。 123import repattern = re.compile(&#x27;ppp.*?ppp&#x27;, re.S)","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"}],"author":"Amber"},{"title":"用frp实现内网穿透","slug":"frp-2018","date":"2018-07-13T16:00:00.000Z","updated":"2023-02-26T04:10:38.892Z","comments":true,"path":"2018/07/13/frp-2018/","link":"","permalink":"https://sumsc-caa.github.io/2018/07/13/frp-2018/","excerpt":"","text":"前言 最近把家里的旧电脑换了 redhat 做服务器，因为没有家里公网 ip，就用 frp 实现了内网穿透 准备工作 一台有公网 ip 的电脑 一台能上网的机子 安装 这里以 0.20.0 版本为例 https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz 其他的 release 参见https://github.com/fatedier/frp/releases 1$ wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_a md64.tar.gz 下载后解压 1$ tar -xvf frp_0.20.0_linux_amd64.tar.gz 服务端 1$ cd frp_0.20.0_linux_amd64 编辑配置文件 1vim frps.ini 修改地址和端口 1234567[common]vhost_http_port = 8080bind_port = 7000[web]type = httpcustom_domains = your.domains 确保你的服务器开启的你填的端口并且没有被占用 客户端 同样下载解压之后编辑 frpc.ini 1$ vim frpc.ini 配置文件内容如下 123456789[common]server_addr = your.server.addressserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 之后运行就 ok 了 可选 将 frps 写入系统服务(frpc 只要将下面所有的 frps 换成 frpc 即可) 先移动文件 123$ sudo cp frps /usr/bin$ sudo mkdir /etc/frp$ sudo cp frps.ini /etc/frp 之后是写服务文件 1$ sudo vim /etc/systemd/system/frps.service 文件如下 123456789101112131415[Unit]Description=frps daemonAfter=network.target syslog.targetWants=network.target[Service]Type=simple#启动服务的命令（此处xxx换做你的实际安装目录）ExecStart=/usr/bin/frps -c /etc/frps/frps.iniRestart= alwaysRestartSec=1minExecStop=/usr/bin/killall frps[Install]WantedBy=multi-user.target 这样我们就可以用 systemed 进行控制并且开机启动 12$ sudo systemctl enable frps$ sudo systemctl start frps 这样我们就可以偷(yu)税(kuai)地进行内网穿透了！","categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"}],"tags":[]}],"categories":[{"name":"技术博客","slug":"技术博客","permalink":"https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"},{"name":"活动","slug":"活动","permalink":"https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sumsc-caa.github.io/tags/Python/"},{"name":"Hackathon","slug":"Hackathon","permalink":"https://sumsc-caa.github.io/tags/Hackathon/"},{"name":"Pandora","slug":"Pandora","permalink":"https://sumsc-caa.github.io/tags/Pandora/"},{"name":"前端","slug":"前端","permalink":"https://sumsc-caa.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}