<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUMSC</title>
  
  <subtitle>计算机爱好者协会（微软学生俱乐部）</subtitle>
  <link href="https://sumsc-caa.github.io/atom.xml" rel="self"/>
  
  <link href="https://sumsc-caa.github.io/"/>
  <updated>2023-02-26T05:39:47.346Z</updated>
  <id>https://sumsc-caa.github.io/</id>
  
  <author>
    <name>SUMSC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客帮助文档（更新）</title>
    <link href="https://sumsc-caa.github.io/2023/02/26/bloghelp-2023/"/>
    <id>https://sumsc-caa.github.io/2023/02/26/bloghelp-2023/</id>
    <published>2023-02-26T11:30:05.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>本站的博客系统基于 <a href="https://github.com/hexojs/hexo">Hexo.js框架</a>，因为在对应的Github仓库中已经设置好了Github Actions，所以不在本地安装Hexo也可以发布博客。以下为具体步骤：</p><h2 id="使用说明"><a class="markdownIt-Anchor" href="#使用说明"></a> 使用说明</h2><ol start="0"><li>注册Github帐号；</li><li>加入Github SUMSC组织 <a href="https://github.com/sumsc-caa">sumsc-caa</a>（请联系技术组组长）；</li><li>拉取仓库（需要事先在Github<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh">设置好ssh公钥</a>）： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:sumsc-caa/WebSite.git</span><br></pre></td></tr></table></figure></li><li>创建文章文件：在 <code>source/_posts/</code>下创建markdown格式的博客文件（<code>.md</code>），并在文件顶部插入 frontmatter。frontmatter为<a href="https://yaml.org/">yaml格式</a>，可以参照<a href="https://hexo.io/zh-cn/docs/front-matter">Hexo的官方文档</a>，或是参照已有文章的frontmatter编写，例如本文的 frontmatter：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">date: 2023-02-26 11:30:05</span><br><span class="line">title: 博客帮助文档（更新）</span><br><span class="line">categories:</span><br><span class="line">  - 技术博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li>编写文章正文，<ul><li>如果文章内需要包含图片等静态文件，请参见 <a href="#%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6">关于静态文件</a>；</li><li>如果需要预览构建结果，请参见 <a href="#%E5%85%B3%E4%BA%8E%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88">关于实时预览</a>；</li></ul></li><li>将更改推送至源码仓库：<br /><strong>请勿频繁推送</strong>，Github Actions具有一定的免费额度（整个组织有2000分钟每月的免费构建时间），超过这个额度则会产生费用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull                  <span class="comment"># push前先pull，如果出现冲突需要自己merge</span></span><br><span class="line">$ git add sources/_posts/*  <span class="comment"># 只更新posts下的文件</span></span><br><span class="line">$ git commit -m <span class="string">&quot;&lt;message&gt;&quot;</span> <span class="comment"># commit message要写清楚自己做了什么哦</span></span><br><span class="line">$ git push origin main      <span class="comment"># 推送至源码仓库</span></span><br></pre></td></tr></table></figure>成功推送后，Github Actions会自动构建博客并发布至 <a href="https://sumsc-caa.github.io">https://sumsc-caa.github.io</a>，这个过程需要一定时间（大约一分钟），请耐心等待，在此期间不要推送新的更改。</li></ol><h2 id="关于静态文件"><a class="markdownIt-Anchor" href="#关于静态文件"></a> 关于静态文件</h2><p>图像文件有两种处理方法：</p><ol><li>放置在 <code>source/images</code> 内，并在文章中使用<code>![](/images/&lt;path&gt;/&lt;filename&gt;)</code>引用图片，例如<a href="https://sumsc-caa.github.io/2022/11/04/hackathon2022-2/">这篇文章</a>。若使用这种方法请尽量降低图像的体积。</li><li>上传至国内的免费图床，例如<a href="https://sumsc-caa.github.io/2020/10/23/hackathon2020/">这篇文章</a>。</li></ol><p>非图像文件请放在 <code>source/assets</code> 内，发布后对应的URL为<code>/assets/&lt;filename&gt;</code>，例如<a href="https://sumsc-caa.github.io/2021/11/05/hackathon2021-q2-tetris/">这篇文章</a>。</p><p>此外，如果是代码文件，也可以考虑使用 <a href="https://gist.github.com/">Github Gist</a>，例如<a href="https://sumsc-caa.github.io/2022/11/04/hackathon2022-gameoflife/">这篇文章</a>。</p><h2 id="关于实时预览"><a class="markdownIt-Anchor" href="#关于实时预览"></a> 关于实时预览</h2><p>使用实时本地预览需要在本地安装好Hexo及其运行环境，这首先需要在本地配置好<a href="https://nodejs.org/">node.js</a>，这一步请参考网络上的教程。装好node.js后，在本仓库的目录下执行（或者用你常用的包管理工具）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br></pre></td></tr></table></figure><p>安装本项目的依赖（包括hexo）。然后使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm server</span><br><span class="line"># 或者</span><br><span class="line">$ hexo server</span><br><span class="line"># 或者</span><br><span class="line">$ npx hexo server</span><br></pre></td></tr></table></figure><p>启动预览服务器，默认的预览地址为 <a href="http://localhost:4000">http://localhost:4000</a> 。作出更改后保存，并在浏览器内刷新对应的页面即可看到更改后的结果。预览的效果与实际部署的效果是完全一致的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本站的博客系统基于 &lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;Hexo.js框架&lt;/a&gt;，因为在对应的Github仓库中已经设置好了Github Actions，所以不在本地安装Hexo也可以发布博客。以下为具体步骤：&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="技术博客" scheme="https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>技术赋能#2：Python可迭代对象的相关函数（1）</title>
    <link href="https://sumsc-caa.github.io/2022/11/18/techpost-2022-2/"/>
    <id>https://sumsc-caa.github.io/2022/11/18/techpost-2022-2/</id>
    <published>2022-11-18T08:23:48.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>Python内置了许多有用的工具函数与类，用于处理可迭代对象与迭代器产生的数据流。本文将对这些工具函数或类作简要介绍，包括<code>map</code>，<code>filter</code>，<code>enumerate</code>，<code>zip</code>，<code>sum</code>，<code>all</code>/<code>any</code>，<code>min</code>/<code>max</code>，<code>sorted</code>。</p><p><em>本文是本系列的上一篇文章“技术赋能#1：Python的可迭代对象、迭代器与生成器”的延续，建议先了解这一篇再继续阅读。</em></p><h3 id="map函数"><a class="markdownIt-Anchor" href="#map函数"></a> <code>map</code>函数</h3><p><code>map</code>是Python中常用的一个函数（类），它接受一个函数与一个或多个可迭代对象作为输入，并输出一个迭代器（<code>map</code>实例）。</p><p>例如，当我们需要得到一个数列的平方时，我们可以使用<code>map</code>函数这样编写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = <span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><p>这样写有点繁琐了，为了简化下文的代码，本文将使用Python提供的“lambda表达式（匿名函数）”与“序列解包”两个语法。上面的代码等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><p>上面提到的两种语法如果你没学到也没关系，你只需要知道<code>lambda x: x**2</code>和前面的<code>square</code>函数的定义相同，<code>print</code>和<code>*</code>+可迭代对象可以代替上面的那个循环。</p><p>如果设输入<code>map</code>的第一个参数为函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，第二个参数为数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a_1, a_2, \ldots, a_n\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span>，则这个<code>map</code>调用的输出为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle f(a_1), f(a_2), \ldots, f(a_n)\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">⟩</span></span></span></span>。在上面的例子中，数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>为 0-9 的自然数列，函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x)=x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，因此输出是 0-9 内各个自然数的平方。</p><p>当然，在Python中<code>map</code>接受的序列（可迭代对象）当然不止数列，字符串与字符串序列也是可以的，下面这个例子将列表与字符串中的小写字母全部转化成大写字母（字符串也是可迭代对象哦）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="keyword">lambda</span> s:s.upper(), [<span class="string">&quot;Alpha&quot;</span>, <span class="string">&quot;Beta&quot;</span>, <span class="string">&quot;Gamma&quot;</span>]))</span><br><span class="line">ALPHA BETA GAMMA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="keyword">lambda</span> s:s.upper(), <span class="string">&quot;Alpha&quot;</span>))</span><br><span class="line">A L P H A</span><br></pre></td></tr></table></figure><p>此外，输入和输出不一定要保持相同的数据类型，这一段代码可以将输入的字符串形式的数字转化为整型变量的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="string">&quot;1,1,2,3,5,8,13,21&quot;</span>.split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>上文提到，<code>map</code>也可以接受多个可迭代对象作为输入，此时函数<code>f</code>的参数数量需要与可迭代对象的数量相同，当多个输入序列长度不一样时，输出序列的长度与较短的序列的相同。这个例子使用<code>map</code>函数将两个序列对应位置的数相乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="keyword">lambda</span> x,y: x*y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]))</span><br><span class="line"><span class="number">6</span> <span class="number">14</span> <span class="number">24</span> <span class="number">36</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><h3 id="filter函数"><a class="markdownIt-Anchor" href="#filter函数"></a> <code>filter</code>函数</h3><p><code>filter</code>的参数形式与<code>map</code>相似，其接受一个函数<code>f</code>与<strong>一个</strong>可迭代对象作为输入，输出一个迭代器（<code>filter</code>实例）。其中输入函数<code>f</code>的返回值必须是布尔类型（<code>True/False</code>）或是能隐式转换为布尔类型，函数值为<code>True</code>的值将留在输出序列中，为<code>False</code>的值将被筛去。下面两个例子分别筛选出了输入序列中的偶数与素数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的暴力算法，考试时不要使用哦）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">filter</span>(<span class="keyword">lambda</span> n:n%<span class="number">2</span>==<span class="number">0</span>, <span class="built_in">range</span>(<span class="number">20</span>)))</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">filter</span>(<span class="keyword">lambda</span> n: n==<span class="number">2</span> <span class="keyword">or</span> n&gt;<span class="number">2</span> <span class="keyword">and</span> <span class="built_in">all</span>(n%i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>)), <span class="built_in">range</span>(<span class="number">100</span>)))</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">19</span> <span class="number">23</span> <span class="number">29</span> <span class="number">31</span> <span class="number">37</span> <span class="number">41</span> <span class="number">43</span> <span class="number">47</span> <span class="number">53</span> <span class="number">59</span> <span class="number">61</span> <span class="number">67</span> <span class="number">71</span> <span class="number">73</span> <span class="number">79</span> <span class="number">83</span> <span class="number">89</span> <span class="number">97</span></span><br></pre></td></tr></table></figure><h3 id="enumerate函数"><a class="markdownIt-Anchor" href="#enumerate函数"></a> <code>enumerate</code>函数</h3><p><code>enumerate</code>函数也是Python中很常用的一个函数，它接受一个可迭代对象和一个可选参数<code>start</code>作为输入，返回值是元组的可迭代对象，每个元组的第二项为原序列的内容，第一项为这一项在序列中的编号。在Python中它常常伴随<code>for</code>循环出现，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;grape&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(lst):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> apple</span><br><span class="line"><span class="number">1</span> pear</span><br><span class="line"><span class="number">2</span> peach</span><br><span class="line"><span class="number">3</span> banana</span><br><span class="line"><span class="number">4</span> grape</span><br></pre></td></tr></table></figure><p>可选参数<code>start</code>制定了初始的计数值，默认为0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(lst, start=<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">5</span> apple</span><br><span class="line"><span class="number">6</span> pear</span><br><span class="line"><span class="number">7</span> peach</span><br><span class="line"><span class="number">8</span> banana</span><br><span class="line"><span class="number">9</span> grape</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a class="markdownIt-Anchor" href="#zip函数"></a> <code>zip</code>函数</h3><p><code>zip</code>函数用于对多个可迭代对象进行打包，对于输入序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a_1,a_2,\ldots,a_n\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>+</mo><mi>t</mi></mrow></msub><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle b_1,b_2,\ldots,b_n,\ldots,b_{n+t}\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span>，<code>zip</code>函数将对应位置的值打包成元组返回，并丢弃多余的值，即返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mo>…</mo><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle (a_1,b_1),~(a_2,b_2),~\ldots,~(a_n,b_n)\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">⟩</span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>), <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">13</span>,<span class="number">2</span>)))</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>) (<span class="number">2</span>, <span class="number">3</span>) (<span class="number">4</span>, <span class="number">5</span>) (<span class="number">6</span>, <span class="number">7</span>) (<span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><h3 id="sum函数"><a class="markdownIt-Anchor" href="#sum函数"></a> <code>sum</code>函数</h3><p>顾名思义，<code>sum</code>函数对输入的可迭代对象求和，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>))</span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="allany函数"><a class="markdownIt-Anchor" href="#allany函数"></a> <code>all</code>/<code>any</code>函数</h3><p><code>all</code>/<code>any</code>函数都接受一个可迭代对象作为输入，要求这个可迭代对象内的值可以被隐式转化为布尔值，返回值为单个布尔值。<code>all</code>函数在逻辑上与多项的<code>and</code>（与逻辑）相同，当且仅当可迭代对象内的所有值都为<code>True</code>或相当于<code>True</code>时返回<code>True</code>，否则返回<code>False</code>。<code>any</code>函数则在逻辑上与<code>or</code>（或逻辑）相同，当可迭代对象内存在<code>True</code>时就返回<code>True</code>，否则（全为<code>False</code>时）返回<code>False</code>。</p><p>与Python的逻辑表达式（布尔表达式）相同，<code>all</code>与<code>any</code>函数也都是短路求值的，也就是说它们会在发现条件不满足时立刻返回（对于<code>all</code>来说就是第一次遇到<code>False</code>的时候），而不是过完整个序列。下面的这段代码演示了这一特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">iter</span>([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>(r) <span class="comment"># 消耗 5,4,3,2,1,0 遇到0时直接返回False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(*r) <span class="comment"># 获取剩余值</span></span><br><span class="line">-<span class="number">1</span> -<span class="number">2</span> -<span class="number">3</span></span><br></pre></td></tr></table></figure><p>此外，当输入序列为空时，<code>all</code>将返回<code>True</code>，<code>any</code>则返回<code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([])</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="minmax函数"><a class="markdownIt-Anchor" href="#minmax函数"></a> <code>min</code>/<code>max</code>函数</h3><p>这两个函数都用于求序列中的极值，<code>min</code>返回最小值而<code>max</code>返回最大值。除了可迭代对象之外，它们还会接受可选参数<code>key</code>，<code>key</code>参数是一个函数，用法类似于下文的<code>sorted</code>的<code>key</code>参数，这里仅演示用法，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, <span class="built_in">range</span>(-<span class="number">15</span>,<span class="number">11</span>)))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, <span class="built_in">range</span>(-<span class="number">15</span>,<span class="number">11</span>)))</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="built_in">range</span>(-<span class="number">15</span>,<span class="number">11</span>), key=<span class="built_in">abs</span>)</span><br><span class="line">-<span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="sorted函数"><a class="markdownIt-Anchor" href="#sorted函数"></a> <code>sorted</code>函数</h3><p><code>sorted</code>函数对输入序列非原地排序，其返回值一定是一个排好序的<strong>列表</strong>，除了可迭代对象之外，它还接受<code>reverse</code>与<code>key</code>两个参数。<code>reverse</code>参数指定是否逆序排序，这个很好理解；而<code>key</code>参数接受的是一个函数，这个函数接受输入序列中的值作为输入，返回一个有序对象（例如数值、字符串等），<code>sorted</code>函数将以返回的有序对象作为排序的标准。</p><p>在下面的示例中，第一个<code>sorted</code>调用对<code>lst</code>顺序排序，第二个对其逆序排序，第三个以每个值的绝对值作为标准进行排序（绝对值小的排在前面），第四个以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>2.2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x)=(x-2.2)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 为标准排序。需要分组排序时，可以让<code>key</code>参数接受的函数返回一个元组，例如第五个<code>sorted</code>调用，先按照每个数除以3的余数分组，然后对每一组按值的大小逆序排序。</p><p>Python采用的Timsort算法是稳定排序算法，也就是说标准值相同的对象会按照它们在原序列中的顺序排序（相对位置保持不变），例如第三个示例中<code>-3</code>与<code>3</code>的绝对值相同，但是原序列中<code>-3</code>在前面，所以输出的列表中<code>-3</code>也在<code>3</code>的前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,-<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(lst)                               <span class="comment">#1</span></span><br><span class="line">[-<span class="number">4</span>, -<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(lst, reverse=<span class="literal">True</span>)                 <span class="comment">#2</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(lst, key=<span class="built_in">abs</span>)                      <span class="comment">#3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(lst, key=<span class="keyword">lambda</span> x:(x-<span class="number">2.2</span>)**<span class="number">2</span>)      <span class="comment">#4</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="number">15</span>), key=<span class="keyword">lambda</span> x:(x%<span class="number">3</span>, -x)) <span class="comment">#5</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>本文介绍了Python内置的一些与可迭代对象有关的函数以及它们的使用方法，在本系列的下一篇文章内我们将介绍Python标准库中的<code>itertools</code>库，它提供了更多与可迭代对象有关的功能，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python内置了许多有用的工具函数与类，用于处理可迭代对象与迭代器产生的数据流。本文将对这些工具函数或类作简要介绍，包括&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;enumerate&lt;/code&gt;，&lt;code&gt;zip&lt;/code&gt;</summary>
      
    
    
    
    <category term="技术博客" scheme="https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2022 Hackathon: 字符画与康威生命游戏</title>
    <link href="https://sumsc-caa.github.io/2022/11/04/hackathon2022-2/"/>
    <id>https://sumsc-caa.github.io/2022/11/04/hackathon2022-2/</id>
    <published>2022-11-04T18:30:03.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="苏州大学计算机爱好者协会-hackathon-2022-赛题"><a class="markdownIt-Anchor" href="#苏州大学计算机爱好者协会-hackathon-2022-赛题"></a> 苏州大学计算机爱好者协会 Hackathon 2022 赛题</h1><p>以下两题请<strong>任选一题完成</strong>：</p><h2 id="q1-字符画"><a class="markdownIt-Anchor" href="#q1-字符画"></a> Q1: 字符画</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>字符画/ASCII艺术，是指在计算机中使用字符组成图片的一种艺术形式。其大致可以分为以下几种：</p><ol><li><p>西方式表情符号：受限于ASCII字符集，其组成的图像与表达的意思都较为简单，通常需要旋转90°阅读。</p></li><li><p>东方式表情符号/颜文字：得益于东方语言丰富的字符与标点符号，其在形式和含义上都较前者更加复杂。</p><blockquote><p>(⁄ ⁄•⁄ω⁄•⁄ ⁄)  (≧∇≦)/  ∩(·ω·)∩  (Ｔ▽Ｔ) (<sup>._.</sup>)~<br />(=<sup>・・</sup>=)  (－‸ლ)  （ ﾟ Дﾟ)  (づ￣ ³￣)づ<br />(ノಠ益ಠ)ノ彡┻━┻    ┬─┬ノ( º _ ºノ)</p></blockquote></li></ol><p>以上二者都是单行的字符画，常在社交平台上的日常对话中被使用（不过近几年国内外emoji和表情包等图片式表情符号的发展使它们日渐式微）。</p><ol start="3"><li>打字机风格/打字机艺术（Typewriter Art）：这是最早的字符画之一，下图中展示了1875年1月6日美国一份报纸上刊登的广告（来源：<a href="https://en.wikipedia.org/wiki/ASCII_art">wikipedia - ASCII art</a>），它们都利用打字机艺术使广告引人注目。</li></ol><div style="text-align:center"><img src="/images/hackathon2022f/Brooklyn-Daily-Eagle-1875-01-06.png" style="width:50%; min-width:300px" /></div><ol start="4"><li>灰度字符画：即按照相同大小的不同ASCII字符所占面积组成灰度级，并用这些灰度级组合成一张图片。下图为这种形式的土星（来源：<a href="https://scipython.com/blog/ascii-art/">ASCII art</a>）。在支持对单个字符指定颜色的软件内，这种方式也可以被用来制作彩色字符画。</li></ol><div style="text-align:center"><img src="/images/hackathon2022f/saturn-ascii-i.png" style="width:50%; min-width:300px" /></div><ol start="5"><li>矢量字符画：这些字符画通常会在图中加入一些线形字符来对线条作视觉引导，并使用灰度字符画的方式对色块进行填充，下图为这种形式的初音未来（来源：<a href="http://anime.en.utf8art.com/arc/hatsune_miku_43.html">Ascii Art Archives for Recycle</a>）。</li></ol><div style="text-align:center"><img src="/images/hackathon2022f/hatsune_miku_43.png" style="width:50%; min-width:300px" /></div><p>此外，这种形式也被用于制作命令行界面中展示的标题文字，且有各种风格。例如（来源：<a href="https://patorjk.com/software/taag">Text to ASCII Art Generator</a>）：</p><div style="text-align:center"><img src="/images/hackathon2022f/helloworld.png" style="width:50%; min-width:300px" /></div><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><ol><li>绘制一幅字符画，或者选择一幅你们喜欢的图片并将其转化为字符画。</li><li>编写程序，使其能自动将文字或图片转化为字符画，并尽可能优化结果的观感。你可以选择完善<a href="/2022/11/04/hackathon2022-asciiart">我们提供的示例程序</a>。</li><li>【可选】改进程序，将生成的字符画渲染为 PNG/JPEG（位图）、html（网页）、pdf（文档）或svg（矢量图）等格式，使其在不同环境的呈现效果一致。</li><li>【可选】改进程序，使其能逐帧处理视频，并将结果渲染到视频内。</li></ol><p>关于本题的帮助请参见：<a href="/2022/11/04/hackathon2022-asciiart">2022 Hackathon: 字符画 示例程序与帮助</a></p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>下面是可能有用的资料：</p><ol><li><a href="https://emojipedia.org/zh/">Emojipedia</a>（测试图片可以从这里获取）</li><li><a href="https://zh.wikipedia.org/zh-cn/%E6%96%B9%E5%A1%8A%E5%85%83%E7%B4%A0">方块元素 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/zh-cn/ASCII%E8%89%BA%E6%9C%AF">ASCII艺术 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93">等宽字体 - 维基百科</a></li><li><a href="https://pillow.readthedocs.io/en/stable/index.html">Pillow 库官方文档</a></li><li><a href="https://github.com/tartley/colorama">colorama 库 | Github</a></li><li><a href="https://github.com/mozman/svgwrite">svgwrite 库 | Github</a></li><li><a href="https://docs.python.org/zh-cn/3/library/argparse.html">argparse - Python 3.11 官方文档</a></li><li><a href="https://patorjk.com/software/taag/">Text to ASCII Art Generator</a></li><li><a href="http://www.jave.de/">Jave：使用Java编写的字符画编辑器</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML">HTML 简介 - 学习 Web 开发 | MDN</a></li></ol><h2 id="q2-康威生命游戏"><a class="markdownIt-Anchor" href="#q2-康威生命游戏"></a> Q2: 康威生命游戏</h2><h3 id="背景-2"><a class="markdownIt-Anchor" href="#背景-2"></a> 背景</h3><p>康威生命游戏（Conway’s Game of Life），又称康威生命棋，是英国数学家 <strong>John Horton Conway</strong> 在1970年发明的<a href="https://zh.wikipedia.org/zh-cn/%E7%B4%B0%E8%83%9E%E8%87%AA%E5%8B%95%E6%A9%9F">元胞自动机</a>。康威生命游戏在充分大的棋盘（模拟世界）上运行，棋盘的每个格子被称为一个细胞，对于棋盘内的每个细胞，只有五条规则：</p><ul><li>每个细胞有存活与死亡两种状态，每个细胞只与以自身为中心的周围<strong>八格</strong>细胞产生互动；</li><li>当前细胞为存活状态时，当周围的存活细胞低于2个时（不包含2个），该细胞变成死亡状态（模拟生命数量稀少）；</li><li>当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样；</li><li>当前细胞为存活状态时，当周围有超过3个存活细胞时，该细胞变成死亡状态（模拟生命数量过多）；</li><li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态（模拟繁殖）。</li></ul><p>整个游戏从<code>t=0</code>开始模拟，每一步模拟会对棋盘上所有细胞运用上述五条规则，得到下一步的棋盘。在这个游戏中，玩家是这个模拟世界里的神，可以旁观模拟世界内细胞的发展、随意向棋盘中添加、删除细胞，甚至是通过编程改变模拟世界的规则。</p><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><p>我们编写了一个康威生命游戏的模拟程序，你可以在比赛中使用它，也可以随意更改代码实现你期望的效果。关于代码与使用说明请见：<a href="/2022/11/04/hackathon2022-gameoflife/">2022 Hackathon: 康威生命游戏 示例程序与使用说明</a></p><p>除了我们编写的模拟程序之外，你也可以使用其它模拟程序，例如：</p><ul><li><a href="https://playgameoflife.com/">https://playgameoflife.com/</a></li><li><a href="https://conwaylife.com/">https://conwaylife.com/</a></li><li><a href="https://wavjaby.github.io/GameOfLife/">https://wavjaby.github.io/GameOfLife/</a></li><li><a href="https://github.com/thearn/game-of-life/">https://github.com/thearn/game-of-life/</a></li></ul><p>以下是你在本题可以尝试探索的几个方向：</p><ol><li>游玩康威生命游戏，并尝试在其中创建能稳定存在并增殖的生命（可以使用已发现的模式，见 <a href="https://conwaylife.com/wiki/">https://conwaylife.com/wiki/</a> ）。</li><li>尝试构建高生存力的生命体，即最大化<u>一定时间内增殖的细胞数</u>与<u>初始细胞数</u>之比。</li><li>编写程序，修改或添加生命游戏的规则，例如：<ul><li>改变基础规则的阈值；</li><li>扩大单个细胞的互动范围；</li><li>每过一定时间随机消灭世界内一半的活细胞；</li></ul></li><li>改进程序或为程序添加功能，例如：<ul><li>利用<a href="https://zh.wikipedia.org/zh-cn/%E6%96%B9%E5%A1%8A%E5%85%83%E7%B4%A0">方块元素</a>中的半高方块代替两个全高方块（也就是每一行字符对应模拟世界里的两行细胞），让程序可以在相同大小的命令行界面中展示四倍的细胞；</li><li>活细胞死亡后在地图上留下标记；</li><li>跟踪种群（初始状态聚集在一起的一群细胞）的发展，并使用颜色（<a href="https://github.com/tartley/colorama">colorama 库</a>）标记不同种群（通过规则5诞生的细胞的颜色与周围细胞中占多数的颜色相同），这样可以展示不同种群争夺生存资源（地盘）的过程。</li></ul></li></ol><h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3><ol><li><a href="https://conwaylife.com/wiki/">LifeWiki</a></li><li>Numpy 官方文档：<a href="https://numpy.org/doc/stable/">英文</a> <a href="https://www.numpy.org.cn/reference/">中文</a></li><li><a href="https://docs.python.org/zh-cn/3/library/argparse.html">argparse - Python 3.11 官方文档</a></li><li><a href="https://github.com/tartley/colorama">colorama 库 | Github</a></li><li><a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of Life - Wikipedia</a></li><li>【科普】<a href="https://zhuanlan.zhihu.com/p/45026142">康威生命游戏——孤独会致命，拥挤也一样 - 知乎</a></li></ol><h2 id="比赛规则"><a class="markdownIt-Anchor" href="#比赛规则"></a> 比赛规则</h2><p>本次比赛你可以查阅任意资料，但是请尽可能避免直接照搬网上的代码的情况。</p><p>请在星期日（7月6日）15:00之前完成你们的作品，期间你<strong>可以</strong>（非强制）在比赛场地（博远楼104-107）讨论交流与编写代码，会有工作人员现场负责技术指导。如果遇到了技术问题，你可以在比赛场地寻找技术指导，或是在比赛群内询问。7月6日15:00之后是作品展示环节，届时各组将上台展示作品、运行代码，并由评委对作品打分，打分的结果将作为最终成绩。</p><p>比赛期间请密切关注比赛群内的消息，关于比赛的任何消息我们都会在群内通知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;苏州大学计算机爱好者协会-hackathon-2022-赛题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#苏州大学计算机爱好者协会-hackathon-2022-赛题&quot;&gt;&lt;/a&gt; 苏州大学计算机爱好者协会 Hackathon 2022</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>2022 Hackathon: 字符画 示例程序与帮助</title>
    <link href="https://sumsc-caa.github.io/2022/11/04/hackathon2022-asciiart/"/>
    <id>https://sumsc-caa.github.io/2022/11/04/hackathon2022-asciiart/</id>
    <published>2022-11-04T18:30:02.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;&lt;&lt;&lt; <a href="/2022/11/04/hackathon2022-2/">返回赛题</a></p><h2 id="示例程序"><a class="markdownIt-Anchor" href="#示例程序"></a> 示例程序</h2><p>在运行程序前需要安装依赖：numpy与Pillow，在命令提示符中输入：（不含<code>$</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install numpy Pillow</span><br></pre></td></tr></table></figure><p>示例程序如下（在<a href="/assets/2022hackathon/asciiart.py">这里</a>也可以下载），其中只实现了图片转灰度字符画的核心步骤，你可以完善该程序，优化生成的字符画的效果，或者参考在线资料从零编写自己的程序。</p><script src="https://gist.github.com/Furffico/ef9f7c49aef41e12707803bfc7315e00.js"></script><p>代码中使用的<code>trophy.png</code>是emoji“🏆”（奖杯）在微软的部分产品中的显示效果。生成字符画时需要对比明显、尺寸较小、色彩简单且边缘清晰的图像，所以选择了这张图作为演示。你可以在 <a href="https://emojipedia.org/zh/">Emojipedia</a>中找到更多类似的图片作为测试图片。<code>trophy.png</code>如下：</p><p><img src="/images/hackathon2022f/trophy.png" alt="" /></p><p>对这个程序提出几点可改进之处，仅供参考：</p><ul><li>【重要】查阅<a href="https://pillow.readthedocs.io/en/stable/index.html">Pillow 库的官方文档</a>，在生成字符画之前缩小图像到合适的尺寸</li><li>等宽字体中一个半角字符的宽高比大约是1:2，因此在横向需要用2个字符才能代替1个像素</li><li>对输入图像进行预处理，例如增强图像的对比度等</li><li>使用<code>-\|/</code>等字符突出图像边缘</li><li>尝试使用<a href="https://zh.wikipedia.org/zh-cn/%E6%96%B9%E5%A1%8A%E5%85%83%E7%B4%A0">方块元素</a>代替ascii字符组成字符画</li><li>使用命令行参数控制程序（如另一题的<code>gameofLife.py</code>，可能会用到python标准库中的argparse模块）</li><li>使用colorama模块在命令行中创建彩色字符画</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; &lt;a href=&quot;/2022/11/04/hackathon2022-2/&quot;&gt;返回赛题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#示例程序&quot;&gt;&lt;/a&gt; 示例程序&lt;/h</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>2022 Hackathon: 康威生命游戏 示例程序与使用说明</title>
    <link href="https://sumsc-caa.github.io/2022/11/04/hackathon2022-gameoflife/"/>
    <id>https://sumsc-caa.github.io/2022/11/04/hackathon2022-gameoflife/</id>
    <published>2022-11-04T18:30:01.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;&lt;&lt;&lt; <a href="/2022/11/04/hackathon2022-2/">返回赛题</a></p><h2 id="使用说明"><a class="markdownIt-Anchor" href="#使用说明"></a> 使用说明</h2><h3 id="获取程序"><a class="markdownIt-Anchor" href="#获取程序"></a> 获取程序</h3><p>在本地新建python文件<code>gameofLife.py</code>，在IDE（VScode或pyCharm等）中打开此文件。前往<a href="#%E4%BB%A3%E7%A0%81%E6%9C%AC%E4%BD%93">“代码本体”一节</a>获取程序源代码，并复制到该文件中。</p><h3 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h3><p>在命令提示符中输入下列指令（不包括<code>$</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install numpy</span><br></pre></td></tr></table></figure><p>回车运行即可。</p><h3 id="程序的使用方法"><a class="markdownIt-Anchor" href="#程序的使用方法"></a> 程序的使用方法</h3><p>在命令行中使用<code>cd</code>指令切换到<code>gameofLife.py</code>所在目录，然后输入<code>python gameofLife.py</code>或<code>python3 gameofLife.py</code>即可运行程序。（命令行界面要求是<a href="https://zh.wikipedia.org/zh-cn/%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93">等宽字体</a>才能正常显示程序界面）</p><p>添加命令行参数<code>-h</code>可以看到程序的使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ python3 gameofLife.py -h</span><br><span class="line">usage: gameoflife [-h] [-s W H] [-t T] [-e] [-f F] [-p P] [-w] [FILE]</span><br><span class="line"></span><br><span class="line">Simple implementation of Conway&#x27;s Game of Life in python, CLI version. Written by Furffico for SUMSC Hackathon 2022.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  FILE                 Input initial state [default: random]</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -h, --help           show this help message and exit</span><br><span class="line">  -s W H, --shape W H  Shape of the world. [default: fill the terminal]</span><br><span class="line">  -t T, --iteration T  Maximum count of iterations (set to 0 for infinity). [default: 0]</span><br><span class="line">  -e, --autoexit       Terminate the simulation when certain conditions are met (e.g. no live cells, repeated states). [default: False]</span><br><span class="line">  -f F, --fps F        Set the framerate (frames per second). [default: 10]</span><br><span class="line">  -p P, --position P   Select where to put the loaded world. The first letter indicates horizontal position (l, c, r); the second letter indicates vertical position (t, c, b). [default: cc, choices: lt, ct, rt, lc, cc, rc, lb, cb, rb]</span><br><span class="line">  -w, --waitinit       Pause the program after the initial state is drawn. [default: False]</span><br><span class="line"></span><br><span class="line">This program is distributed under GNU GENERAL PUBLIC LICENSE version 3, for full text please refer to https://www.gnu.org/licenses/gpl-3.0.html</span><br></pre></td></tr></table></figure><p>下面将对各个参数进行详细讲解：</p><ul><li><strong><code>FILE</code></strong> 位置参数为输入的文件，用来指定程序的初始状态，当没有输入文件时程序将随机初始化。关于输入文件的格式请见<a href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">“文件格式说明”</a></li><li><strong><code>-h</code></strong> 参数用于打印上述帮助。</li><li><strong><code>-s</code></strong> 参数接受两个整数参数，分别为宽与高，用来设定地图的大小，默认为填满整个命令行界面。</li><li><strong><code>-t</code></strong> 参数用于指定程序模拟的运行轮数，<u>设为0时程序将永久运行（默认为0）</u>。在程序运行时可以通过<kbd>Ctrl-C</kbd>组合键终止程序的运行。</li><li><strong><code>-e</code></strong> 用于设定当程序检测到循环的状态或者地图内没有活细胞时结束运行。</li><li><strong><code>-f</code></strong> 用于设定程序运行的帧率，默认为每秒10帧。（当帧率过高时可能会导致程序界面出现闪烁现象。）</li><li><strong><code>-p</code></strong> 参数用于设定加载输入的初始状态在地图中的位置，当没有输入文件时该选项无效果。这个参数由两个字符构成，第一个字符指定水平位置，可选的有<code>l</code>、<code>c</code>与<code>r</code>，分别对应左、中、右；第二个字符指定垂直位置，包括<code>t</code>、<code>c</code>与<code>b</code>，分别对应上、中、下。参数一共有九种组合（<code>lt</code>、<code>cb</code>、<code>rc</code>等），默认值为<code>cc</code>，即将输入的状态加载到地图中间。</li><li>加入 <strong><code>-w</code></strong> 可以让程序在展示初始状态后等待你按下回车键再继续运行。</li></ul><p>上述参数结合使用的一些示例如下：（示例在linux系统中运行）</p><ol><li>加载<code>p32-glider-gun.txt</code>到地图左上角（<code>lt</code>），每秒10帧，等待Enter后开始运行。默认为永久运行，示例中使用<kbd>Ctrl-C</kbd>在第15秒终止了程序。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./gameofLife.py ./p32-glider-gun.txt -f 10 -p lt -w</span><br></pre></td></tr></table></figure><p><img src="/images/hackathon2022f/gexample1.gif" alt="" /></p><ol start="2"><li>最多运行200轮，自动退出，设定地图大小为30x20，以每秒10帧的帧率运行（随机初始化）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./gameofLife.py -t 200 -e -s 30 20 -f 10</span><br></pre></td></tr></table></figure><p><img src="/images/hackathon2022f/gexample2.gif" alt="" /></p><h3 id="文件格式说明"><a class="markdownIt-Anchor" href="#文件格式说明"></a> 文件格式说明</h3><p>输入文件为纯文本文件，格式为用于存储康威生命游戏状态的plaintext格式（详见 <a href="https://conwaylife.com/wiki/Plaintext">https://conwaylife.com/wiki/Plaintext</a> ）。在文件中使用英文句号/小数点<code>.</code>表示死细胞，使用大写的英文字母<code>O</code>表示活细胞，每行的长度不定。此外以半角感叹号<code>!</code>开头的行会被忽略，可以在里面写注释。</p><p>下面是一个示例文件（也就是上面一节中示例1的输入文件，<a href="https://conwaylife.com/wiki/Gosper_glider_gun">来源</a>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">!Name: Gosper glider gun</span><br><span class="line">!Author: Bill Gosper </span><br><span class="line">!The first known gun and the first known finite pattern with unbounded growth.</span><br><span class="line">!www.conwaylife.com/wiki/index.php?title=Gosper_glider_gun</span><br><span class="line">........................O...........</span><br><span class="line">......................O.O</span><br><span class="line">............OO......OO............OO</span><br><span class="line">...........O...O....OO............OO</span><br><span class="line">OO........O.....O...OO</span><br><span class="line">OO........O...O.OO....O.O</span><br><span class="line">..........O.....O.......O</span><br><span class="line">...........O...O</span><br><span class="line">............OO</span><br></pre></td></tr></table></figure><h2 id="代码本体"><a class="markdownIt-Anchor" href="#代码本体"></a> 代码本体</h2><p>你可以从下面展示的源代码中直接复制，如果没加载出来请前往<a href="https://gist.github.com/Furffico/ba799e362f4ab82501e5b1105119824a">Github Gist</a>复制，或是从这里直接获取文件：<a href="/assets/2022hackathon/gameofLife.py">下载地址</a>（<strong>可能不是最新的</strong>）</p><script src="https://gist.github.com/Furffico/ba799e362f4ab82501e5b1105119824a.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; &lt;a href=&quot;/2022/11/04/hackathon2022-2/&quot;&gt;返回赛题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用说明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用说明&quot;&gt;&lt;/a&gt; 使用说明&lt;/h</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>技术赋能#1：python的可迭代对象、迭代器与生成器</title>
    <link href="https://sumsc-caa.github.io/2022/10/18/techpost-2022-1/"/>
    <id>https://sumsc-caa.github.io/2022/10/18/techpost-2022-1/</id>
    <published>2022-10-18T12:23:48.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家在学习 python 的 for 循环的时候，一定或多或少听说过<strong>迭代</strong>这个词语。例如下面这段代码中的循环可以描述为“变量<code>i</code>对<code>range(100)</code>迭代”，其中<code>i</code>是迭代变量，<code>range(100)</code>是被迭代的对象。而在 python 中，只有 <strong>可迭代对象（iterable）</strong> 能被迭代。本文将简要介绍可迭代对象，以及 python 中与之相关的两个概念：<strong>迭代器（iterator）<strong>与</strong>生成器（generator）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    s += i</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><h2 id="可迭代对象与迭代器"><a class="markdownIt-Anchor" href="#可迭代对象与迭代器"></a> 可迭代对象与迭代器</h2><p><strong>可迭代对象（iterable）</strong> 包括两种对象，一是实现了<code>__iter__()</code>方法的对象，其中<code>__iter__()</code>方法要求返回一个迭代器；二是具有序列属性的对象，即具有<code>__getitem__()</code>方法，并可以使用连续的自然数作为索引从对象中获得值。我们所接触的大部分 python 内置的数据结构的实例都同时满足这两个条件，包括列表<code>list</code>，元组<code>tuple</code>，字符串<code>str</code>和<code>bytes</code>等；而集合<code>set</code>与字典<code>dict</code>只满足第一个条件，不过它们都是可迭代对象。除此之外，<code>range</code>、<code>map</code>、<code>filter</code>和<code>enumerate</code>等内置函数的返回值也是可迭代对象。</p><p><strong>迭代器（iterator）</strong> 是实现了<code>__next__()</code>方法与<code>__iter__()</code>方法的对象，其中<code>__iter__()</code>方法只能返回对象自身，<u>因此迭代器都是可迭代对象</u>。每次调用该对象的<code>__next__()</code>方法或者对其使用内置函数<code>next()</code>可以从迭代器中获得一个值，当迭代器耗尽时抛出<code>StopIteration</code>异常，结束迭代。</p><h3 id="几个示例"><a class="markdownIt-Anchor" href="#几个示例"></a> 几个示例</h3><p>上面的描述有点抽象了，还是来看看示例吧。下面的例子以内置函数<code>range</code>为例，演示了可迭代对象和迭代器的一些属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rg = <span class="built_in">range</span>(<span class="number">5</span>)  <span class="comment"># 创建range对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(rg)        <span class="comment"># rg有__iter__()方法，是可迭代对象</span></span><br><span class="line">[<span class="string">&#x27;__bool__&#x27;</span>,  ..., <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, ...]</span><br><span class="line"><span class="comment"># 注：next(x)效果同调用 x.__next__()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(rg)       <span class="comment"># rg没有__next__()方法，不是迭代器</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;range&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="comment"># 注：iter(x)效果同调用 x.__iter__()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">iter</span>(rg)   <span class="comment"># 调用__iter__()方法获得可迭代对象对应的迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(r)         <span class="comment"># r有__iter__()与__next__()方法，是迭代器</span></span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, ..., <span class="string">&#x27;__iter__&#x27;</span>, ..., <span class="string">&#x27;__next__&#x27;</span>, ...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(r)        <span class="comment"># 使用next()函数或者__next__()方法从r中获得值</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(r)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.__next__()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.__next__()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(r)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(r)      <span class="comment"># r被耗尽，抛出 StopIteration 异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>下面是一个对比示例，演示了 不是迭代器的可迭代对象 和 迭代器 在 for 循环中的区别。</p><p>不是迭代器的可迭代对象：代码与执行结果如下。因为每次循环开始前都会调用<code>__iter__()</code>方法返回一个新的迭代器，所以两次循环都是从 0 开始的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rg = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rg:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="number">2</span>: <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;|&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rg:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># === output ===</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> | <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>迭代器：将上例中第一行改为<code>rg = iter(range(5))</code>，此时<code>rg</code>变为迭代器，变更后代码的执行结果如下。两次 for 循环开始前都调用<code>__iter__()</code>方法返回<code>rg</code>对象自身（是同一个迭代器），而第一次循环执行到 2 停止了，此时<code>rg</code>中的 0 1 2 均被消耗，因此第二次循环从 3 开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> | <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="自定义迭代器"><a class="markdownIt-Anchor" href="#自定义迭代器"></a> 自定义迭代器</h3><p>根据定义，我们知道迭代器需要具有<code>__next__()</code>方法和返回自身的<code>__iter__()</code>方法。不难据此写出自己的迭代器类，下面就是笔者自定义的一个迭代器类，实现了一个可顺序访问的 Fibonacci 数列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, count: <span class="built_in">int</span></span>):</span><br><span class="line">        self.count = count</span><br><span class="line">        self.last = <span class="number">1</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># __iter__()方法返回对象自身</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">0</span>: <span class="comment"># 如果迭代了指定的次数则抛出 StopIteration</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        self.last, self.current = self.current, self.last+self.current</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.current <span class="comment"># 返回当前值</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Fibonacci(<span class="number">15</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># === output ===</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span></span><br></pre></td></tr></table></figure><p>同时 python 中的迭代器可以是无限的，在上例中只要将<code>Fibonacci()</code>的参数改为负数即可得到一个无限的迭代器。因为它们是无限的，所以在 for 循环中使用它们时一定不要忘记添加退出条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Fibonacci(-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10000</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># === output ===</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span> <span class="number">4181</span> <span class="number">6765</span></span><br></pre></td></tr></table></figure><h2 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h2><p><strong>生成器（生成器函数，generator）</strong> 是指 python 中含有<code>yield</code>关键字的函数，是 python 提供的用于定义生成器的简易方法。生成器函数在调用时会返回一个<strong>生成器迭代器（generator iterator）</strong>（顾名思义这是一种迭代器）。</p><p>你可能也会觉得上面的那个自定义迭代器的代码太冗长了，我们可以使用生成器将其简化（这里就不考虑无限的情况了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">count: <span class="built_in">int</span></span>):</span><br><span class="line">    last, current = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        last, current = current, last+current</span><br><span class="line">        <span class="keyword">yield</span> current <span class="comment"># 使用yield函数返回当前值，同时表明这是一个生成器</span></span><br></pre></td></tr></table></figure><p>在生成器函数中，当函数执行到<code>yield</code>语句的时候会保存函数当前的状态，然后返回语句里的值，相当于函数的运行在这里暂停了。当<code>__next__()</code>再次被调用的时候函数会加载之前保存的状态，并从<code>yield</code>语句继续执行。你可以在上面的例子中添加一些<code>print</code>函数，结合<code>next</code>对生成器迭代来查看具体的执行过程。</p><p>测试代码和结果都和上面的相似，这里就不展示了。需要注意的是，这个例子定义的函数是生成器函数，生成器函数本质上是一个函数，不是可迭代对象，调用生成器函数得到的对象才是迭代器，如下面的例子所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibonacci       <span class="comment"># fibonacci是生成器函数</span></span><br><span class="line">&lt;function fibonacci at <span class="number">0x7facc4139cf0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(fibonacci) <span class="comment"># fibonacci不可迭代</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;function&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibonacci(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib             <span class="comment"># fibonacci函数调用返回的才是生成器迭代器</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> fibonacci at <span class="number">0x7facc42525e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(fib)       <span class="comment"># fib是可迭代对象，对应的迭代器是其自身（内存地址相同）</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> fibonacci at <span class="number">0x7facc42525e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(fib)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="生成器推导式"><a class="markdownIt-Anchor" href="#生成器推导式"></a> 生成器推导式</h3><p><strong>生成器推导式（generator expression）</strong> 是对生成器的简化，可以用来替换一些简单的生成器函数。它的语法结构如下，其中<code>&lt;var&gt;</code>为循环变量，<code>&lt;iterable&gt;</code>为被迭代对象，<code>&lt;expr&gt;</code>为输出表达式，<code>&lt;condition&gt;</code>为逻辑表达式（或者是能转换为布尔值的对象）。这个结构与列表推导式和集合推导式相似，除了两边使用的是圆括号，以及返回值是生成器迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;expr&gt; <span class="keyword">for</span> &lt;var&gt; <span class="keyword">in</span> &lt;iterable&gt; <span class="keyword">if</span> &lt;condition&gt;)</span><br></pre></td></tr></table></figure><p>上面的生成器推导式的结果等价于这个生成器函数的执行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>():</span><br><span class="line">    <span class="keyword">for</span> &lt;var&gt; <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">        <span class="keyword">if</span> &lt;condition&gt;:</span><br><span class="line">            <span class="keyword">yield</span> &lt;expr&gt;</span><br></pre></td></tr></table></figure><p>同时也等价于这个 filter-map 链：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> &lt;var&gt;:&lt;expr&gt;, <span class="built_in">filter</span>(<span class="keyword">lambda</span> &lt;var&gt;:&lt;condition&gt;, &lt;iterable&gt;))</span><br></pre></td></tr></table></figure><h3 id="关于-yield-关键字"><a class="markdownIt-Anchor" href="#关于-yield-关键字"></a> 关于 yield 关键字</h3><p>如果你需要在一个生成器中逐个返回另一个可迭代对象的值，比起使用 for 循环+<code>yield</code>，可以用更简便的<code>yield from</code>，比如下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rangerange</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*rangerange(<span class="number">7</span>))</span><br><span class="line"><span class="comment"># === output ===</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>还有一个不太常用的知识：<code>yield</code>语句是有返回值的，其值来自于调用生成器迭代器的<code>send()</code>方法时的参数。编程时可以利用这个在迭代过程中从外部影响迭代器的状态。可以用下面这个测试函数看看效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = <span class="keyword">yield</span> counter</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;value received at <span class="subst">&#123;counter&#125;</span>:&#x27;</span>, value)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># === testing ===</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)     <span class="comment"># yield语句默认的返回值为None</span></span><br><span class="line">value received at <span class="number">0</span>: <span class="literal">None</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="number">123</span>) <span class="comment"># 调用send方法也会触发一次生成器迭代器的更新</span></span><br><span class="line">value received at <span class="number">1</span>: <span class="number">123</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send()    <span class="comment"># send方法必须接受一个参数</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: generator.send() takes exactly one argument (<span class="number">0</span> given)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">value received at <span class="number">2</span>: <span class="literal">None</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2><p>你可能会想：自定义迭代器到底有什么用呢？我把这些代码移到 for 循环里面不是也有相同的效果？为什么不直接返回一个列表呢？下文将解答你的问题。迭代器的应用与优点包括但不限于：</p><ol><li>迭代器是 python 提供的用于遍历自定义数据结构的接口：假如有人用 python 实现了一个单向链表，并且希望 for 语句能在这个单向链表上迭代，这个时候就需要在单向链表类中实现<code>__iter__()</code>方法将其变成可迭代对象。</li><li>节约内存：以上面的<code>fibonacci</code>生成器为例，记一次性返回完整列表的版本为<code>fibonacci2</code>，假设输入参数是 n，则前者的空间复杂度是 O(1)（因为不用存储每次迭代得到的值），而后者的是 O(n)（需要将每个值存到列表内一次性返回），在 n 很大的时候这个差距尤其明显。</li><li>代码封装：针对第二个问题，只有一个 for 循环时确实有相同的效果。若有多个 for 循环都要用到这段代码，则需要对其进行封装。如果使用返回列表的方法，在数据量大的时候会导致内存的浪费，这时生成器无疑是最合适的。</li></ol><!-- 4. 函数式编程：迭代器和 python 的函数式编程是紧密相连的，因为迭代器输出的是数据流，而函数式编程中最基本的`map/filter/reduce`操作处理的恰恰是数据流。 --><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://docs.python.org/zh-cn/3/glossary.html">术语对照表 - python3.10 官方中文文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信大家在学习 python 的 for 循环的时候，一定或多或少听说过&lt;strong&gt;迭代&lt;/strong&gt;这个词语。例如下面这段代码中的循环可以描述为“变量&lt;code&gt;i&lt;/code&gt;对&lt;code&gt;range(100)&lt;/code&gt;迭代”，其中&lt;code&gt;i&lt;/code</summary>
      
    
    
    
    <category term="技术博客" scheme="https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2022 Hackathon Online</title>
    <link href="https://sumsc-caa.github.io/2022/06/05/hackathon2022-online/"/>
    <id>https://sumsc-caa.github.io/2022/06/05/hackathon2022-online/</id>
    <published>2022-06-05T12:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步io与qq机器人"><a class="markdownIt-Anchor" href="#异步io与qq机器人"></a> 异步IO与QQ机器人</h1><blockquote><p>作者：苏州大学计算机爱好者协会 王嘉睿</p></blockquote><p>如果是常年混迹各大qq群的同学想必都或多或少地见过qq机器人，它们常常具有丰富的功能，并在不同类型的群中发挥着作用：游戏群里的qq机器人可以在对话中查询游戏的相关数据；主播粉丝群里的机器人可以在主播开播时发消息提醒大家；vtuber字幕组群中的qq机器人可以是兼拉取推文、嵌字和发布于一体的“烤推机”；<s>年级群里的qq机器人也可以被辅导员设置用来提醒同学们及时完成青年大学习；</s>此外有些qq机器人还会安装一些小游戏，例如成语接龙等，用于活跃群里的气氛。</p><p>本期魔盒挑战旨在通过引导你动手实现一个简易的qq机器人，让你逐步了解异步编程和python的asyncio（异步io）。</p><h2 id="1-背景知识"><a class="markdownIt-Anchor" href="#1-背景知识"></a> 1 背景知识</h2><h3 id="11-异步"><a class="markdownIt-Anchor" href="#11-异步"></a> 1.1 异步</h3><p><em>了解过异步的同学可以跳过本节。</em></p><p>首先，什么是异步？要回答这个问题，我们可以看看这个例子（网上找的小学奥数题）：</p><blockquote><p>玲玲想给客人烧水沏茶。洗水壶要2分钟，烧开水要12分钟，买茶叶要5分钟，洗茶杯要1分钟，冲茶叶要1分钟，要让客人尽可能早的喝上茶，你认为怎样安排才最合理？最少需要多少分钟？</p></blockquote><p>答案很简单，先洗水壶 <code>2</code> 分钟，然后用水壶烧开水，同时买茶叶、洗茶杯，共 <code>min(12,5+1)=12</code> 分钟，最后使用烧好的开水和买来的茶叶泡茶，需要 <code>1</code> 分钟。因此最少需要 <code>2+12+1=15</code> 分钟才能让客人喝上茶。</p><p>接下来用伪代码复现一下这个安排：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">洗水壶() <span class="comment"># 2 min</span></span><br><span class="line">烧开水() <span class="comment"># 12 min</span></span><br><span class="line">冲茶叶() <span class="comment"># 1 min</span></span><br></pre></td></tr></table></figure><p>诶？好像不太对，我们怎么让程序在执行A任务的同时完成B任务呢？</p><p>有的同学可能会想到多线程，我们再开一个线程让它等水烧开就行：<br /><em>（CPython的多线程其实是假的多线程，详见<a href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock">全局解释器锁</a>，不过在这里不重要）</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">洗水壶()    <span class="comment"># 2 min</span></span><br><span class="line">t=threading.Thread(target=烧开水)</span><br><span class="line">t.start()</span><br><span class="line">买茶叶()    <span class="comment"># 5 min</span></span><br><span class="line">洗茶杯()    <span class="comment"># 1 min</span></span><br><span class="line">t.join()   <span class="comment"># 12-5-1=6 min</span></span><br><span class="line">冲茶叶()    <span class="comment"># 1 min</span></span><br></pre></td></tr></table></figure><p>但是这样就显得有点大材小用了，只是泡个茶居然要用掉两个线程，有没有更好的方法呢？</p><p>让我们来回顾一下解题的过程，首先要理清楚五个任务的因果关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">洗水壶</span><br><span class="line">  │  </span><br><span class="line">烧开水  买茶叶  洗茶杯</span><br><span class="line">  └──────┼──────┘</span><br><span class="line">　　　  冲茶叶</span><br></pre></td></tr></table></figure><p>然后我们会把题中的任务分成两类：</p><ul><li>A类：洗水壶、买茶叶、洗茶杯、冲茶叶</li><li>B类：烧开水</li></ul><p>其中A类任务需要占用玲玲的处理时间，因此不能同时进行，例如玲玲不能在洗茶杯的同时出门买茶叶，称其为“<strong>同步</strong>”的任务。而B类任务不需要占用处理时间，换言之玲玲在烧开水的时候只需要将热水壶装好水插上电就行，剩下的等待时间她可以用来处理其它A类或者B类（比如再烧一壶水）任务，因此可以称其为“<strong>异步</strong>”的任务。</p><p>因为烧开水是异步的，且和买茶叶、洗茶杯之间不存在因果关系，所以我们安排玲玲在烧开水的同时去买茶叶和洗茶杯，节省了6分钟的时间。又因为剩下的任务必须要按因果顺序进行，所以这个就是时间最短的安排了。</p><p>而在python中，上面的程序可以使用asyncio改写成这样，其中的函数虽然都是异步函数的<u>形式</u>，但是只有烧开水是真正的异步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio <span class="comment"># python的异步io库</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">text1,text2,duration,block=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">wrapped</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;:.0f&#125;&#x27;</span>.<span class="built_in">format</span>(time.time()-t0),text1)</span><br><span class="line">        <span class="keyword">if</span> block:</span><br><span class="line">            time.sleep(duration)            <span class="comment"># 同步的等待</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(duration)   <span class="comment"># 异步的等待    </span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;:.0f&#125;&#x27;</span>.<span class="built_in">format</span>(time.time()-t0),text2)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line">洗水壶=f(<span class="string">&#x27;开始洗水壶&#x27;</span>,<span class="string">&#x27;水壶洗好啦&#x27;</span>,<span class="number">2</span>,<span class="literal">True</span>)  <span class="comment"># 同步</span></span><br><span class="line">烧开水=f(<span class="string">&#x27;开始烧开水&#x27;</span>,<span class="string">&#x27;水烧开啦&#x27;</span>,<span class="number">12</span>,<span class="literal">False</span>)  <span class="comment"># 异步</span></span><br><span class="line">买茶叶=f(<span class="string">&#x27;开始买茶叶&#x27;</span>,<span class="string">&#x27;茶叶买好了&#x27;</span>,<span class="number">5</span>,<span class="literal">True</span>)  <span class="comment"># 同步</span></span><br><span class="line">洗茶杯=f(<span class="string">&#x27;开始洗茶杯&#x27;</span>,<span class="string">&#x27;茶杯洗好了&#x27;</span>,<span class="number">1</span>,<span class="literal">True</span>)  <span class="comment"># 同步</span></span><br><span class="line">冲茶叶=f(<span class="string">&#x27;开始冲茶叶&#x27;</span>,<span class="string">&#x27;茶冲好了&#x27;</span>,<span class="number">1</span>,<span class="literal">True</span>)    <span class="comment"># 同步</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">泡茶</span>():</span><br><span class="line">    <span class="keyword">await</span> 洗水壶()           <span class="comment"># 洗水壶</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(   <span class="comment"># 等待下面三个任务全部完成</span></span><br><span class="line">        烧开水(),            <span class="comment"># 首先执行烧开水，因为烧开水是异步的，等待的时间内会依次执行下面两个任务</span></span><br><span class="line">        买茶叶(),</span><br><span class="line">        洗茶杯(),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">await</span> 冲茶叶()           <span class="comment"># 冲茶叶</span></span><br><span class="line"></span><br><span class="line">t0=time.time()  <span class="comment"># 记录开始时间</span></span><br><span class="line">asyncio.run(泡茶()) <span class="comment"># 运行异步函数的入口</span></span><br></pre></td></tr></table></figure><p>运行之后可以看到类似这样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 开始洗水壶</span><br><span class="line">2 水壶洗好啦</span><br><span class="line">2 开始烧开水</span><br><span class="line">2 开始买茶叶</span><br><span class="line">7 茶叶买好了</span><br><span class="line">7 开始洗茶杯</span><br><span class="line">8 茶杯洗好了</span><br><span class="line">14 水烧开啦</span><br><span class="line">14 开始冲茶叶</span><br><span class="line">15 茶冲好了</span><br></pre></td></tr></table></figure><p>可以看到烧开水的等待时间的确有一部分被玲玲用来买茶叶和洗茶杯了，这样玲玲就可以在一个线程内完成泡茶的任务了。实际程序中的任务模型会比上面的例子复杂许多，可能会有上百个异步的网络请求在同时进行，而python的异步io能帮助我们很好地安排和执行这些任务，同时保持代码的简洁与优雅。</p><p>最早在编程语言中大面积使用异步的是JavaScript，关于这个的故事可以参考这篇文章：<a href="https://blog.csdn.net/li123128/article/details/80650256">https://blog.csdn.net/li123128/article/details/80650256</a> 。而python中引入异步io最早是在2015年更新的python3.5，经过几年的打磨和优化，语法逐渐定型成我们今天所见的这个样子。</p><p>希望以上的说明能为你理解异步这个概念提供一些帮助。以下是一些关于python的异步IO的参考资料：</p><ul><li><a href="https://docs.python.org/zh-cn/3/library/asyncio.html">python官方文档 | asyncio——异步I/O</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017959540289152">廖雪峰的官方网站 | 异步IO</a></li></ul><h3 id="12-websocket"><a class="markdownIt-Anchor" href="#12-websocket"></a> 1.2 WebSocket</h3><blockquote><p><strong>WebSocket</strong>是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。</p></blockquote><p>在我们平时所接触的http/https协议中，所有请求都只能由客户端主动发起，这使得以往要实现从服务端向客户端实时发送数据只能使用轮询的模式，即客户端每隔一段时间向服务端发送http请求，服务端收到请求后返回这段时间内累积的数据。这个轮询方案有几个问题：</p><p>其一，传输的损耗很大。假设某实时聊天软件（IM）的客户端每隔<code>5秒</code>向服务器发送一个http的轮询请求，请求和响应的header的大小均为<code>0.5KB</code>，平均情况下每隔15秒就有人给你发一条<code>1KB</code>的消息（大约500个汉字）。这样你每分钟就要花掉<code>1KB*60s/5s+1KB*60s/15s=16KB</code>的流量，一个月下来就是<code>16KB*60*24*30=691.2MB</code>，而其中真正有效的信息只有<code>(1KB/15s)/(1KB/5s+1KB/15s)=25%</code>，无论是用户还是服务提供商都不想承受另外75%的没什么用的流量。</p><p>其二，不适合对延迟很敏感的场景。还是上面那个例子，在轮询机制下消息的延迟上限（不计其它网络延迟）与轮询的间隔相等，在上面的例子中你最多要等5秒才能收到朋友发的消息。而在即时对决的网游中为了降低延迟则必须提高轮询的频率，如果画面帧率为<code>60fps</code>，为了让画面保持同步轮询的频率也得大于<code>60Hz</code>，这样会导致巨额的流量（若是按照上面的数据算，相当于每一帧都要花掉至少<code>1KB</code>，20分钟累计<code>1KB*60Hz*60s/min*20min=72MB</code>），即使把header大小降到0（也就是不使用http协议，直接用tcp），高频率的请求依然会给服务器造成很大的压力。</p><p>WebSocket则可以很好地避免上述问题。WebSocket是全双工的，换言之ws连接的服务端和客户端都可以主动向对方发送信息，并且发送的消息不像http协议需要耗费一定体积作为header，这样就解决了轮询机制的两个问题。现在ws因为其特性被广泛运用在许多即时性强的应用中，例如实时聊天、直播平台的实时评论/弹幕、游戏的客户端与服务端的通信等等。</p><p>项目中使用到的go-cqhttp也提供了http轮询和websocket两种模式，这里我们选择后者是因为后者代码的逻辑更简单。</p><p>在python中我们将使用<strong>websockets</strong>包(package)来和go-cqhttp服务器通信。python中包的安装方法在此不在赘述，建议你为了任务新建一个虚拟环境（参见 <a href="https://docs.python.org/zh-cn/3/library/venv.html">venv - 创建虚拟环境</a>），这样提交的时候可以方便一些。你可以从官方文档了解这个包的基本使用方法，在这里我们只要用到它作为ws客户端的用法，因此服务端的部分可以略过不看。</p><p>相关资料（感兴趣的同学可以阅读其中的 RFC 6455 了解 WebSocket 协议的技术细节）：</p><ul><li><a href="https://websockets.readthedocs.io/en/stable/index.html">websockets 10.3 documentation</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455 - The WebSocket Protocol</a></li></ul><h2 id="2-说明"><a class="markdownIt-Anchor" href="#2-说明"></a> 2 说明</h2><h3 id="21-结构"><a class="markdownIt-Anchor" href="#21-结构"></a> 2.1 结构</h3><p>这个项目的结构如下图：<br /><img src="/images/hackathon2022o/structure.png" alt="项目结构" /></p><p>其中<a href="https://github.com/botuniverse/onebot"><strong>OneBot标准</strong></a>是一个聊天机器人应用接口标准（官网：<a href="https://onebot.dev/">https://onebot.dev/</a> ），<a href="https://github.com/Mrs4s/go-cqhttp"><strong>go-cqhttp</strong></a>是OneBot协议的服务端的golang实现（官网：<a href="https://docs.go-cqhttp.org/">https://docs.go-cqhttp.org/</a> ），在我们的项目中它的作用是连接QQ服务器，将其发来的消息解包后再用OneBot标准打包发送给我们的程序，同样我们发送的请求也会被go-cqhttp以QQ服务器可解析的方式重新打包后发送。</p><h3 id="22-比赛说明"><a class="markdownIt-Anchor" href="#22-比赛说明"></a> 2.2 比赛说明</h3><h4 id="221-赛程"><a class="markdownIt-Anchor" href="#221-赛程"></a> 2.2.1 赛程</h4><ul><li>第一部分 开幕式：6月5日下午</li><li>第二部分 Hackathon主体：6月5日 - 6月12日</li><li>第三部分 作品展示与评选：6月12日 13:30-17:30</li></ul><p>请于作品展示开始前（即 6月12日 13:30 之前）将你所写的<strong>程序的源码</strong>压缩后以你的小组名命名并发送至 <a href="mailto:furffy@outlook.com">furffy@outlook.com</a></p><h4 id="222-评分方式"><a class="markdownIt-Anchor" href="#222-评分方式"></a> 2.2.2 评分方式</h4><p>比赛一共有6道题目，各题的分值与评价方式如下：</p><table><thead><tr><th>题号</th><th>标题</th><th>分值</th><th>评价标准</th></tr></thead><tbody><tr><td>#1</td><td>运行 go-cqhttp 服务端</td><td>5分</td><td>引导任务，不需要展示。<br/>只要完成#2就能得到这5分。</td></tr><tr><td>#2</td><td>复读机</td><td>5分</td><td>引导任务，不需要展示。<br/>只要完成#3就能得到这5分。</td></tr><tr><td>#3</td><td>天气助手</td><td>15分</td><td>基础分15分</td></tr><tr><td>#4</td><td>定时任务</td><td>20分</td><td>基础分10分，评委分10分</td></tr><tr><td>#5</td><td>小游戏</td><td>20分</td><td>基础分10分，评委分10分</td></tr><tr><td>#6</td><td>自由开发</td><td>30分</td><td>基础分10分，评委分20分</td></tr></tbody></table><p>其中，只要你能完成题目的要求就可以拿到基础分，评委分是评委对该题给出的评分的均值。</p><h3 id="23-注意事项"><a class="markdownIt-Anchor" href="#23-注意事项"></a> 2.3 注意事项</h3><ol><li>你<span style="color:#DB452E;font-size:larger;font-weight:bold;">不可以</span>使用现成的python机器人框架，例如<a href="https://docs.nonebot.dev/">nonebot</a>、<a href="https://v2.nonebot.dev/">nonebot2</a>等，但是你可以在编写代码时参考这些框架的结构与实现。</li><li>虽然我们不会公开发布你上传的代码，但是<span style="color:#DB452E;font-size:larger;font-weight:bold;">上传时请务必抹去所有可能会导致你个人隐私泄漏的信息，包括但不限于：在go-cqhttp配置文件中填写的qq号与密码。</span><strong>要对你自己的信息安全负责哦~</strong></li><li>qq机器人在群里发消息时有一定概率会被腾讯风控，具体表现为机器人无法正常在群聊中发送消息，这在go-cqhttp的输出中会有体现（风控 != 封号，若是你的机器人被风控了也不必惊慌，大概过几天就好了，但是这并不代表用自己的大号作为qq机器人就完全没有风险）。目前私信是不受风控影响的，因此比赛中的所有问题都只要求在私信的场景下能正常工作。</li></ol><h3 id="24-参考资料"><a class="markdownIt-Anchor" href="#24-参考资料"></a> 2.4 参考资料</h3><p>以下这些python包或许会有用：</p><ul><li>asyncio: <a href="https://docs.python.org/zh-cn/3/library/asyncio.html">documentation</a></li><li>json: <a href="https://docs.python.org/zh-cn/3/library/json.html">documentation</a></li><li>logging: <a href="https://docs.python.org/zh-cn/3/library/logging.html">documentation</a></li><li>websockets: <a href="https://websockets.readthedocs.io/en/stable/index.html">documentation</a> | <a href="https://github.com/aaugustin/websockets">github</a> | <a href="https://pypi.org/project/websockets/">PyPI</a></li><li>httpx: <a href="https://www.python-httpx.org/">documentation</a> | <a href="https://github.com/encode/httpx/">github</a> | <a href="https://pypi.org/project/httpx/">PyPI</a></li><li>aioschedule (schedule的异步IO版): <a href="https://github.com/ibrb/python-aioschedule">github</a> | <a href="https://pypi.org/project/aioschedule/">PyPI</a> | <a href="https://schedule.readthedocs.io/en/stable/">schedule的documentation</a></li></ul><p>还有一些资料：</p><ol><li><a href="https://docs.go-cqhttp.org/api/">go-cqhttp api文档</a></li><li><a href="https://github.com/botuniverse/onebot-11">onebot-11 协议</a></li><li><a href="https://stackoverflow.com/questions/58454190/python-async-waiting-for-stdin-input-while-doing-other-stuff">stack overflow - Python async: Waiting for stdin input while doing other stuff</a></li><li><a href="https://tenapi.cn/">TenApi</a> （一些有用的公共api）</li></ol><h2 id="3-题目"><a class="markdownIt-Anchor" href="#3-题目"></a> 3 题目</h2><h2 id="31-运行-go-cqhttp-服务端"><a class="markdownIt-Anchor" href="#31-运行-go-cqhttp-服务端"></a> 3.1 运行 go-cqhttp 服务端</h2><blockquote><p>(5分) 参考go-cqhttp的官方文档的<a href="https://docs.go-cqhttp.org/guide/quick_start.html">快速开始</a>和<a href="https://docs.go-cqhttp.org/guide/config.html">配置</a>，下载、配置并在本地（或者你的VPS上）运行一个go-cqhttp服务端。</p></blockquote><p><em>注：配置时请使用你的QQ号或者你的小号，servers部分选择“正向ws”模式。</em></p><h3 id="311-测试程序"><a class="markdownIt-Anchor" href="#311-测试程序"></a> 3.1.1 测试程序</h3><p>以下是一个测试程序，它可以通过ws协议连接go-cqhttp服务器（正向ws），并实时输出它发送的信息，其中地址和<code>&lt;port&gt;</code>要替换为你在本地运行的go-cqhttp服务器的地址和端口，<code>&lt;access-token&gt;</code>替换为你在go-cqhttp的设置文件中设定的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> websockets.connect(<span class="string">&quot;ws://localhost:&lt;port&gt;/?access_token=&lt;access-token&gt;&quot;</span>) <span class="keyword">as</span> websocket:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> websocket.recv())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>如果配置没问题，程序会首先收到连接成功的信息，长这个样子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;_post_method&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;meta_event_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;lifecycle&quot;</span><span class="punctuation">,</span><span class="attr">&quot;post_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;meta_event&quot;</span><span class="punctuation">,</span><span class="attr">&quot;self_id&quot;</span><span class="punctuation">:</span>&lt;当前qq号&gt;<span class="punctuation">,</span><span class="attr">&quot;sub_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;connect&quot;</span><span class="punctuation">,</span><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span>&lt;当前时间戳&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你在cqhttp的设置里打开了心跳，在程序启动后每隔一段时间就能收到来自服务器的heartbeat。如果你试着用别的号给登录机器人的号发送了消息，应该可以在输出中看到go-cqhttp给客户端打包转发的消息。</p><h2 id="32-复读机"><a class="markdownIt-Anchor" href="#32-复读机"></a> 3.2 复读机</h2><blockquote><p>(5分) 以上面的测试程序为基础，参考go-cqhttp的api文档，编写程序实现当某特定的qq号（你或者你的好友，当然要事先联系一下）发来消息时，向该qq号回复相同的消息。</p></blockquote><p>示例对话（其中“我”为该特定的qq号，bot为你编写的机器人）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我&gt; 你好</span><br><span class="line">bot&gt; 你好</span><br><span class="line">我&gt; 人类的本质就是复读机</span><br><span class="line">bot&gt; 人类的本质就是复读机</span><br></pre></td></tr></table></figure><h2 id="33-天气助手"><a class="markdownIt-Anchor" href="#33-天气助手"></a> 3.3 天气助手</h2><blockquote><p>(15分) 以上一题的复读机为基础，删去复读功能，改为当有人向机器人发送<code>天气 &lt;城市名&gt;</code>时，从公共api（例如 <em>2.4 参考资料</em> 中的TenApi）获得该城市的天气并返回。这个功能应该包含在最终提交的代码内。</p></blockquote><p>示例对话（只是示例，bot回复的模板由你来决定）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我&gt; 天气 苏州</span><br><span class="line">bot&gt; 苏州今天的天气是：21-29°C 西南风2级 小雨</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">我&gt; 天气预报 苏州</span><br><span class="line">bot&gt; </span><br><span class="line">苏州今天的天气是：21-29°C 西南风2级 小雨</span><br><span class="line">明天星期四：21-31°C 东南风 晴</span><br><span class="line">后天星期五：……</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><h2 id="34-定时任务"><a class="markdownIt-Anchor" href="#34-定时任务"></a> 3.4 定时任务</h2><blockquote><p>(20分) 利用<code>asyncio</code>的<code>create_task</code>，让机器人可以定时执行任务。这个功能应该包含在最终提交的代码内。</p></blockquote><p>提示：任务循环不应阻塞正常的消息处理，另建议使用aioschedule包简化任务设置的流程。</p><p>定时任务由你来决定，例如：</p><ul><li>每天晚上8点提醒你去刷leetcode；</li><li>工作日12点-16点每隔一个小时发送补水提醒；</li><li>每隔五分钟向直播平台的api（这个就需要一些爬虫和抓包的技术了）发送请求获得直播间开播情况。如果某个主播开播，则向你发送开播提醒。</li></ul><h2 id="35-小游戏"><a class="markdownIt-Anchor" href="#35-小游戏"></a> 3.5 小游戏</h2><blockquote><p>(20分) 以上一题的天气助手为基础，编写一个单人小游戏，要求能做到在私信中与人互动。这个功能应该包含在最终提交的代码内。</p></blockquote><p>如果你想不到什么单人小游戏，可以实现以下样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">我&gt; 猜数 100</span><br><span class="line">bot&gt; 开始猜数，目标在0-100之间，请输入你的答案</span><br><span class="line">我&gt; 50</span><br><span class="line">bot&gt; 小了</span><br><span class="line">我&gt; 75</span><br><span class="line">bot&gt; 大了</span><br><span class="line">我&gt; 62</span><br><span class="line">bot&gt; 小了</span><br><span class="line">我&gt; 68</span><br><span class="line">bot&gt; 小了</span><br><span class="line">我&gt; 71</span><br><span class="line">bot&gt; 小了</span><br><span class="line">我&gt; 73</span><br><span class="line">bot&gt; 恭喜你在第6次尝试猜对啦！</span><br></pre></td></tr></table></figure><h2 id="36-自由开发"><a class="markdownIt-Anchor" href="#36-自由开发"></a> 3.6 自由开发</h2><blockquote><p>(30分) 编写代码为机器人添加功能。</p></blockquote><p><em>注：什么功能都行。可以<strong>参考</strong><a href="https://v2.nonebot.dev/store">nonebot2 的插件列表</a>以获取灵感。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异步io与qq机器人&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#异步io与qq机器人&quot;&gt;&lt;/a&gt; 异步IO与QQ机器人&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：苏州大学计算机爱好者协会 王嘉睿&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>魔盒挑战 2022.5</title>
    <link href="https://sumsc-caa.github.io/2022/04/28/Pandora-22-5/"/>
    <id>https://sumsc-caa.github.io/2022/04/28/Pandora-22-5/</id>
    <published>2022-04-28T16:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="welcome"><a class="markdownIt-Anchor" href="#welcome"></a> Welcome!</h2><p>欢迎来到新一期的魔盒挑战（2022年5月期）！</p><img src="/images/pandora/Pandora-22-5.PNG" style="zoom: 0.5;"><h3 id="什么是魔盒挑战"><a class="markdownIt-Anchor" href="#什么是魔盒挑战"></a> ❓ 什么是魔盒挑战</h3><p>魔盒挑战（Pandora Challenge）是计算机爱好者协会（微软学生俱乐部）技术组定期举行的大型创意编程挑战赛。这一挑战不同于一般的编程竞赛，各位挑战者将收到一个<strong>神秘盒子</strong><s>（不是物理上的盒子）</s>，挑战者需要根据魔盒（赛题）的指引一步步解开魔盒。解开的过程需要挑战者们开动脑筋，发散思维，我们欢迎具有创新的解法！挑战成功有机会获得奖品或技术组的邀请函。</p><h3 id="如何参与"><a class="markdownIt-Anchor" href="#如何参与"></a> 🔍 如何参与</h3><p>本期魔盒挑战的<strong>时间</strong>为：2022年5月1日 12:00 — 2022年5月7日 23:59，为期<strong>一周</strong>，限<strong>单人</strong>参与挑战。</p><p>请各位参与本次魔盒挑战的同学加入QQ群，以便我们能更好地了解各位的题目选择情况，并提供相应的技术支持。</p><p>你一共有<strong>七天</strong>时间来完成这个挑战，无论你是提前完成了挑战，还是时限内未能到达终点，最后都请将的成果及时提交。<br /><strong>如果题目给出了具体的提交方式，请以题目的要求为准</strong>，否则按照下列要求发送<strong>邮件</strong>至<a href="mailto:sumstc@outlook.com">sumstc@outlook.com</a>。邮件请以 <code>Pandora-2022-[参与题目] [姓名] [学号]</code> 命名，请根据各题目要求上传附件。</p><h3 id="本期主题"><a class="markdownIt-Anchor" href="#本期主题"></a> 🔔 本期主题</h3><p>本期共有 2 个题目可供你选择（选择的数量不限）。</p><p>各题目传送门：</p><ul><li>简单LISP解释器 <a href="https://sumsc.github.io/2022/04/28/Pandora-22-5-q1/">传送门</a></li><li>失物招领登记与查询系统 <a href="https://sumsc.github.io/2022/04/28/Pandora-22-5-q2/">传送门</a></li></ul><h3 id="奖品设置"><a class="markdownIt-Anchor" href="#奖品设置"></a> 🎁 奖品设置</h3><p>依照各题目给出的评比标准，排名靠前的同学会有神秘礼品！</p><blockquote><p>奖品由微软亚洲研究院赞助。</p></blockquote><h3 id="参赛协议"><a class="markdownIt-Anchor" href="#参赛协议"></a> 📄 参赛协议</h3><ul><li>参赛者<strong>自愿</strong>参加本次活动；</li><li>我们将于返校后组织参赛获奖者的颁奖活动，地点暂定于俱乐部实验室（天赐庄校区理工楼110）；</li><li>参赛者参与本次活动，默认同意本协议的所有内容。</li></ul><h4 id="参赛守则"><a class="markdownIt-Anchor" href="#参赛守则"></a> 参赛守则</h4><p>参赛者应承诺：</p><ol><li>不对比赛设施（包括但不限于网站、服务器、数据库）进行任何非法操作；</li><li>在活动中使用本人真实信息；</li><li>独立参赛，不得给予、借鉴、抄袭其他参赛者的成果，不得不加以声明地使用他人的开源成果；</li><li>不得出于任何目的采用任何手段攻击比赛设施、其他参与者的设备。</li></ol><p>参赛者如有上述违规行为，苏州大学计算机爱好者协会（微软学生俱乐部）有权取消您的参赛成绩和资格。</p><h4 id="用户隐私"><a class="markdownIt-Anchor" href="#用户隐私"></a> 用户隐私</h4><blockquote><p>本次活动可能会收集您的学号用于身份核实与奖品发放。</p></blockquote><ul><li>我们承诺不会收集任何用户隐私信息，您的学号仅用于验证本人的真实信息；</li><li>我们承诺活动结束后删除所有用户隐私数据。</li></ul><p>活动最终解释权归苏州大学计算机爱好者协会（微软学生俱乐部）所有。</p><hr /><p>2022 苏州大学计算机爱好者协会（微软学生俱乐部）版权所有</p><p>往期回顾：<a href="https://sumsc.github.io/2021/11/25/Pandora-2021-1/">2021年第一期</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;welcome&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#welcome&quot;&gt;&lt;/a&gt; Welcome!&lt;/h2&gt;
&lt;p&gt;欢迎来到新一期的魔盒挑战（2022年5月期）！&lt;/p&gt;
&lt;img src=&quot;/images/pandora/Pa</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Pandora" scheme="https://sumsc-caa.github.io/tags/Pandora/"/>
    
  </entry>
  
  <entry>
    <title>魔盒挑战 2022.5 失物招领登记与查询系统</title>
    <link href="https://sumsc-caa.github.io/2022/04/28/Pandora-22-5-q2/"/>
    <id>https://sumsc-caa.github.io/2022/04/28/Pandora-22-5-q2/</id>
    <published>2022-04-28T15:39:39.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>出题人：孙家扬(<a href="https://github.com/BlueberryOreo">git</a>)，李承庚(<a href="https://github.com/lcg-wow">git</a>)</p></blockquote><hr /><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>大学生活中，遗失物品是一个很常见的现象，遗失物品的人通过什么样的途径来查找自己丢失的物品便是一个值得思考的问题；与此同时，对于捡到遗失物品的人来说，如何方便准确地将捡到的物品归还给遗失物品的人，同样是一个值得我们思考的问题。现在把这个问题交给你，请你为遗失物品的人和捡到遗失的物品的人搭建一个桥梁，方便他们查询和登记遗失的物品。</p><h2 id="你需要做的"><a class="markdownIt-Anchor" href="#你需要做的"></a> 你需要做的</h2><p>你需要设计一个程序，语言不限。基本要求很简单。首先，这个程序能够帮助捡到遗失物品的人<strong>登记</strong>他们捡到的遗失物品。每登记一个物品，需要用户提供<strong>一张图片</strong>，同时提供一些<strong>相关的标签</strong>，便于后续的查找。其次，这个程序还需要帮助遗失物品的人根据他们的<strong>描述</strong>来查找已登记的物品，即输入相应的标签，返回包含有这个标签的图片。</p><p>我们使用Python的tkinter库写了一个样例程序（见下）。这个样例实现了基本的登记物品和查找物品。如果你不想白手起家，那么你也可以在我们写好的样例程序上面进行<strong>升级</strong>。升级内容不限，你可以选择改进界面，让界面更加丰富；你也可以选择增加其中的功能，使其更加完善；等等。</p><h2 id="提高"><a class="markdownIt-Anchor" href="#提高"></a> 提高</h2><p>到此，这是一个本地的后端的程序。我们知道，这样的登记查询系统如果建立在网站上将会更加有意义。请尝试将该系统建立到网站上。</p><h2 id="挑战"><a class="markdownIt-Anchor" href="#挑战"></a> 挑战</h2><p>这个程序的查询当前还限制在标签的查询。你有没有什么想法或办法，不通过标签，直接输入相关描述，返回相关的图片？</p><hr /><h2 id="样例程序"><a class="markdownIt-Anchor" href="#样例程序"></a> <a href="https://github.com/BlueberryOreo/Simple-lost-and-found-management-system">样例程序</a></h2><h3 id="样例程序说明"><a class="markdownIt-Anchor" href="#样例程序说明"></a> 样例程序说明</h3><p>样例程序包含：<code>__init__.py</code>, <code>main.py</code>, <code>window.py</code>, <code>data</code></p><p><code>__init__.py</code>为Python package管理文件</p><p><code>main.py</code>为主程序</p><p><code>window.py</code>为创建图形用户界面的程序</p><p><code>data</code>为存储照片和相关标签的文件夹，内含<code>picture</code>文件夹和<code>data.dat</code></p><hr /><h2 id="评分标准"><a class="markdownIt-Anchor" href="#评分标准"></a> 评分标准</h2><p>满分为100分</p><table><thead><tr><th style="text-align:center">评分项</th><th style="text-align:center">分数</th></tr></thead><tbody><tr><td style="text-align:center">功能完善</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">创意性</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">用户操作体验</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">界面美观</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">代码美观</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">程序出现错误</td><td style="text-align:center">-5</td></tr></tbody></table><hr /><p>最后更新时间：2022.4.27</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;出题人：孙家扬(&lt;a href=&quot;https://github.com/BlueberryOreo&quot;&gt;git&lt;/a&gt;)，李承庚(&lt;a href=&quot;https://github.com/lcg-wow&quot;&gt;git&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquo</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Pandora" scheme="https://sumsc-caa.github.io/tags/Pandora/"/>
    
  </entry>
  
  <entry>
    <title>魔盒挑战 2022.5 简单LISP解释器</title>
    <link href="https://sumsc-caa.github.io/2022/04/28/Pandora-22-5-q1/"/>
    <id>https://sumsc-caa.github.io/2022/04/28/Pandora-22-5-q1/</id>
    <published>2022-04-28T15:39:36.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一份简易的lispscheme教程"><a class="markdownIt-Anchor" href="#一份简易的lispscheme教程"></a> 一份简易的LISP（Scheme）教程</h2><p>相信不少人对LISP这门编程语言有所耳闻，又常常听说这门语言“抽象难学”。但实际上LISP的语法规则相当简单，甚至只有几个最基本的规则。下面就拿LISP的一种经典方言Scheme举例：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上面的代码很好理解。<code>(+ a b)</code>在这里是一个<strong>表达式</strong>，可以理解为一个函数，接受两个参数，并且返回它们之和，<code>(+ 1 2)</code>的结果就是<code>3</code>，同理<code>(* 2 3)</code>的结果是<code>6</code>，<code>(- 1 2)</code>的结果是<code>-1</code>……</p><p>这些表达式也可以组合起来：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">3</span> <span class="number">5</span>) (<span class="name"><span class="built_in">-</span></span> <span class="number">10</span> <span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>上面这个表达式的值就是<code>19</code>，这相当于<code>(3 * 5) + (10 - 6)</code>。</p><p>我们常常将LISP表达式通过缩进更清晰地表示：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">3</span></span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">2</span> <span class="number">4</span>)</span><br><span class="line">         (<span class="name"><span class="built_in">+</span></span> <span class="number">3</span> <span class="number">5</span>)))</span><br><span class="line">   (<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">-</span></span> <span class="number">10</span> <span class="number">7</span>)</span><br><span class="line">      <span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>上面这段代码相当于<code>(3 * ((2 * 4) + (3 + 5))) + ((10 - 7) + 6)</code>，值是<code>57</code>.</p><p>除了基本的加减乘除外，LISP还有一些特殊的关键字，例如<code>define</code>可以用来<strong>定义变量</strong>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> size <span class="number">2</span>)</span><br><span class="line">(<span class="name"><span class="built_in">*</span></span> <span class="number">5</span> size)</span><br></pre></td></tr></table></figure><p>这里先定义了一个值为<code>2</code>的变量<code>size</code>，然后将它乘以<code>5</code>，最终结果是<code>10</code>.</p><p>更有意思的是，<code>define</code>还可以用来<strong>定义自己的函数</strong>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br></pre></td></tr></table></figure><p>这里定义了一个名为<code>square</code>的函数，它接收一个参数<code>x</code>，并返回它的平方。</p><p>我们刚才定义的<code>square</code>函数可以这样调用：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> size <span class="number">3</span>)</span><br><span class="line">(<span class="name">square</span> size)</span><br></pre></td></tr></table></figure><p>这段代码的返回值是<code>9</code>.</p><p>下面是<strong>define函数定义</strong>的一般形式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">&lt;函数名&gt;</span> &lt;参数1&gt; &lt;参数2&gt; &lt;参数3&gt; ...) &lt;具体实现...&gt;)</span><br></pre></td></tr></table></figure><p>下面定义一个稍微复杂的函数<code>sum-of-squares</code>，接收两个参数，返回它们的平方和：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">sum-of-squares</span> x y)</span><br><span class="line">  (<span class="name"><span class="built_in">+</span></span> (<span class="name">square</span> x) (<span class="name">square</span> y))</span><br></pre></td></tr></table></figure><p>注意到，这里使用了刚才定义的<code>square</code>函数。上面这段代码应该很容易理解。下面我们使用该函数：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">sum-of-squares</span> <span class="number">3</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>这段代码的返回值是<code>25</code>，即<code>(3 * 3) + (4 * 4)</code>的值.</p><p>除了<code>define</code>之外，LISP也有类似<code>if ... else ...</code>的<strong>条件表达式</strong>，在Scheme中它被这样实现：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">&gt;</span></span> x <span class="number">0</span>) x)</span><br><span class="line">        ((<span class="name"><span class="built_in">=</span></span> x <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>) (<span class="name"><span class="built_in">-</span></span> x))))</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个<code>abs</code>函数，用来返回某个数的绝对值。这里使用了<code>cond</code>做条件判断。上面的代码应该也不难理解。<strong>cond条件表达式</strong>的一般形式如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cond</span></span> (<span class="name">&lt;条件1&gt;</span> &lt;返回值1&gt;)</span><br><span class="line">      (<span class="name">&lt;条件2&gt;</span> &lt;返回值2&gt;)</span><br><span class="line">      (<span class="name">&lt;条件3&gt;</span> &lt;返回值3&gt;)</span><br><span class="line">      ...)</span><br></pre></td></tr></table></figure><p>同时<code>cond</code>表达式也提供了一个可选的<code>else</code>，用来在所有条件都不成立时返回值：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>) (<span class="name"><span class="built_in">-</span></span> x))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> x)))</span><br></pre></td></tr></table></figure><p>此外，Scheme也提供了简化的<code>cond</code>，即<code>if</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">abs</span></span> x)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">-</span></span> x)</span><br><span class="line">      x))</span><br></pre></td></tr></table></figure><p>上面的代码也很好理解。<code>if</code>后面跟的第一个参数是条件，条件应该是一个返回布尔值的函数，这里的<code>(&lt; x 0)</code>表示条件&quot;若<code>x</code>小于<code>0</code>&quot;；第二个参数是当条件成立时的返回值，也就是<code>x</code>小于<code>0</code>时返回<code>-x</code>；第三个参数是当条件不成立时的返回值，也就是当<code>x</code>大于等于<code>0</code>时返回<code>x</code>。</p><p>下面是<strong>if条件表达式</strong>的一般形式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">if</span></span> &lt;条件&gt; &lt;条件成立时的返回值&gt; &lt;条件不成立时的返回值&gt;)</span><br></pre></td></tr></table></figure><p>同时，Scheme也包含Python中的<code>and</code>、<code>or</code>、<code>not</code>，而且它们也是<strong>惰性求值</strong>的：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">and</span></span> &lt;e1&gt; &lt;e2&gt; &lt;e3&gt; ...)</span><br><span class="line">(<span class="name"><span class="built_in">or</span></span> &lt;e1&gt; &lt;e2&gt; &lt;e3&gt; ...)</span><br><span class="line">(<span class="name"><span class="built_in">not</span></span> &lt;e&gt;)</span><br></pre></td></tr></table></figure><p>对于<code>and</code>，Scheme解释器从左到右一个个地求值<code>&lt;e&gt;</code>，如果某个<code>&lt;e&gt;</code>求值得到假，这一and表达式的值就是假，后面那些<code>&lt;e&gt;</code>自然也不用再求值了。如果所有的<code>&lt;e&gt;</code>都求出真值，这一and表达式的值就是最后那个<code>&lt;e&gt;</code>的值。</p><p>同理，对于<code>or</code>，Scheme解释器从左到右一个个地求值<code>&lt;e&gt;</code>，如果某个<code>&lt;e&gt;</code>求值得到真，这一or表达式的值就是真，后面那些<code>&lt;e&gt;</code>自然也不用再求值了。如果所有的<code>&lt;e&gt;</code>都求出假值，这一or表达式的值就是最后那个<code>&lt;e&gt;</code>的值。</p><p>对于<code>not</code>，如果<code>&lt;e&gt;</code>求出的值是假，not表达式的值就是真，否则其值为假。</p><p>作为示例，下面定义大于等于函数<code>&gt;=</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">&gt;=</span></span> x y)</span><br><span class="line">  (<span class="name"><span class="built_in">or</span></span> (<span class="name"><span class="built_in">&gt;</span></span> x y) (<span class="name"><span class="built_in">=</span></span> x y)))</span><br></pre></td></tr></table></figure><p>或者可以这么定义：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">&gt;=</span></span> x y)</span><br><span class="line">  (<span class="name"><span class="built_in">not</span></span> (<span class="name"><span class="built_in">&lt;</span></span> x y))</span><br></pre></td></tr></table></figure><p>实际上，<strong>到此为止，所有基本的Scheme语法就解释完毕了，已经可以开始编写图灵完备的程序了</strong>。仅仅掌握这些知识就能写代码了，简直简单到不可思议……<strong>但是等一下，循环呢？</strong></p><p><strong>在LISP中，循环的实现方式是递归</strong>。Lisp没有常规的for/while循环，一切类似的操作都可以使用递归实现。下面通过已经介绍的这些语法，实现一个计算阶乘的函数<code>factorial</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">1</span>)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      (<span class="name"><span class="built_in">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure><p>可以看到，这里使用了递归的思想：若<code>n</code>是<code>1</code>，则直接返回<code>1</code>，否则返回<code>n</code>乘以<code>factorial(n-1)</code>。计算阶乘就是这么简单。</p><p>下面我们尝试着综合运用学到的知识，实现一个求幂的函数。相比于上面实现阶乘的函数，这里的求幂函数使用了迭代的思想，所以会稍微复杂一些，可能需要花一点时间去理解，你也许需要在草稿纸上动手画一画示意图，但这里用到的知识完全没有超出上面介绍的范围：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">expt</span></span> b n)</span><br><span class="line">  (<span class="name">expt-iter</span> b n <span class="number">1</span>))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">expt-iter</span> b counter product)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> counter <span class="number">0</span>)</span><br><span class="line">      product</span><br><span class="line">      (<span class="name">expt-iter</span> b</span><br><span class="line">                 (<span class="name"><span class="built_in">-</span></span> counter <span class="number">1</span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">*</span></span> b product))))</span><br></pre></td></tr></table></figure><p>不过，这种求幂的方法未免有些低效。我们知道<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">b^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>可以拆分成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>4</mn></msup><mo>∗</mo><msup><mi>b</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">b^4*b^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">b^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>又可以继续拆分成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>∗</mo><msup><mi>b</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">b^2*b^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">b^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">b*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，只需通过这么三步就可以计算得到结果。而上面的代码如果要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">b^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，则只是一步步将结果乘以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，计算了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>次。于是我们可以这样实现一个快速求幂函数：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">fast-expt</span> b n)</span><br><span class="line">  (<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="built_in">even?</span></span> n) (<span class="name">square</span> (<span class="name">fast-expt</span> b (<span class="name"><span class="built_in">/</span></span> n <span class="number">2</span>))))</span><br><span class="line">        (<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">*</span></span> b (<span class="name">fast-expt</span> b (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))))))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">even?</span></span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">remainder</span></span> n <span class="number">2</span>) <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>上面代码里的<code>remainder</code>表示求余，相当于Python中的<code>%</code>符号。</p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>好了，通过上面的教程，你应当已经基本理解Scheme的语法了。这些语法本质上非常简单，而且LISP独特的语法使得这些语法解析起来非常简单。你可能会认为实现一个Scheme解释器非常复杂，但实际上如果只需要实现上面这些简单的功能，几十行Python代码就可以做到，你可以试试看。事实上，目前速度最快并且进行高度优化的一个完整Scheme解释器&quot;Chez Scheme&quot;也只用了不到一千行C语言代码，由此可见Lisp的实现是多么简单。</p><p>你只需要编写一个Python版本的Scheme解释器（当然，如果你乐意，也可以使用其它语言），<strong>这个解释器只需要实现上面提到的最基本的语法</strong>。它接受一个字符串，也就是Scheme代码，返回这段代码的执行结果。你的脚本应当可以通过命令行进行交互，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python test.py <span class="string">&quot;(define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) (factorial 5)&quot;</span></span></span><br><span class="line">120</span><br></pre></td></tr></table></figure><p>或者，这个Scheme解释器可以读取一个文本文件，执行其中的Scheme代码。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python test.py expt.txt</span></span><br><span class="line">256</span><br></pre></td></tr></table></figure><p>下面是上面示例中expt.txt的内容：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name"><span class="built_in">expt</span></span> b n)</span><br><span class="line">  (<span class="name">expt-iter</span> b n <span class="number">1</span>))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">expt-iter</span> b counter product)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> counter <span class="number">0</span>)</span><br><span class="line">      product</span><br><span class="line">      (<span class="name">expt-iter</span> b</span><br><span class="line">                 (<span class="name"><span class="built_in">-</span></span> counter <span class="number">1</span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">*</span></span> b product))))</span><br><span class="line">(<span class="name"><span class="built_in">expt</span></span> <span class="number">2</span> <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>在这里给出一个基本的Python代码框架，它接收一个文件名，读取并解析该文件中的Scheme代码，并打印结果到终端（不过如果你喜欢，自然也可以不按这个框架来写）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_code_string</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;interpreter takes exactly one argument (0 given)&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args) &gt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&#x27;interpreter takes exactly one argument (<span class="subst">&#123;<span class="built_in">len</span>(args) - <span class="number">1</span>&#125;</span> given)&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    filepath = args[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(process_code_string(s))</span><br></pre></td></tr></table></figure><p>解释器的核心代码应该都包括在process_code_string这一函数中。这里省略了该函数的实现，因为这显然是需要你自己去完成的。</p><p><strong>具体来说，你需要实现以下Scheme语法</strong>：</p><ul><li>实现基本的数据类型（数字及布尔值）</li><li>基本组合式，例如加减乘除运算、取负数、取余（remainder）、求商（quotient）、开方（sqrt）、判断相等/大于/小于等。如果你愿意实现一个更完善的解释器，可以考虑加入sin、cos、tan、asin、acos、atan、min、max、abs、square、exp、expt、log等内置函数</li><li>变量及函数定义（通过define）。或者你也可以通过lambda块的方式实现函数定义（你可以自行了解相关资料）</li><li>cond条件表达式，需要包含else的实现，并且需要包含and/or/not。你实现的cond表达式应当是惰性求值的</li><li>（可选）实现if表达式。由于if表达式实质上是对cond的简化，因此这并不是必须实现的</li><li>递归调用函数</li></ul><p><strong>下面是详细的评分标准（满分100分）：</strong></p><ul><li>实现基本组合式求值与数字类型（例如<code>(+ 1 2)</code>）—— 15分</li><li>实现布尔类型（<code>#f</code>和<code>#t</code>） —— 5分</li><li>实现常见运算（加减乘除、取余、开方、相等/大于/小于判断等）—— 10分</li><li>实现变量定义 —— 15分</li><li>实现cond条件表达式（if表达式可不实现）—— 10分</li><li>实现函数定义（define或lambda块，可挑选任意一种实现方式） —— 20分</li><li>实现函数的递归调用 —— 15分</li><li>其他分数（根据实现方式、逻辑结构、代码规范等给出的主观综合评分）—— 10分</li></ul><p><strong>你需要在附带的文档中给出你实现Scheme解释器的过程，使用了什么样的思路，并给出<em>示例代码</em>和<em>运行结果</em>。此外，你还需要给出附有适当注释的解释器源代码。</strong></p><p><strong>在完成这一题目后（即使你仅仅完成了一小部分也没有关系），请将代码及文档发送到邮箱<a href="mailto:gaoge011022@163.com">gaoge011022@163.com</a>，我们会尽快为题目打分，给出结果。</strong>当然了，如果你不仅仅满足于此，你也可以考虑继续实现下面的”进阶“甚至“挑战”任务，会有加分。</p><p><strong>提示</strong>：如果你希望高效地实现这个解释器，可能会需要用到关于<code>抽象语法树(Abstract Syntax Tree)</code>的知识，这是一种简单的树状数据结构，并且与Lisp语法的相性非常好。不过，如果你不愿那么深入，直接用<code>正则表达式</code>甚至通过.replace()和.split()分割字符串也能实现一个不错的Scheme解释器。</p><p><strong>提示2</strong>：如果你希望能够实际体验一下编写Scheme代码，你可以在<a href="https://github.com/cisco/ChezScheme/releases/download/v9.5.6/ChezScheme9.5.6.exe">Chez Scheme的官方网站</a>上下载安装一个现成的Scheme解释器用来体验一下。在安装完成后，你的电脑上将会出现Chez Scheme的程序，运行之后会弹出一个交互式的命令行窗口，你可以在这里运行你的Scheme代码。</p><p><strong>提示3</strong>：如果你对如何实现这个解释器毫无头绪，<strong>可以通过搜索“Python实现LISP解释器”获得一些信息</strong>。不过建议你尽量不要这么做。</p><p><strong>注意事项</strong>：在Scheme中，<code>布尔值</code>被表示为<code>#f</code>或<code>#t</code>，对应着Python中的False与True，例如<code>(&gt; 1 2)</code>对应的返回值就应该是<code>#f</code>。</p><p><strong>注意事项2</strong>：在Scheme中，可以使用<code>;</code>表示注释的开头，以换行作为结尾。例如<code>(expt 2 8) ; 256</code>，这后面的<code>; 256</code>会被自动忽略。你可以考虑实现这一特性，也可以选择不实现。</p><p><strong>注意事项3</strong>：如果你仍感觉实现这些功能比较困难，可以考虑只实现上面提到的一部分功能，例如只实现最简单的<code>(+ 1 2)</code>，变量定义<code>(define x 1)</code>等。</p><h2 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h2><p>如果你在实现完这个简单的Scheme解释器后仍有余力，可以考虑实现一些更高级的语法，例如添加对<code>字符串</code>和<code>浮点数</code>的支持、<code>lambda语句块</code>、<code>列表(list)</code>、<code>局部变量(let)</code>甚至<code>闭包</code>。你可以在w3cschool上找到一个<a href="https://www.w3cschool.cn/yast_cn/ciw3kozt.html">完整的Scheme教程(Yet Another Scheme)</a>，并考虑实现这里提到的部分特性。当然，你也可以自己查找其他资料学习Scheme。</p><p>这里并不给出一个具体需要实现哪些语法的列表，你可以自由发挥。推荐你先尝试实现列表（cons及list），以及在列表上使用的一些常用函数（car/cdr/filter/map/reduce/for-each等），由于Python本身对这些函数有支持，并且Python的list与Scheme中的list很相似，因此你只需要在之前的代码基础上做一些小小的改进就可以实现。或者你也可以先实现lambda语句块，它本质上不过是另一种更通用的变量定义方式，应当也是很容易实现的。你也可以优先考虑实现let/throw/quote这些简单的语法，这应当也比较轻松。至于实现字符串可能稍微有些困难，这需要运用一些数据结构的思想，例如栈和树，不过你也可以通过简单的循环判断实现。</p><p>另外，非常推荐你首先选择实现Scheme内置的<code>(display x)</code>函数，它负责在命令行（终端）中直接打印x的值，很类似于Python中的<code>print</code>函数。这样就可以非常方便地调试Scheme代码了。</p><p>你甚至可以考虑实现一些自己的独特想法，甚至是不包含在Scheme语法规范里的语法。例如，你可以实现一个<code>(print-to-file &lt;string&gt; &lt;filepath&gt;)</code>函数，将字符串<code>&lt;string&gt;</code>的值输出到文件。你也可以将一些函数内置，例如上面提到的<code>(square x)</code>函数，使其不需定义就可以直接使用。你可以充分发挥创造力，打造属于自己的LISP方言。</p><p>例如，在LISP的另一门方言Clojure中，实现了宏定义<code>(-&gt;&gt; ...)</code>，它可以像下面这样使用：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">-&gt;&gt;</span></span> <span class="number">1</span></span><br><span class="line">     (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span>)</span><br><span class="line">     (<span class="name"><span class="built_in">*</span></span> <span class="number">2</span>)</span><br><span class="line">     (<span class="name"><span class="built_in">-</span></span> <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>上面这段代码的值是<code>-6</code>，正好就是<code>((1 + 1) * 2) - 10</code>的结果。在Clojure中，这被称为<code>thread-last</code>宏，它将典型的LISP书写顺序颠倒了过来，重整为更自然的从左到右的阅读顺序，很符合人类的习惯，也更加清晰。</p><p>假设你已经实现了list、字符串、lambda块等高级特性，利用上面提到的&quot;-&gt;&gt;&quot;，就可以编写更有意思的代码：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">process-string</span> Alist)</span><br><span class="line">  (<span class="name">-&gt;&gt;</span> Alist</span><br><span class="line">       (<span class="name">filter</span> (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">&gt;</span></span> (<span class="name"><span class="built_in">string-length</span></span> x) <span class="number">1</span>)))</span><br><span class="line">       (<span class="name"><span class="built_in">map</span></span> capitalize)</span><br><span class="line">       (<span class="name">interpose</span> <span class="string">&quot;,&quot;</span>)</span><br><span class="line">       (<span class="name">reduce</span> str)))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> list-of-employees (<span class="name"><span class="built_in">list</span></span> <span class="string">&quot;neal&quot;</span> <span class="string">&quot;s&quot;</span> <span class="string">&quot;stu&quot;</span> <span class="string">&quot;j&quot;</span> <span class="string">&quot;rich&quot;</span> <span class="string">&quot;bob&quot;</span> <span class="string">&quot;aiden&quot;</span>))</span><br><span class="line">(<span class="name">process-string</span> list-of-employees)</span><br><span class="line"><span class="comment">; 下面一步一步地演示了list-of-employees的转换过程</span></span><br><span class="line"><span class="comment">; (&quot;neal&quot; &quot;s&quot; &quot;stu&quot; &quot;j&quot; &quot;rich&quot; &quot;bob&quot; &quot;aiden&quot;)</span></span><br><span class="line"><span class="comment">; (&quot;neal&quot; &quot;stu&quot; &quot;rich&quot; &quot;bob&quot; &quot;aiden&quot;)</span></span><br><span class="line"><span class="comment">; (&quot;Neal&quot; &quot;Stu&quot; &quot;Rich&quot; &quot;Bob&quot; &quot;Aiden&quot;)</span></span><br><span class="line"><span class="comment">; (&quot;Neal&quot; &quot;,&quot; &quot;Stu&quot; &quot;,&quot; &quot;Rich&quot; &quot;,&quot; &quot;Bob&quot; &quot;,&quot; &quot;Aiden&quot;)</span></span><br><span class="line"><span class="comment">; &quot;Neal, Stu, Rich, Bob, Aiden&quot;</span></span><br></pre></td></tr></table></figure><p>上面先不讨论filter、map、capitalize、interpose、reduce、str这几个内置函数是怎么实现的，只着眼于代码本身。上面这段代码演示了处理如何处理一个包含公司雇员姓名的列表：先去除所有只有一个字母的错误数据，再对每个雇员的姓名应用<code>capitalize</code>，即将其首字母大写，然后用<code>interpose</code>在两两单词之间插入<code>,</code>作为分隔符，然后通过<code>reduce</code>累加地调用<code>str</code>函数将这些单词组合起来。</p><p>上面代码中演示的解决问题的方式被称为<strong>函数式编程思想</strong>，而LISP就是一种典型的函数式编程语言。函数式编程不关心复杂的数据结构与类继承关系，而是创造一系列通用的函数，将复杂的问题转换为最基本的几个数据结构，然后利用这些通用的函数求解问题，而不是制造更多的数据结构。函数式编程将函数当作”一等公民“，函数也可以被当作变量，可以直接作为参数传入，这被称为<code>高阶函数</code>，例如上面代码中的&quot;filter&quot;就接收了一个lambda函数作为参数。在函数式编程中，很常用的三个操作列表的函数是<code>filter(筛选)</code>、<code>map(映射)</code>、<code>reduce(折叠/化约)</code>，Python中也有这三个函数，你可以了解一下，并考虑在你的Scheme解释器上实现它们（不过你显然需要先实现list）。此外，函数式编程还有不变性、减少副作用等概念，你若感兴趣可以自行了解。</p><p>不过，要让你的Scheme解释器支持运行上面提到的代码可能并不容易。这个例子仅仅是展示了LISP的无限可能：即使<code>-&gt;&gt;</code>并不是Scheme的标准语法，你仍可以轻松地实现这个功能（相较于其他语言来说），这意味着你可以充分发挥你的想象力，创造属于自己的LISP方言。</p><p>当然了，<strong>这一部分不作强制要求</strong>，仅仅作为加分项<strong>（满分40分，作为附加分）</strong>。<strong>如果你实现了基本功能之外的功能，需要在附带的文档中指出你实现了哪些Scheme高阶特性，又有哪些是你独创的语法，并给出示例代码和运行结果。此外，你还需要给出附有适当注释的解释器源代码。</strong></p><p>为了不束缚想象力，这一部分较为开放，<em>并不包括详细的评分标准</em>。但你可以在下面的推荐里挑选几个实现。当然，你可以实现的功能远不仅限于这个范围。<strong>我们会根据你具体的实现情况以及创新点决定你的40分附加分</strong>：</p><ul><li>实现字符串以及浮点数</li><li>实现局部变量（let）</li><li>实现高阶函数</li><li>实现列表（list和cons）及相关函数（filter/map/reduce/for-each等）</li><li>实现内置的哈希表</li><li>实现文件输入/输出API</li><li>实现引用语法（'）</li><li>实现向量（vector）</li><li>实现一些独特的内置宏定义（例如上面演示的<code>thread-last</code>宏）</li><li>实现一些有趣的独创语法</li><li>其他创新点</li></ul><p>再次强调，相比于100%还原Scheme语法，我们更希望能够看到一些闪光的创新点。我们的目的并不是复刻一门语言，而是实现一个有趣的解释器。因此，我们会考虑对创新特性进行更多加分，即使是实现起来非常容易的创新点。</p><blockquote><p>注：如果你对此很感兴趣，希望深入学习Scheme，可以在这次活动结束后阅读《计算机程序的构造与解释（SICP）》，这本书从原理入手，通过Scheme解释了编程语言的原理，很有趣但也很需要一定的思维量。不过在这次活动中就不推荐你阅读了，这本书需要很长的时间才能搞明白，而且应当对你在本次活动中的解题过程没什么帮助。</p></blockquote><h2 id="挑战"><a class="markdownIt-Anchor" href="#挑战"></a> 挑战</h2><p><strong>注意</strong>：这一部分仅仅作为“挑战”，即使你完成了这些挑战，给出了很完善的实现，也只能获得<strong>很少的加分（满分10分）</strong>。建议优先考虑完善上面的基本题目与“进阶”部分。</p><p>如果你在完成进阶任务后仍有余力，可以考虑完成这里的一部分“挑战”。完成这些挑战有助于将你的Scheme解释器变成一个真正具有实用价值的解释器，可以真正方便地运行各种代码，并且具有简单的调试功能。</p><p>以下是挑战列表。当然，如果你不满足于这些挑战，也可以自己完成想做的挑战：</p><ul><li>实现一个简单的REPL（交互式运行环境），就像Python自带的IDLE一样。实现这一功能可能远比你想象的简单许多，甚至只需要十数行代码</li><li>输出更好的报错信息，当代码出现语法错误时猜测可能是哪里出了问题</li><li>实现尾递归优化</li><li>实现垃圾回收（你可以考虑最简单的引用计数法，当然也可以挑战自己选择使用更复杂的算法实现）</li><li>考虑完全不使用eval实现解释器。注意：较难</li><li>为LISP添加面向对象支持，例如加入class关键字。如果你对如何添加类似Java/Python中传统的面向对象支持没有头绪，可以考虑实现JavaScript中的原型链继承。一个更简单的主意是先考虑实现C语言中的结构体（struct）。注意：这可能非常困难！尝试完成这一挑战时请务必谨慎</li></ul><p>值得注意的是，“挑战”与“进阶”的区别在于“进阶”仅限于语法层面，而“挑战”部分的内容范围更广，并且不集中于语法层面，且难度大得多。例如你在语法之外实现了解释器速度上的优化，那么这些工作就算在“挑战”中。“挑战”的加分很少（仅10分），因此推荐你不优先考虑解释器的效率问题。</p><p><strong>如果你尝试着完成了这些挑战的一部分，可以将你通过Scheme实现解释器的心路历程、实现了哪些语法、又实现了哪些自创语法、示例代码和运行结果写在文档里，并给出解释器的源代码。<strong>再次强调，这一部分仅仅是一个“挑战”，即使你给出了很完善的实现，也只会有</strong>很少的加分</strong>，仅建议你在有余力的情况下考虑挑战这个任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一份简易的lispscheme教程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一份简易的lispscheme教程&quot;&gt;&lt;/a&gt; 一份简易的LISP（Scheme）教程&lt;/h2&gt;
&lt;p&gt;相信不少人对LISP这门编程语言有所耳闻，又常常听</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Pandora" scheme="https://sumsc-caa.github.io/tags/Pandora/"/>
    
  </entry>
  
  <entry>
    <title>2021 魔盒挑战第一期-网页迷宫篇 解题流程与说明</title>
    <link href="https://sumsc-caa.github.io/2021/12/03/pandora-2021-1-maze-solution/"/>
    <id>https://sumsc-caa.github.io/2021/12/03/pandora-2021-1-maze-solution/</id>
    <published>2021-12-03T10:44:25.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="level-00"><a class="markdownIt-Anchor" href="#level-00"></a> Level 00</h2><p>略。</p><h2 id="level-01-hellomazehtml"><a class="markdownIt-Anchor" href="#level-01-hellomazehtml"></a> Level 01 | HelloMaze.html</h2><p>用鼠标选中色块中的文字即可，得到答案<code>eA5JlOGrq0AFEPy6IJT</code>。</p><h2 id="level-010-ea5jlogrq0afepy6ijthtml"><a class="markdownIt-Anchor" href="#level-010-ea5jlogrq0afepy6ijthtml"></a> Level 010 | eA5JlOGrq0AFEPy6IJT.html</h2><p>根据提示打开审查元素，在元素/Inspector一栏用元素选择器选择带边框的div，展开标签看到hiddentext：<code>UDZvYvFch</code>，即为答案。</p><h2 id="level-011-udzvyvfchhtml"><a class="markdownIt-Anchor" href="#level-011-udzvyvfchhtml"></a> Level 011 | UDZvYvFch.html</h2><p>根据提示打开审查元素的控制台，此时点击按钮可以看到控制台输出<code>EiuOOcxCOKzEyXLL</code>，即为答案。</p><h2 id="level-0100-eiuoocxcokzeyxllhtml"><a class="markdownIt-Anchor" href="#level-0100-eiuoocxcokzeyxllhtml"></a> Level 0100 | EiuOOcxCOKzEyXLL.html</h2><h3 id="method-1"><a class="markdownIt-Anchor" href="#method-1"></a> Method 1</h3><p>根据提示打开审查元素的控制台，输入指令<code>answer</code>或<code>console.log(answer)</code>即可看到答案：<code>rMhsaAmoDVeRXBcdoN</code>。</p><h3 id="method-2"><a class="markdownIt-Anchor" href="#method-2"></a> Method 2</h3><p>在审查元素的元素一栏中查找script标签，看到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">var</span> answer=<span class="string">&quot;rMhsaAmoDVeRXBcdoN&quot;</span> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一行，说明answer的值为<code>rMhsaAmoDVeRXBcdoN</code>。</p><h2 id="level-0101-rmhsaamodverxbcdonhtml"><a class="markdownIt-Anchor" href="#level-0101-rmhsaamodverxbcdonhtml"></a> Level 0101 | rMhsaAmoDVeRXBcdoN.html</h2><p>按照题目要求写出程序并运行即可得到答案。两个样例程序如下：</p><h3 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc</span>(<span class="params">st</span>):</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, st))</span><br><span class="line">    avg = <span class="built_in">sum</span>(nums)/<span class="built_in">len</span>(nums)</span><br><span class="line">    var = <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, nums))/<span class="built_in">len</span>(nums)-avg**<span class="number">2</span></span><br><span class="line">    avg, var = math.ceil(avg), math.ceil(var)</span><br><span class="line">    <span class="keyword">return</span> avg, var</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proc2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span>(<span class="number">48</span> &lt;= num &lt;= <span class="number">57</span> <span class="keyword">or</span> <span class="number">65</span> &lt;= num &lt;= <span class="number">90</span> <span class="keyword">or</span> <span class="number">97</span> &lt;= num &lt;= <span class="number">122</span>):</span><br><span class="line">        num = (num+<span class="number">7</span>) % <span class="number">129</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [</span><br><span class="line">    <span class="string">&quot;HelloMaze&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eA5JlOGrq0AFEPy6IJT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UDZvYvFch&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EiuOOcxCOKzEyXLL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rMhsaAmoDVeRXBcdoN&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([proc2(j) <span class="keyword">for</span> i <span class="keyword">in</span> lst <span class="keyword">for</span> j <span class="keyword">in</span> proc(i)]))</span><br></pre></td></tr></table></figure><h3 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processNum</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    n=<span class="title class_">Math</span>.<span class="title function_">ceil</span>(n)</span><br><span class="line">    <span class="keyword">while</span>(n&lt;<span class="number">48</span>|<span class="number">57</span>&lt;n&amp;n&lt;<span class="number">65</span>|<span class="number">90</span>&lt;n&amp;n&lt;<span class="number">97</span>|n&gt;<span class="number">122</span>)&#123;</span><br><span class="line">        n=(n+<span class="number">7</span>)%<span class="number">129</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processStr</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span>,squaredsum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> n=s.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">        sum+=n;</span><br><span class="line">        squaredsum+=n*n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> avg=sum/s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> variance=squaredsum/s.<span class="property">length</span>-avg*avg;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">processNum</span>(avg)+<span class="title function_">processNum</span>(variance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> answer=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lst=[</span><br><span class="line">    <span class="string">&quot;HelloMaze&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eA5JlOGrq0AFEPy6IJT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UDZvYvFch&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EiuOOcxCOKzEyXLL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rMhsaAmoDVeRXBcdoN&quot;</span></span><br><span class="line">];</span><br><span class="line">lst.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    answer+=<span class="title function_">processStr</span>(value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure><h2 id="level-0110-dkpbe3b2d3html"><a class="markdownIt-Anchor" href="#level-0110-dkpbe3b2d3html"></a> Level 0110 | dkPBe3b2d3.html</h2><p>根据提示打开审查元素，找到check的源代码（注释是后加的）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">m,n,o,p</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> ns = [m,n,o,p].<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a); <span class="comment">// 将[m,n,o,p]逆序排序后存入ns内，说明参数的顺序不会对影响结果</span></span><br><span class="line">    <span class="keyword">let</span> nums = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;<span class="number">5</span>; i++)&#123;              <span class="comment">// i从2到4迭代</span></span><br><span class="line">        ns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;            <span class="comment">// 对列表ns迭代</span></span><br><span class="line">            nums.<span class="title function_">push</span>(value*i);          <span class="comment">// 将value*i加到nums末尾</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(...nums); <span class="comment">// 将nums转换为字符串并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后可知check函数负责将四个数字，m、n、o、p，倒序排序后都乘以2、3、4，将结果依次加入数组nums内。随后将nums的各项按照ascii码转换为字符串。</p><p>这里再结合提示“联系上一题”，为了确保整数对应的字符是合规的答案，整数n必须满足如下约束：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mi>n</mi><mo separator="true">,</mo><mn>3</mn><mi>n</mi><mo separator="true">,</mo><mn>4</mn><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi><mo>∩</mo><mo stretchy="false">{</mo><mo stretchy="false">[</mo><mn>48</mn><mo separator="true">,</mo><mn>57</mn><mo stretchy="false">]</mo><mo>∪</mo><mo stretchy="false">[</mo><mn>65</mn><mo separator="true">,</mo><mn>90</mn><mo stretchy="false">]</mo><mo>∪</mo><mo stretchy="false">[</mo><mn>97</mn><mo separator="true">,</mo><mn>122</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">2n,3n,4n\in \mathbb Z\cap\{[48,57]\cup[65,90]\cup[97,122]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mopen">[</span><span class="mord">4</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span></span></p><p>即</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>24.25</mn><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><mn>24</mn><mo separator="true">,</mo><mfrac><mn>65</mn><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mn>97</mn><mn>4</mn></mfrac><mo stretchy="false">}</mo><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">{</mo><mfrac><mn>57</mn><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mn>90</mn><mn>3</mn></mfrac><mo separator="true">,</mo><mfrac><mn>122</mn><mn>4</mn></mfrac><mo stretchy="false">}</mo><mo>=</mo><mn>28.5</mn></mrow><annotation encoding="application/x-tex">24.25=\max\{24,\frac{65}{3},\frac{97}{4}\}\leq n \leq \min\{\frac{57}{2},\frac{90}{3},\frac{122}{4}\}=28.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord">2</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">2</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mord">.</span><span class="mord">5</span></span></span></span></span></p><p>又因为题目中规定了check的输入都是整数，所以满足条件的只有25,26,27,28四个数，共有35种情况。可以写程序穷举也可以手工穷举，不过在穷举之前应该能想到把四个数都填进去试试看，正好就能得到答案<code>8642TQNKplhd</code>。</p><p>穷举程序（python）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> r   <span class="comment"># python中著名的网络请求库，需通过pip安装</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">*args</span>):   <span class="comment"># 页面中的check函数的复刻</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(i*j) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(args, reverse=<span class="literal">True</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>]</span><br><span class="line"></span><br><span class="line">conditions = (</span><br><span class="line">    (nums[i], nums[j], nums[k], nums[l])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="number">4</span>)</span><br><span class="line">)  <span class="comment"># 列举所有情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cond <span class="keyword">in</span> conditions:</span><br><span class="line">    answer = check(*cond)</span><br><span class="line">    url = <span class="string">f&quot;http://10.10.65.208:8080/maze/<span class="subst">&#123;answer&#125;</span>.html&quot;</span></span><br><span class="line">    response = r.get(url, timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:  <span class="comment"># 页面存在时状态码为200</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;cond&#125;</span> =&gt; <span class="subst">&#123;url&#125;</span> exist.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n======================&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;The answer: <span class="subst">&#123;answer&#125;</span>\nLink to next level: <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;======================\n&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> response.status_code == <span class="number">404</span>:  <span class="comment"># 页面不存在时状态码为404</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;cond&#125;</span> =&gt; <span class="subst">&#123;url&#125;</span> not exist.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:           <span class="comment"># 如果状态码不是上述二者说明服务器出问题或者访问过于频繁，抛出异常</span></span><br><span class="line">        <span class="keyword">raise</span> BaseException(</span><br><span class="line">            <span class="string">f&quot;unknown status code: <span class="subst">&#123;response.status_code&#125;</span> while accessing <span class="subst">&#123;url&#125;</span>.&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)  <span class="comment"># 控制访问间隔，防止对服务器造成压力</span></span><br></pre></td></tr></table></figure><h2 id="level-0111-8642tqnkplhdhtml"><a class="markdownIt-Anchor" href="#level-0111-8642tqnkplhdhtml"></a> Level 0111 | 8642TQNKplhd.html</h2><p>题目中的色块共有6行8列，且只有8种颜色，结合提示猜测通关的信息可能被编码成颜色，因此先按顺序提取出色块中的所有颜色，发现颜色的rgb值中各分量只有<code>00</code>与<code>ff</code>两种值，若是将<code>00</code>记为0，将<code>ff</code>记为1，即可得到一个仅由0与1组成的二进制串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">011100100101001000110000010100100100100101010110010110100011000101010100001110010011010101100100001101000111010001111000011100000110100101100101</span><br></pre></td></tr></table></figure><p>因为<code>1 byte=8 bits</code>，所以将上述二进制串每八位分为一组，再将每组转化为十进制，得到一个长度为18的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">114</span>, <span class="number">82</span>, <span class="number">48</span>, <span class="number">82</span>, <span class="number">73</span>, <span class="number">86</span>, <span class="number">90</span>, <span class="number">49</span>, <span class="number">84</span>, <span class="number">57</span>, <span class="number">53</span>, <span class="number">100</span>, <span class="number">52</span>, <span class="number">116</span>, <span class="number">120</span>, <span class="number">112</span>, <span class="number">105</span>, <span class="number">101</span>]</span><br></pre></td></tr></table></figure><p>注意到数组内每个数都在128以内，猜测这可能是ascii码值，于是将数组转化为字符串，得到<code>rR0RIVZ1T95d4txpie</code>，即本题的答案。</p><p>完整代码（javascript）如下（在审查元素的控制台中运行）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 用正则表达式按顺序获取table中的所有颜色</span></span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;colormatrix&quot;</span>)[<span class="number">0</span>].<span class="property">innerHTML</span>;</span><br><span class="line">    <span class="keyword">let</span> colors = [...text.<span class="title function_">matchAll</span>(<span class="regexp">/#([0-9a-f]&#123;2&#125;)([0-9a-f]&#123;2&#125;)([0-9a-f]&#123;2&#125;)/g</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为比特</span></span><br><span class="line">    <span class="keyword">let</span> bits = [];</span><br><span class="line">    colors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        bits.<span class="title function_">push</span>(value[<span class="number">1</span>] === <span class="string">&quot;00&quot;</span> ? <span class="number">0</span> : <span class="number">1</span>, value[<span class="number">2</span>] === <span class="string">&quot;00&quot;</span> ? <span class="number">0</span> : <span class="number">1</span>, value[<span class="number">3</span>] === <span class="string">&quot;00&quot;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为字符串</span></span><br><span class="line">    <span class="keyword">let</span> nums = [];</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; bits.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++, n++) &#123;</span><br><span class="line">            num = num * <span class="number">2</span> + bits[n]</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="title function_">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> answer = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(...nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="level-01000-rr0rivz1t95d4txpiehtml"><a class="markdownIt-Anchor" href="#level-01000-rr0rivz1t95d4txpiehtml"></a> Level 01000 | rR0RIVZ1T95d4txpie.html</h2><p>提示中已经给出这一题是上一题的强化版，因此我们仿照上一题，先提取出表中的所有颜色代码。</p><h3 id="从页面获得二进制串"><a class="markdownIt-Anchor" href="#从页面获得二进制串"></a> 从页面获得二进制串</h3><p>但需要注意的是，上一题所用的使用正则表达式<code>#[0-9a-fA-F]&#123;6&#125;</code>提取颜色代码的方式在这里并不适用，因为表中存在有以下三种形式的单元格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;background:#102024&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;background:#040&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中第一种我们在上一题遇到过了，第二种里<code>#040</code>是<code>#004400</code>的简写形式，而第三种，结合.colormatrix上方的样式表：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.colormatrix</span> <span class="selector-tag">td</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知是黑色，即<code>#000000</code>。</p><p>因此我们在提取颜色的时候需要兼顾此三种，提取颜色后我们要将其转换为二进制串，完整代码如下（在审查元素的控制台中运行）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getbits</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> blocks=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;td&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> bits=[];</span><br><span class="line">    <span class="keyword">const</span> black=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> digits=[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;blocks.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> color;</span><br><span class="line">        <span class="keyword">if</span>(blocks[i].<span class="property">style</span>.<span class="property">background</span>===<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            color=black;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> c=blocks[i].<span class="property">style</span>.<span class="property">backgroundColor</span>.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>);</span><br><span class="line">            color=c.<span class="title function_">map</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="keyword">return</span> <span class="title class_">Number</span>.<span class="built_in">parseInt</span>(value)&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        color.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            bits.<span class="title function_">push</span>(...digits.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (value&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bits=<span class="title function_">getbits</span>();</span><br></pre></td></tr></table></figure><h3 id="从bmp文件获得二进制串"><a class="markdownIt-Anchor" href="#从bmp文件获得二进制串"></a> 从bmp文件获得二进制串</h3><p>在colormatrix的下方有一条注释：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  http://localhost:4580/PtdqW.bmp  --&gt;</span></span><br></pre></td></tr></table></figure><p>这个url（实际线上版本与此不同）指向一张bmp图片，其内容与上方表格相同，因此我们也可以从这里提取颜色。</p><p>下载图片后我们用python的Pillow库与numpy库（需要用pip安装）来处理图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Image.<span class="built_in">open</span>(<span class="string">&quot;./PtdqW.bmp&quot;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> im:</span><br><span class="line">    ar = np.array(im)</span><br><span class="line"></span><br><span class="line">ar = ar.reshape((<span class="number">20</span>*<span class="number">89</span>*<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">bits = np.hstack([(ar &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>)])</span><br></pre></td></tr></table></figure><h3 id="将二进制串转化为图片"><a class="markdownIt-Anchor" href="#将二进制串转化为图片"></a> 将二进制串转化为图片</h3><p>经过上述两个操作的任一个我们都能得到一个含有42720个比特的数组。再结合第二条提示<code>267x160</code>，发现<code>267*160=42720</code>，因此我们只需将数组填入宽160高267的矩阵中即可。</p><p>python的完整程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Image.<span class="built_in">open</span>(<span class="string">&quot;./PtdqW.bmp&quot;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> im:</span><br><span class="line">    ar = np.array(im)</span><br><span class="line"></span><br><span class="line">ar = ar.reshape((<span class="number">20</span>*<span class="number">89</span>*<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">bits = np.hstack([(ar &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>)])</span><br><span class="line">bits = bits.reshape((<span class="number">267</span>, <span class="number">160</span>))</span><br><span class="line"></span><br><span class="line">plt.imshow(bits)</span><br><span class="line">plt.savefig(<span class="string">&quot;./output.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出的图片如下：</p><p><img src="/images/pandora/output.jpg" alt="output" /></p><p>在js中的处理如下（接上个程序，在审查元素的控制台中运行）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showimg</span>(<span class="params">bits</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> el=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">    el.<span class="property">className</span>=<span class="string">&quot;colormatrix2&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;bits.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> tr=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> t=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">160</span>;i++,k++)&#123;</span><br><span class="line">            t+=bits[k]?<span class="string">&quot;&lt;td&gt;&lt;/td&gt;&quot;</span>:<span class="string">`&lt;td class=&quot;white&quot;&gt;&lt;/td&gt;`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tr.<span class="property">innerHTML</span>=t;</span><br><span class="line">        el.<span class="title function_">appendChild</span>(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> style=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>)</span><br><span class="line">    style.<span class="property">innerHTML</span>=<span class="string">`</span></span><br><span class="line"><span class="string">    .colormatrix2 td&#123;</span></span><br><span class="line"><span class="string">        width: .1em;</span></span><br><span class="line"><span class="string">        height: .1em;</span></span><br><span class="line"><span class="string">        background-color: black;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    .colormatrix2 td.white&#123;</span></span><br><span class="line"><span class="string">        background-color: white;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    <span class="keyword">const</span> parent=<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;flexbox&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    parent.<span class="title function_">appendChild</span>(style);</span><br><span class="line">    parent.<span class="title function_">appendChild</span>(el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showimg</span>(bits);</span><br></pre></td></tr></table></figure><p>可以在页面中看到如下图像：</p><p><img src="/images/pandora/showimg.png" alt="showimg" /></p><p>亦可将上面的python程序的后两行改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> bits:</span><br><span class="line">        <span class="built_in">print</span>(*(<span class="string">&quot;*&quot;</span> <span class="keyword">if</span> i <span class="keyword">else</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> r),sep=<span class="string">&quot;&quot;</span>,file=f)</span><br></pre></td></tr></table></figure><p>运行程序后，打开<code>a.txt</code>，在合适的字体、字号与行距下可以看到由字符组成的图片。</p><p>通过图片我们可以看出这张图中的是埃菲尔铁塔，其英文名是<code>The Eiffel Tower</code>或<code>Eiffel Tower</code>，又因为题目要求“答案为由<strong>驼峰命名法</strong>（<strong>首字母小写</strong>）结合而成的<strong>三个单词</strong>”，所以答案是<code>theEiffelTower</code>。</p><p>注：图片来源：<a href="https://commons.wikimedia.org/wiki/File:Eiffel_Tower_1945.jpg">https://commons.wikimedia.org/wiki/File:Eiffel_Tower_1945.jpg</a> 原图属于公有领域，在引用时做了亿点点处理以压缩体积。</p><h2 id="level-01001-theeiffeltowerhtml"><a class="markdownIt-Anchor" href="#level-01001-theeiffeltowerhtml"></a> Level 01001 | theEiffelTower.html</h2><h3 id="base64解码"><a class="markdownIt-Anchor" href="#base64解码"></a> Base64解码</h3><p>首先观察题目给的数据，根据提示得知这是使用base64编码的二进制数据，因此首先使用base64对其解码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line">data = b64decode(<span class="string">&quot;ASJcDiBgWReEMk5KyjCGSOi0OQNT&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><p>得到一串二进制数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;\x01&quot;\\\x0e `Y\x17\x842NJ\xca0\x86H\xe8\xb49\x03S&#x27;</span><br></pre></td></tr></table></figure><h3 id="校验"><a class="markdownIt-Anchor" href="#校验"></a> 校验</h3><p>根据提示，接下来要用汉明码进行校验，因此先将其转化为仅含0与1的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bits = [i <span class="keyword">for</span> n <span class="keyword">in</span> data <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>(</span><br><span class="line">    <span class="keyword">lambda</span> power:(n &gt;&gt; power) &amp; <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>))]</span><br><span class="line"><span class="built_in">print</span>(*bits,sep=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000010010001001011100000011100010000001100000010110010001011110000100001100100100111001001010110010100011000010000110010010001110100010110100001110010000001101010011</span><br></pre></td></tr></table></figure><p>然后校验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="built_in">pow</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; <span class="built_in">pow</span>)-<span class="number">1</span> &lt; <span class="built_in">len</span>(bits):</span><br><span class="line">    <span class="built_in">pow</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">parities = [<span class="number">0</span>]*<span class="built_in">pow</span></span><br><span class="line"><span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">pow</span>):</span><br><span class="line">    parities[-digit-<span class="number">1</span>] = reduce(<span class="keyword">lambda</span> x, y: x ^ y,</span><br><span class="line">                    (v <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) <span class="keyword">if</span> (i+<span class="number">1</span> &gt;&gt; digit) &amp; <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(parities)</span><br></pre></td></tr></table></figure><p>输出：<code>[0, 0, 0, 1, 1, 0, 0, 0]</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>00011000</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">(00011000)_2=24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span>，说明<strong>从1开始数</strong>的第24位发生了翻转（当然也可能有多位发生了翻转，不过那样题目就做不下去了，故不在考虑范围内），因此对数组的第23位进行修正：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits[<span class="number">23</span>]=<span class="number">0</span> <span class="keyword">if</span> bits[<span class="number">23</span>] <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后剔除数据中的校验位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkedbits = [v <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(bits) <span class="keyword">if</span> i &amp; (i+<span class="number">1</span>)]</span><br><span class="line"><span class="built_in">print</span>(*checkedbits,sep=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000001000101011101000011100100000011000000101100100010111000010000110010010011100100101011001010001100001000011001001001110100010110100001110010000001101010011</span><br></pre></td></tr></table></figure><h3 id="解码"><a class="markdownIt-Anchor" href="#解码"></a> 解码</h3><p>根据提示的第三条<strong>Zeckendorf定理</strong>我们可以在搜索引擎中找到其在编码领域的应用，即<strong>斐波那契编码</strong>。斐波那契编码仅有0与1组成，其中每一位的位值都对应一个斐波那契数，将斐波那契编码中为1的位对应的位值求和即可得到编码表示的十进制数，例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1010101</mn><msub><mo stretchy="false">)</mo><mrow><mi>f</mi><mi>i</mi><mi>b</mi></mrow></msub><mo>=</mo><mn>21</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>33</mn></mrow><annotation encoding="application/x-tex">(1010101)_{fib}=21+8+3+1=33</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">3</span></span></span></span>。Zeckendorf定理能确保在合适的条件下，一个数在斐波那契编码中不会出现两个连续的1。若是在每个数的末尾补充一个1，这个1与下一个数首位的1连在一起形成“11”，我们可以据此区分编码串中相邻的两个数：</p><ul><li>若出现连续的两个1，则上一个数以0结尾，以第一个1作为分隔符；</li><li>若出现连续的三个1，则上一个数以1结尾，以第二个1作为分隔符。</li></ul><p>上面的二进制串可以依此法分为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000100010101 10100001 1001000000 100000010 1001000101 1000010000 1001001001 1001001010 100101000 1000010000 1001001001 10100010 10100001 1001000000 10101001</span><br></pre></td></tr></table></figure><p>然后将斐波那契编码转换为十进制，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67 48 110 57 114 97 116 117 73 97 116 49 48 110 53</span><br></pre></td></tr></table></figure><p>最后按ascii码表转换为字符，得到答案：<code>C0n9ratuIat10n5</code></p><p>解码的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列</span></span><br><span class="line">fib = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">while</span> fib[-<span class="number">1</span>] &lt;= <span class="number">1024</span>:</span><br><span class="line">    fib.append(fib[-<span class="number">2</span>]+fib[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">checkedbits.pop()  <span class="comment"># 忽略最后一个数末尾添的1</span></span><br><span class="line">nums = []</span><br><span class="line">n, lastbit, p = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(checkedbits):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">and</span> lastbit:</span><br><span class="line">        nums.append(n)</span><br><span class="line">        n, lastbit, p = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            n += fib[p]</span><br><span class="line">        lastbit = i</span><br><span class="line">        p += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n:</span><br><span class="line">    nums.append(n)</span><br><span class="line"></span><br><span class="line">answer = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, <span class="built_in">reversed</span>(nums)))</span><br><span class="line"><span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure><h2 id="bonus的获取方法"><a class="markdownIt-Anchor" href="#bonus的获取方法"></a> Bonus的获取方法</h2><h3 id="bonus-0-iwndvqjy"><a class="markdownIt-Anchor" href="#bonus-0-iwndvqjy"></a> Bonus 0: iWNDvqJY</h3><p>在Level 0打开审查元素，发现在文字的第二、三段之间隐藏了一个元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span>Bonus0: iWNDvqJY<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="bonus-1-8864ttqnpplh"><a class="markdownIt-Anchor" href="#bonus-1-8864ttqnpplh"></a> Bonus 1: 8864TTQNpplh</h3><p>在Level 6中穷举时可以得到两个存在的页面，其中<code>8642TQNKplhd</code>指向Level 7，另一个<code>8864TTQNpplh</code>即为Bonus 1。</p><h3 id="bonus-2-latoureiffel"><a class="markdownIt-Anchor" href="#bonus-2-latoureiffel"></a> Bonus 2: laTourEiffel</h3><p>在Level 8得到答案前的最后一步，法文单词怎么能不算单词呢（逃）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;level-00&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#level-00&quot;&gt;&lt;/a&gt; Level 00&lt;/h2&gt;
&lt;p&gt;略。&lt;/p&gt;
&lt;h2 id=&quot;level-01-hellomazehtml&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Pandora" scheme="https://sumsc-caa.github.io/tags/Pandora/"/>
    
    <category term="前端" scheme="https://sumsc-caa.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2021 魔盒挑战 第一期</title>
    <link href="https://sumsc-caa.github.io/2021/11/25/Pandora-2021-1/"/>
    <id>https://sumsc-caa.github.io/2021/11/25/Pandora-2021-1/</id>
    <published>2021-11-25T00:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="welcome"><a class="markdownIt-Anchor" href="#welcome"></a> Welcome!</h2><p>欢迎来到 2021 年魔盒挑战第一期！</p><h3 id="什么是魔盒挑战"><a class="markdownIt-Anchor" href="#什么是魔盒挑战"></a> ❓ 什么是魔盒挑战</h3><p>又到了技术组招新的时候了。</p><p>我们决定发布一项 <strong>魔盒挑战</strong> 来挑选与我们同行的勇士们！</p><p>各位挑战者将收到一个装有通往技术组“钥匙”的 <strong>神秘盒子</strong>，挑战者需要运用自己的<s>渊博</s>知识 <strong>打开魔盒</strong>，完成的挑战者将会获得前往技术组的邀请函。</p><h3 id="如何参与"><a class="markdownIt-Anchor" href="#如何参与"></a> 🔍 如何参与</h3><p>本期魔盒挑战的<strong>时间</strong>为：2021年11月25日 12:00 —— 2021年12月2日 23:59，为期<strong>一周</strong>。</p><p>请各位参与本次魔盒挑战的同学在QQ群（497516494）中参与群投票，以便我们能更好地了解各位的题目选择情况。</p><p>你一共有<strong>七天</strong>时间来完成这个挑战，无论你是提前完成了挑战，还是时限内未能到达终点，最后都请将你得到的所有答案按照下列要求发送<strong>邮件</strong>至<a href="mailto:sumstc@outlook.com">sumstc@outlook.com</a>。邮件请以 <code>Pandora-2021-1-[参与题目] [姓名] [学号]</code> 命名，请根据各题目要求上传附件。</p><h3 id="本期主题"><a class="markdownIt-Anchor" href="#本期主题"></a> 🔔 本期主题</h3><p>本期的主题是【Web前端技术】，共有三个题目可供你选择（数量不限）。</p><p>各题目传送门：【各题目链接需要在 SUDA_WIFI 环境下访问】</p><ul><li>网页迷宫篇：<a href="http://10.10.65.208:8080/maze/">10.10.65.208:8080/maze</a></li><li>Web备忘录篇：<a href="http://10.10.65.208:8080/memo/">10.10.65.208:8080/memo</a></li><li>论CSS的妙用：<a href="http://10.10.65.208:8080/css/">10.10.65.208:8080/css</a></li></ul><h3 id="考察点"><a class="markdownIt-Anchor" href="#考察点"></a> 🔑 考察点</h3><ul><li>HTML 超文本标记语言</li><li>CSS 层叠样式表</li><li>JavaScript 解释型语言</li></ul><h3 id="奖品设置"><a class="markdownIt-Anchor" href="#奖品设置"></a> 🎁 奖品设置</h3><p>前 5 名完整解决的同学会有神秘礼品！</p><blockquote><p>奖品由微软亚洲研究院赞助。</p></blockquote><h3 id="参赛协议"><a class="markdownIt-Anchor" href="#参赛协议"></a> 📄 参赛协议</h3><ul><li>参赛者<strong>自愿</strong>参加本次活动；</li><li>参赛获奖者请在获悉中奖信息后尽快联系活动主办方或直接前往俱乐部实验室（理工楼110）领取奖品；</li><li>参赛者参与本次活动，默认同意本协议的所有内容。</li></ul><h4 id="参赛守则"><a class="markdownIt-Anchor" href="#参赛守则"></a> 参赛守则</h4><p>参赛者应承诺：</p><ol><li>不对比赛设施（包括但不限于网站、服务器、数据库）进行任何非法操作；</li><li>在活动中使用本人真实信息；</li><li>独立参赛，不得给予、借鉴、抄袭其他参赛者的成果；不得出于任何目的采用任何手段攻击比赛设施、其他参与者的设备。</li></ol><p>参赛者如有上述违规行为，苏州大学计算机爱好者协会（微软学生俱乐部）有权取消您的参赛成绩和资格。</p><h4 id="用户隐私"><a class="markdownIt-Anchor" href="#用户隐私"></a> 用户隐私</h4><blockquote><p>本次活动可能会涉及到您的学号。</p></blockquote><ul><li>我们承诺不会收集任何用户隐私信息，您的学号仅用于验证本人的真实信息；</li><li>我们承诺活动结束后删除所有用户隐私数据。</li></ul><p>活动最终解释权归苏州大学计算机爱好者协会（微软学生俱乐部）所有。</p><hr /><p>2021 苏州大学计算机爱好者协会（微软学生俱乐部）版权所有</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;welcome&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#welcome&quot;&gt;&lt;/a&gt; Welcome!&lt;/h2&gt;
&lt;p&gt;欢迎来到 2021 年魔盒挑战第一期！&lt;/p&gt;
&lt;h3 id=&quot;什么是魔盒挑战&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Pandora" scheme="https://sumsc-caa.github.io/tags/Pandora/"/>
    
    <category term="前端" scheme="https://sumsc-caa.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2021 Hackathon：Pygame and Turtle</title>
    <link href="https://sumsc-caa.github.io/2021/11/05/hackathon2021/"/>
    <id>https://sumsc-caa.github.io/2021/11/05/hackathon2021/</id>
    <published>2021-11-05T22:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="苏州大学计算机爱好者协会-hackathon-2021-赛题"><a class="markdownIt-Anchor" href="#苏州大学计算机爱好者协会-hackathon-2021-赛题"></a> 苏州大学计算机爱好者协会 Hackathon 2021 赛题</h1><p>以下两题<strong>任选一题完成</strong>即可。</p><h2 id="q1"><a class="markdownIt-Anchor" href="#q1"></a> Q1：</h2><p>贪吃蛇、俄罗斯方块、吃豆人、太空侵略者、打砖块……这些都是在街机游戏的黄金年代涌现出的风靡西方世界的小游戏[ref:1]，它们规则简单但是乐趣无穷，成为了一代西方人的童年回忆。现如今，随着计算机性能的飞速发展和智能手机的普及，电子游戏日新月异，这些小游戏也早已成为历史。</p><p>现在请你们运用自己的编程知识，让这些小游戏重获新生。有以下四个方向供你们选择：</p><ol><li>实现一个命令行小游戏。demo：<a href="/2021/11/05/hackathon2021-q1-snake/">贪吃蛇demo</a></li><li>用pygame库实现一个小游戏。demo：<a href="/2021/11/05/hackathon2021-q2-tetris/">俄罗斯方块demo</a></li><li>以我们在(1)或(2)中提供的demo为基础，在此之上试着增加游戏规则，从而让它更富有游戏性和挑战性。<ul><li>例如：增加障碍物，随着得分的增长增加蛇的速度</li></ul></li><li>以(1)或(2)为基础（我们提供的demo也可以），为小游戏中的玩家角色添加AI。</li></ol><h3 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h3><p>实现的小游戏不必局限于街机游戏和上世纪七八十年代，你能想到的玩法简单的小游戏，例如井字棋、五子棋、flappy bird或者文字冒险游戏都可以作为目标。</p><h4 id="关于pygame库的安装"><a class="markdownIt-Anchor" href="#关于pygame库的安装"></a> 关于pygame库的安装</h4><p><strong>Windows</strong></p><p>按Win+R，在弹出的窗口中输入<code>cmd</code>，按确定，在命令提示符中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pygame</span><br></pre></td></tr></table></figure><p>然后回车执行。</p><p>若提示<code>'pip' 不是内部或外部命令，也不是可运行的程序</code>，请检查是否安装python和pip，并已经将python所在路径加入环境变量Path。</p><h2 id="q2"><a class="markdownIt-Anchor" href="#q2"></a> Q2：</h2><p>在信息技术与社交网络的不断发展中，人们之间的交流方式也从单纯的文字变得越来越丰富多彩，逐步演变为多元的表情文化。后来随着P图、截图技术平民化，越来越多的人开始使用一些自制的图片来进行沟通。这类图片构图夸张，内容丰富，以搞笑居多，或迎合网络文化，或表达共鸣情感。我们通过收藏和分享此类图片，让沟通变得更丰富有趣。[ref:2]</p><p>请在python中使用小海龟（turtle库）绘制一幅或几幅你喜欢的表情或图片。</p><p>demo：（请右键另存为）</p><ul><li>滑稽：<a href="/assets/2021hackathon/draw/huaji.py">huaji.py</a></li><li>捂脸：<a href="/assets/2021hackathon/draw/wulian.py">wulian.py</a></li></ul><h3 id="提示-2"><a class="markdownIt-Anchor" href="#提示-2"></a> 提示</h3><p>请确保你绘制的图片适合在公共场合公开展示。</p><h2 id="可能有用的网址"><a class="markdownIt-Anchor" href="#可能有用的网址"></a> 可能有用的网址</h2><ul><li>python 3.10.0 官方文档：<a href="https://docs.python.org/zh-cn/3/">https://docs.python.org/zh-cn/3/</a></li><li>python官方教程：<a href="https://docs.python.org/zh-cn/3/">https://docs.python.org/zh-cn/3/tutorial/index.html</a></li><li>turtle库参考文档：<a href="https://docs.python.org/zh-cn/3/">https://docs.python.org/zh-cn/3/library/turtle.html</a></li><li>pygame官方文档（英文）：<a href="https://docs.python.org/zh-cn/3/">https://www.pygame.org/docs/</a></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ol><li><a href="https://en.wikipedia.org/wiki/Arcade_game">Arcade game - Wikipedia</a></li><li><a href="https://zh.moegirl.org.cn/%E8%A1%A8%E6%83%85%E5%8C%85">表情包 - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;苏州大学计算机爱好者协会-hackathon-2021-赛题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#苏州大学计算机爱好者协会-hackathon-2021-赛题&quot;&gt;&lt;/a&gt; 苏州大学计算机爱好者协会 Hackathon 2021</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>2021 Hackathon | Tetris</title>
    <link href="https://sumsc-caa.github.io/2021/11/05/hackathon2021-q2-tetris/"/>
    <id>https://sumsc-caa.github.io/2021/11/05/hackathon2021-q2-tetris/</id>
    <published>2021-11-05T21:57:23.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tetris002-简介"><a class="markdownIt-Anchor" href="#tetris002-简介"></a> Tetris0.0.2 简介</h1><p><a href="/2021/11/05/hackathon2021/">返回比赛题目</a></p><p>demo作者：苏州大学计算机爱好者协会（微软学生俱乐部）- 技术组 - 邓宏灿</p><hr /><p>这是一个使用 pygame 制作的一个俄罗斯方块游戏(Tetris)</p><p>主要运用了面向结构的编程思想</p><p>游戏结束时会显示结束语和当前分数</p><h2 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h2><h3 id="基本按键"><a class="markdownIt-Anchor" href="#基本按键"></a> 基本按键</h3><ul><li>A ,D 左右移动方块</li><li>S 加快方块下落</li><li>J 旋转方块</li></ul><h3 id="速度调节"><a class="markdownIt-Anchor" href="#速度调节"></a> 速度调节</h3><p>修改代码开头的SPEED变量，注意数字越小速度越快。</p><h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2><p><a href="/assets/2021hackathon/tetris/tetris.py">tetris.py</a>  （请右键另存为）</p><h2 id="有待改进之处"><a class="markdownIt-Anchor" href="#有待改进之处"></a> 有待改进之处</h2><ul><li>没有对旋转行为进行判定，在方块密集的地方旋转会出现问题</li><li>长按时作出多次响应</li><li>为方块添加颜色</li><li>在游戏界面内显示分数</li><li>在游戏界面内显示之后方块的顺序</li><li>提供切换方块的功能</li><li>随着时间逐渐增加游戏速度</li><li>……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tetris002-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tetris002-简介&quot;&gt;&lt;/a&gt; Tetris0.0.2 简介&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2021/11/05/hackathon2021/&quot;&gt;返回比</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>2021 Hackathon | 贪吃蛇</title>
    <link href="https://sumsc-caa.github.io/2021/11/05/hackathon2021-q1-snake/"/>
    <id>https://sumsc-caa.github.io/2021/11/05/hackathon2021-q1-snake/</id>
    <published>2021-11-05T21:57:14.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪吃蛇demo-说明"><a class="markdownIt-Anchor" href="#贪吃蛇demo-说明"></a> 贪吃蛇demo 说明</h1><p><a href="/2021/11/05/hackathon2021/">返回比赛题目</a></p><p>demo作者：苏州大学计算机爱好者协会（微软学生俱乐部）- 技术组 - 王嘉睿</p><hr /><p>用python制作的在命令行中运行的贪吃蛇小游戏。</p><p>在cmd/powershell或linux/MacOS的终端（建议将终端的字体设为等宽字体）中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; python snake.py</span><br></pre></td></tr></table></figure><p>随后程序会立即开始运行。</p><h2 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h2><p><code>w</code>：向上运动</p><p><code>a</code>：向左运动</p><p><code>s</code>：向下运动</p><p><code>d</code>：向右运动</p><h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2><p><a href="/assets/2021hackathon/snake/snake.py">snake.py</a>  （请右键另存为）</p><h2 id="有待改进之处"><a class="markdownIt-Anchor" href="#有待改进之处"></a> 有待改进之处</h2><ul><li>随着分数增加游戏速度</li><li>增加障碍物</li><li>为蛇和食物添加不同颜色（见 <a href="https://pypi.org/project/colorama/">https://pypi.org/project/colorama/</a> ）</li><li>从命令行参数获取游戏地图的设置。例如运行<code>python snake.py 30 20 -f 2</code>得到的游戏地图的长宽分别为30，20，其中有2个食物（见 <a href="https://pypi.org/project/colorama/">https://docs.python.org/zh-cn/3/library/argparse.html</a> ）</li><li>……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪吃蛇demo-说明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#贪吃蛇demo-说明&quot;&gt;&lt;/a&gt; 贪吃蛇demo 说明&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2021/11/05/hackathon2021/&quot;&gt;返回比赛题目&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
    <category term="Hackathon" scheme="https://sumsc-caa.github.io/tags/Hackathon/"/>
    
  </entry>
  
  <entry>
    <title>Python 指南 (1)</title>
    <link href="https://sumsc-caa.github.io/2021/10/02/python2021-1/"/>
    <id>https://sumsc-caa.github.io/2021/10/02/python2021-1/</id>
    <published>2021-10-02T07:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐大家6本python入门书籍"><a class="markdownIt-Anchor" href="#推荐大家6本python入门书籍"></a> 推荐大家6本Python入门书籍</h2><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>我在逛各大媒体的时候，发现大家都有一个问题，就是不知道入门看什么书籍好，总是在问答上要大家推荐书籍，这些人推荐的质量都是参差不齐，</p><p>本节为大家推荐6本高效率的书籍（总有一本适合你），非常适合初学者，我们一边看书籍一边结合视频来看， 你的进步会神速。</p><h3 id="1python编程快速上手"><a class="markdownIt-Anchor" href="#1python编程快速上手"></a> 1.Python编程快速上手</h3><p><img src="/images/python2021-1.assets/1.png" alt="img" /></p><p>现在，人们面临的大部分任务都可以通过编写计算机软件来完成。Python是一种解释性、面向对象、动态数据类型的高级编程语言。通过python编程，我们可以解决现实生活中的许多任务。</p><p>本书是一本实用的Python编程实践指南。本书的目的不仅是介绍Python语言的基本知识，而且通过项目实践来教读者如何应用这些知识和技能。本书的第一部分介绍了基本的Python编程概念。第二部分介绍了一些不同的任务。通过编写python程序，计算机可以自动完成它们。第二部分的每一章都有一些项目程序供读者学习。在每章的最后，提供一些练习和深入的实践项目，以帮助读者巩固他们的知识。附录提供了所有练习的答案。</p><p>本书适用于任何想通过Python学习编程的人，尤其是那些缺乏编程基础的初学者。</p><h3 id="2笨办法学python"><a class="markdownIt-Anchor" href="#2笨办法学python"></a> 2.笨办法学Python</h3><p><img src="/images/python2021-1.assets/2.png" alt="img" /></p><p>这本书是一本python入门书。它适用于对计算机知之甚少、未学过编程，但对编程感兴趣的读者。本书以练习的方式指导读者逐步学习编程，从简单的打印到整个项目的实现，使初学者能够从基本的编程技术入手，最终体验到软件开发的基本过程。</p><p>这本书的结构很简单。它包括52个练习，其中26个涉及三个主题：输入/输出、变量和函数。其他26个主题涉及更高级的主题，例如条件判断、循环、类和对象、代码测试和项目实现。每章的格式基本相同。从代码练习开始，按照说明编写代码，运行并检查结果，然后再做其他练习。</p><h3 id="3python编程初学者指南"><a class="markdownIt-Anchor" href="#3python编程初学者指南"></a> 3.python编程初学者指南</h3><p><img src="/images/python2021-1.assets/3.png" alt="在这里插入图片描述" /></p><p>Python是一种解释性、面向对象、动态数据类型的高级编程语言。从科学计算到游戏开发，python可以用于许多领域。</p><p>小编推荐一个学python的学习qun 740,3222,34<br />无论你是大牛还是小白，是想转行还是想入行都可以来了解一起进步一起学习！裙内有开发工具，很多干货和技术资料分享！</p><p>《Python编程入门指南》试图帮助初学者轻松有趣地掌握Python语言和编程技能。</p><p>《Python编程入门指南》共有12章，每章将用一个完整的游戏来演示关键知识点，并通过编写有趣的小软件来学习编程，激发读者的兴趣，降低学习难度。在每一章的结尾，将对本章的知识点进行总结，并给出一些练习，供读者试一试。作者巧妙地将所有的编程知识嵌入到这些例子中，真正达到了教学和欣赏的目的。”《python programming初学者指南》是一本易懂、简单生动的示例，是国际上最畅销的python初学者指南，适合对python学习感兴趣的初级和中级读者参考。</p><h3 id="4python3程序开发指南第二版"><a class="markdownIt-Anchor" href="#4python3程序开发指南第二版"></a> 4.Python3程序开发指南（第二版）</h3><p><img src="/images/python2021-1.assets/4.png" alt="img" /></p><p>《python 3程序开发指南》描述了python语言的八个关键元素，分别在不同的章节中阐述，包括数据类型、控制结构和功能、模块、文件处理、调试、进程和线程、网络、数据库、正则表达式、GUI编程等。这本书的主要内容是举例说明。练习题附在每一章的后面，可以帮助读者更好地理解和掌握内容。它非常适合使用Python语言教科书，对Python程序员有一定的参考价值。</p><h3 id="5pythoncookbook"><a class="markdownIt-Anchor" href="#5pythoncookbook"></a> 5.pythonCookBook</h3><p><img src="/images/python2021-1.assets/20190226211057731.png" alt="img" /></p><p>本书介绍了Python在各个领域的一些技术和方法，从基本字符、文件序列、字典和排序到高级面向对象编程、数据库和数据持久性、XML处理和Web编程，到高级和抽象的描述符、修饰器、元类、迭代器和生成器。但是这本书很重，你可以把它放在你的手上阅读，书中有很多经验，当你的思想被阻塞时会给你灵感。</p><h3 id="6爱上python一日精通python"><a class="markdownIt-Anchor" href="#6爱上python一日精通python"></a> 6.爱上Python一日精通Python</h3><p>本书将复杂的概念分解为简单的步骤，以确保没有编程经验的读者能够轻松掌握Python。本书中讨论的所有概念都通过精心选择的Python示例进行了说明。</p><p>其实不论什么书籍，只要你多练多写项目多思考就一定能进步，不同的书籍适合不同人，总之一句话我们要付出努力才能有收获。</p><p><img src="/images/python2021-1.assets/6.png" alt="img" /></p><h2 id="python-学习路线"><a class="markdownIt-Anchor" href="#python-学习路线"></a> Python 学习路线</h2><h3 id="前言-2"><a class="markdownIt-Anchor" href="#前言-2"></a> 前言</h3><p>一直以来都有很多想学习Python的朋友们问我，学Python怎么学？爬虫和数据分析怎么学？web开发的学习路线能教教我吗？</p><p>我先告诉大家一个点，不管你是报了什么培训班，还是自己在通过各种渠道自学，你一定要注重一个东西：完整的知识体系。</p><p>感觉很迷茫？学了一段时间还是不入流？很大一部分原因是因为你没有一个完整的知识体系，你不知道自己现在的进度、未来的方向。</p><p>端午三天，虽然回了乡下，但还是抽时间去做了Python所有方向的学习路线，今天分享给大家。</p><h3 id="一-python入门"><a class="markdownIt-Anchor" href="#一-python入门"></a> 一、Python入门</h3><p>初学者都会比较好奇，学了这么久Python，什么程度才叫入门了呢？</p><p>每个人对技术的认知都不尽相同，在我个人看来，你学完以下这些东西就可以算是入门了，为什么？因为以下这些东西是Python进阶各个方向都必备的基础知识，你进阶去学爬虫或者web开发等方向，你都得先学会它们。</p><p>因为知识点放在一起比较多，我把它们稍加区分成基础和高级编程两块，对于每一个自学的人，按照这个体系去打好基础，你未来的路会走得更稳重。</p><p>适用人群：零基础/基础不扎实者，学Python都从这里开始</p><p><img src="/images/python2021-1.assets/01.png" alt="在这里插入图片描述" /></p><p><img src="/images/python2021-1.assets/02.png" alt="在这里插入图片描述" /></p><h3 id="二-爬虫"><a class="markdownIt-Anchor" href="#二-爬虫"></a> 二、爬虫</h3><p>爬虫作为一个热门的方向，不管是在自己兼职还是当成辅助技能提高工作效率，都是很不错的选择，当然了，还有一些以此为主职业的爬虫工程师。</p><p>那么爬虫怎么学习才能成体系？中级水平的爬虫所需要的东西不是很多，参考这个体系去学习，如果能掌握90%,你可以很自信地说你已经精通爬虫。</p><p>适用人群：爬虫方向/数据分析方向/非程序员加薪</p><p><img src="/images/python2021-1.assets/03.png" alt="在这里插入图片描述" /></p><h3 id="三-数据分析"><a class="markdownIt-Anchor" href="#三-数据分析"></a> 三、数据分析</h3><p>谁都知道数据是这个时代最为宝贵的东西，但有一个前提就是，你拿到的数据你得懂，一切发挥不出应有功效的数据都是垃圾数据。</p><p>数据分析的使命就是发挥数据应有的作用：直接作用和间接作用。</p><p>如果你是从事大数据相关工作的IT人士，我建议你掌握但不要止步于下面的数据体系，不要以为会了Numpy、Pandas、Matplotlib就是会了数据分析，真正强大的东西还在后面。</p><p>如果你是把数据分析当成一个辅助技能，那么学完下面这些就差不多，它们能满足你大多数的需求。有些小伙伴可能还是非计算机专业且从事非IT类的工作，比如说运营之类的岗位，那么我建议大家学Python入门+爬虫+数据分析就可以了，它们足以提升你在职场的工作效率，不用去全栈、测试等方向浪费时间，对你没什么大的帮助。</p><p>适用人群：爬虫方向/数据分析方向/非程序员加薪</p><p><img src="/images/python2021-1.assets/04.png" alt="在这里插入图片描述" /></p><h3 id="四-web开发前后端"><a class="markdownIt-Anchor" href="#四-web开发前后端"></a> 四、web开发（前/后端）</h3><p>web开发是程序员职业中的热门，目前来讲，人才缺口依然很大。web开发分为前端、后端、全栈3个方向，目前国内主流的还是前后端分离，前端主要考虑用户体验，后端主要考虑底层业务逻辑、平台稳定和性能，最主要是要看你想做哪一部分？你是喜欢做用户看得见的部分，还是考虑用户看不见的部分。</p><p>至于全栈，舆论一直很大，褒贬不一，我的建议是如果时间和精力允许，在技术上追求更全面是不会错的。</p><p>适用人群：前端/后端/全栈工程师</p><p><img src="/images/python2021-1.assets/05.png" alt="在这里插入图片描述" /></p><p><img src="/images/python2021-1.assets/06.png" alt="在这里插入图片描述" /></p><h3 id="五-自动化测试"><a class="markdownIt-Anchor" href="#五-自动化测试"></a> 五、自动化测试</h3><p>自动化测试已是未来的一种趋势，现在很多的企业都要求程序员具备自动化测试的能力，而对于自动化测试这个领域来讲，Python是目前最合适的语言。</p><p>适用人群：程序员/测试工程师</p><p><img src="/images/python2021-1.assets/07.png" alt="在这里插入图片描述" /></p><h3 id="六-机器学习"><a class="markdownIt-Anchor" href="#六-机器学习"></a> 六、机器学习</h3><p>机器学习是通往人工智能的必经之路，难度也比前面的大很多，与算法打交道是家常便饭，高付出也会带来高回报，薪资待遇很不错。虽然Python在这方面确实很强，但提醒大家一点，这个领域的门槛比较高，本科生基本无缘，建议上了硕士以上学历再考虑进入这个行业。</p><p><img src="/images/python2021-1.assets/08.png" alt="在这里插入图片描述" /></p><h3 id="寄语"><a class="markdownIt-Anchor" href="#寄语"></a> 寄语</h3><p>上面就是Python所有方向的学习路线了，把你感兴趣的方向掌握了90%之后，你去找工作不是什么问题的。</p><p>有些细心的朋友可能会发现，我没放人工智能的学习路线。说实在的，人工智能比机器学习要广泛很多，它已经不是某一门语言就能单独完成的事情了，所以这里不做推荐。</p><p>同样的，网络安全工程师我也没有放进去谈，虽然Python也能做网络安全方面的事情，但对于一个成熟的网络安全工程师甚至红、H客而言，你需要精通的语言可不止1门而已了，又或者说，这已经不是语言工具层面的问题了。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li>CSDN. python爬虫学习: 推荐大家6本Python入门书籍. <a href="https://blog.csdn.net/qq_39363022/article/details/87949392">https://blog.csdn.net/qq_39363022/article/details/87949392</a></li><li>CSDN. 退休的龙叔: Python所有方向的学习路线，你们要的知识体系在这，千万别做了无用功. <a href="https://blog.csdn.net/zhiguigu/article/details/117924606">https://blog.csdn.net/zhiguigu/article/details/117924606</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐大家6本python入门书籍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#推荐大家6本python入门书籍&quot;&gt;&lt;/a&gt; 推荐大家6本Python入门书籍&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-</summary>
      
    
    
    
    <category term="技术博客" scheme="https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 指南 (turtle)</title>
    <link href="https://sumsc-caa.github.io/2021/10/02/python2021-turtle/"/>
    <id>https://sumsc-caa.github.io/2021/10/02/python2021-turtle/</id>
    <published>2021-10-02T07:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>Python turtle 参考资料</p><ul><li><a href="https://blog.csdn.net/sandalphon4869/article/details/99443949?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pythontuttle%E5%85%A5%E9%97%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-99443949.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">入门</a></li><li><a href="https://blog.csdn.net/qq_38851184/article/details/104973288?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163212833516780261951206%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163212833516780261951206&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104973288.first_rank_v2_pc_rank_v29&amp;utm_term=python%E7%94%A8turtle%E5%AE%9E%E4%BE%8B&amp;spm=1018.2226.3001.4187">实例</a></li><li><a href="https://blog.csdn.net/minshiwang/article/details/104482160?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163212866516780262557989%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163212866516780262557989&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-6-104482160.first_rank_v2_pc_rank_v29&amp;utm_term=%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F&amp;spm=1018.2226.3001.4187">色彩模式</a></li><li><a href="https://blog.csdn.net/heyuchang666/article/details/41812275?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163212866516780262557989%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163212866516780262557989&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-41812275.first_rank_v2_pc_rank_v29&amp;utm_term=%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F&amp;spm=1018.2226.3001.4187">RGB色彩模式</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python turtle 参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/sandalphon4869/article/details/99443949?ops_request_misc=&amp;amp;request_id=&amp;</summary>
      
    
    
    
    <category term="技术博客" scheme="https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 指南 (2)</title>
    <link href="https://sumsc-caa.github.io/2021/10/02/python2021-2/"/>
    <id>https://sumsc-caa.github.io/2021/10/02/python2021-2/</id>
    <published>2021-10-02T07:00:00.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-python"><a class="markdownIt-Anchor" href="#什么是-python"></a> 什么是 Python</h3><p>Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。</p><p>Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print absolute value of an integer:</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(-a)</span><br></pre></td></tr></table></figure><p>以<code>#</code>开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</p><p>缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的惯例，应该始终坚持使用<em>4个空格</em>的缩进。</p><p>缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。</p><p>缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。</p><p>最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。</p><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><h4 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h4><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：<code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p><p>对于很大的数，例如<code>10000000000</code>，很难数清楚0的个数。Python允许在数字中间以<code>_</code>分隔，因此，写成<code>10_000_000_000</code>和<code>10000000000</code>是完全一样的。十六进制数也可以写成<code>0xa1b2_c3d4</code>。</p><h4 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h4><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code>1.23e9</code>，或者<code>12.3e8</code>，0.000012可以写成<code>1.2e-5</code>，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h4 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h4><p>字符串是以单引号<code>'</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>'abc'</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>''</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>'abc'</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>'</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I'm OK&quot;</code>包含的字符是<code>I</code>，<code>'</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p><p>如果字符串内部既包含<code>'</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;</span></span><br></pre></td></tr></table></figure><p>表示的字符串内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m &quot;OK&quot;!</span><br></pre></td></tr></table></figure><p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>，可以在Python的交互式命令行用<code>print()</code>打印字符串看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;I\&#x27;m ok.&#x27;)</span><br><span class="line">I&#x27;m ok.</span><br><span class="line">&gt;&gt;&gt; print(&#x27;I\&#x27;m learning\nPython.&#x27;)</span><br><span class="line">I&#x27;m learning</span><br><span class="line">Python.</span><br><span class="line">&gt;&gt;&gt; print(&#x27;\\\n\\&#x27;)</span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r''</code>表示<code>''</code>内部的字符串默认不转义，可以自己试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;\\\t\\&#x27;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&#x27;\\\t\\&#x27;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>'''...'''</code>的格式表示多行内容，可以自己试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;&#x27;&#x27;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&#x27;&#x27;&#x27;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入，注意<code>...</code>是提示符，不是代码的一部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt - python                           _ □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│&gt;&gt;&gt; print(&#x27;&#x27;&#x27;line1                                      │</span><br><span class="line">│... line2                                               │</span><br><span class="line">│... line3&#x27;&#x27;&#x27;)                                           │</span><br><span class="line">│line1                                                   │</span><br><span class="line">│line2                                                   │</span><br><span class="line">│line3                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│&gt;&gt;&gt; _                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>当输入完结束符`````和括号<code>)</code>后，执行该语句并打印结果。</p><p>如果写成程序并存为<code>.py</code>文件，就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;&#x27;&#x27;line1</span><br><span class="line">line2</span><br><span class="line">line3&#x27;&#x27;&#x27;)</span><br></pre></td></tr></table></figure><h4 id="布尔值"><a class="markdownIt-Anchor" href="#布尔值"></a> 布尔值</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 5</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p><code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True and True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; False and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True or True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True or False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False or False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; not True</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; not 1 &gt; 2</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>布尔值经常用在条件判断中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&#x27;adult&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;teenager&#x27;)</span><br></pre></td></tr></table></figure><h4 id="空值"><a class="markdownIt-Anchor" href="#空值"></a> 空值</h4><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br></pre></td></tr></table></figure><p>变量<code>a</code>是一个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_007 = &#x27;T007&#x27;</span><br></pre></td></tr></table></figure><p>变量<code>t_007</code>是一个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Answer = True</span><br></pre></td></tr></table></figure><p>变量<code>Answer</code>是一个布尔值<code>True</code>。</p><p>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。</p><p>这种变量本身类型不固定的语言称之为<em>动态语言</em>，与之对应的是<em>静态语言</em>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 123; // a是整数类型变量</span><br><span class="line">a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure><p>和静态语言相比，动态语言更灵活，就是这个原因。</p><p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line">x = x + 2</span><br></pre></td></tr></table></figure><p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p><p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;ABC&#x27;</span><br></pre></td></tr></table></figure><p>时，Python解释器干了两件事情：</p><ol><li>在内存中创建了一个<code>'ABC'</code>的字符串；</li><li>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。</li></ol><p>也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据。</p><p>最后一行打印出变量<code>b</code>的内容到底是<code>'ABC'</code>呢还是<code>'XYZ'</code>？如果从数学意义上理解，就会错误地得出<code>b</code>和<code>a</code>相同，也应该是<code>'XYZ'</code>，但实际上<code>b</code>的值是<code>'ABC'</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p><p>执行<code>a = 'ABC'</code>，解释器创建了字符串<code>'ABC'</code>和变量<code>a</code>，并把<code>a</code>指向<code>'ABC'</code>：</p><p><img src="/images/python2021-2.assets/1.png" alt="py-var-code-1" /></p><p>执行<code>b = a</code>，解释器创建了变量<code>b</code>，并把<code>b</code>指向<code>a</code>指向的字符串<code>'ABC'</code>：</p><p><img src="/images/python2021-2.assets/2.png" alt="py-var-code-2" /></p><p>执行<code>a = 'XYZ'</code>，解释器创建了字符串’XYZ’，并把<code>a</code>的指向改为<code>'XYZ'</code>，但<code>b</code>并没有更改：</p><p><img src="/images/python2021-2.assets/3.png" alt="py-var-code-3" /></p><p>所以，最后打印变量<code>b</code>的结果自然是<code>'ABC'</code>了。</p><h3 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = 3.14159265359</span><br></pre></td></tr></table></figure><p>但事实上<code>PI</code>仍然是一个变量，Python根本没有任何机制保证<code>PI</code>不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量<code>PI</code>的值，也没人能拦住你。</p><p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure><p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure><p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p><p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 % 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>无论整数做<code>//</code>除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p><h3 id="字符编码"><a class="markdownIt-Anchor" href="#字符编码"></a> 字符编码</h3><p>我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</p><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到<code>Shift_JIS</code>里，韩国把韩文编到<code>Euc-kr</code>里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><p>因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p><p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>'0'</code>和整数<code>0</code>是不同的；</p><p>汉字<code>中</code>已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p><p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">ASCII</th><th style="text-align:left">Unicode</th><th style="text-align:left">UTF-8</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left">01000001</td><td style="text-align:left">00000000 01000001</td><td style="text-align:left">01000001</td></tr><tr><td style="text-align:left">中</td><td style="text-align:left">x</td><td style="text-align:left">01001110 00101101</td><td style="text-align:left">11100100 10111000 10101101</td></tr></tbody></table><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p><img src="/images/python2021-2.assets/4.png" alt="rw-file-utf-8" /></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="/images/python2021-2.assets/5.png" alt="web-utf-8" /></p><p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><h3 id="python的字符串"><a class="markdownIt-Anchor" href="#python的字符串"></a> Python的字符串</h3><p>搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。</p><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;包含中文的str&#x27;)</span><br><span class="line">包含中文的str</span><br></pre></td></tr></table></figure><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&#x27;A&#x27;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&#x27;中&#x27;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&#x27;B&#x27;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&#x27;文&#x27;</span><br></pre></td></tr></table></figure><p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;\u4e2d\u6587&#x27;</span><br><span class="line">&#x27;中文&#x27;</span><br></pre></td></tr></table></figure><p>两种写法完全是等价的。</p><p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b&#x27;ABC&#x27;</span><br></pre></td></tr></table></figure><p>要注意区分<code>'ABC'</code>和<code>b'ABC'</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</p><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)</span><br><span class="line">b&#x27;ABC&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)</span><br><span class="line">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;ascii&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</p><p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)</span><br><span class="line">&#x27;ABC&#x27;</span><br><span class="line">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;.decode(&#x27;utf-8&#x27;)</span><br><span class="line">&#x27;中文&#x27;</span><br></pre></td></tr></table></figure><p>如果<code>bytes</code>中包含无法解码的字节，<code>decode()</code>方法会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 3: invalid start byte</span><br></pre></td></tr></table></figure><p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors='ignore'</code>忽略错误的字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;\xe4\xb8\xad\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)</span><br><span class="line">&#x27;中&#x27;</span><br></pre></td></tr></table></figure><p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&#x27;中文&#x27;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><p>申明了UTF-8编码并不意味着你的<code>.py</code>文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：</p><p><img src="/images/python2021-2.assets/1008802356788736.png" alt="set-encoding-in-notepad++" /></p><p>如果<code>.py</code>文件本身使用UTF-8编码，并且也申明了<code># -*- coding: utf-8 -*-</code>，打开命令提示符测试就可以正常显示中文：</p><p><img src="/images/python2021-2.assets/1008802515054144.png" alt="py-chinese-test-in-cmd" /></p><h4 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h4><p>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似<code>'亲爱的xxx你好！你xx月的话费是xx，余额是xx'</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p><p>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Hello, %s&#x27; % &#x27;world&#x27;</span><br><span class="line">&#x27;Hello, world&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)</span><br><span class="line">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></pre></td></tr></table></figure><p>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p><p>常见的占位符有：</p><table><thead><tr><th style="text-align:left">占位符</th><th style="text-align:left">替换内容</th></tr></thead><tbody><tr><td style="text-align:left">%d</td><td style="text-align:left">整数</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">浮点数</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">字符串</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%2d-%02d&#x27;</span> % (<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">3.1415926</span>)</span><br></pre></td></tr></table></figure><p>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Age: %s. Gender: %s&#x27; % (25, True)</span><br><span class="line">&#x27;Age: 25. Gender: True&#x27;</span><br></pre></td></tr></table></figure><p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;growth rate: %d %%&#x27; % 7</span><br><span class="line">&#x27;growth rate: 7 %&#x27;</span><br></pre></td></tr></table></figure><h5 id="format"><a class="markdownIt-Anchor" href="#format"></a> format()</h5><p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125)</span><br><span class="line">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></pre></td></tr></table></figure><h5 id="f-string"><a class="markdownIt-Anchor" href="#f-string"></a> f-string</h5><p>最后一种格式化字符串的方法是使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>&#123;xxx&#125;</code>，就会以对应的变量替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = 2.5</span><br><span class="line">&gt;&gt;&gt; s = 3.14 * r ** 2</span><br><span class="line">&gt;&gt;&gt; print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;)</span><br><span class="line">The area of a circle with radius 2.5 is 19.62</span><br></pre></td></tr></table></figure><p>上述代码中，<code>&#123;r&#125;</code>被变量<code>r</code>的值替换，<code>&#123;s:.2f&#125;</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>&#123;s:.2f&#125;</code>的替换结果是<code>19.62</code>。</p><h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>比如，列出班里所有同学的名字，就可以用一个list表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure><p>变量<code>classmates</code>就是一个list。用<code>len()</code>函数可以获得list元素的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(classmates)</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>用索引来访问list中每一个位置的元素，记得索引是从<code>0</code>开始的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[0]</span><br><span class="line">&#x27;Michael&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[1]</span><br><span class="line">&#x27;Bob&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[2]</span><br><span class="line">&#x27;Tracy&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><p>当索引超出了范围时，Python会报一个<code>IndexError</code>错误，所以，要确保索引不要越界，记得最后一个元素的索引是<code>len(classmates) - 1</code>。</p><p>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-1]</span><br><span class="line">&#x27;Tracy&#x27;</span><br></pre></td></tr></table></figure><p>以此类推，可以获取倒数第2个、倒数第3个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-2]</span><br><span class="line">&#x27;Bob&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[-3]</span><br><span class="line">&#x27;Michael&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[-4]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><p>当然，倒数第4个就越界了。</p><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br></pre></td></tr></table></figure><p>也可以把元素插入到指定的位置，比如索引号为<code>1</code>的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br></pre></td></tr></table></figure><p>要删除list末尾的元素，用<code>pop()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&#x27;Adam&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure><p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop(1)</span><br><span class="line">&#x27;Jack&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[1] = &#x27;Sarah&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure><p>list里面的元素的数据类型也可以不同，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Apple&#x27;, 123, True]</span><br></pre></td></tr></table></figure><p>list元素也可以是另一个list，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>要注意<code>s</code>只有4个元素，其中<code>s[2]</code>又是一个list，如果拆开写就更容易理解了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = [&#x27;asp&#x27;, &#x27;php&#x27;]</span><br><span class="line">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, p, &#x27;scheme&#x27;]</span><br></pre></td></tr></table></figure><p>要拿到<code>'php'</code>可以写<code>p[1]</code>或者<code>s[2][1]</code>，因此<code>s</code>可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p><p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; len(L)</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h3><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</span><br></pre></td></tr></table></figure><p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用<code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p><p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure><p>如果要定义一个空的tuple，可以写成<code>()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">()</span><br></pre></td></tr></table></figure><p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p><p>最后来看一个“可变的”tuple：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;])</span><br></pre></td></tr></table></figure><p>这个tuple定义的时候有3个元素，分别是<code>'a'</code>，<code>'b'</code>和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</p><p>别急，我们先看看定义的时候tuple包含的3个元素：</p><p><img src="/images/python2021-2.assets/6.png" alt="tuple-0" /></p><p>当我们把list的元素<code>'A'</code>和<code>'B'</code>修改为<code>'X'</code>和<code>'Y'</code>后，tuple变为：</p><p><img src="/images/python2021-2.assets/0.png" alt="tuple-1" /></p><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>'a'</code>，就不能改成指向<code>'b'</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p><h3 id="dict"><a class="markdownIt-Anchor" href="#dict"></a> dict</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">scores = [95, 75, 85]</span><br></pre></td></tr></table></figure><p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</p><p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Michael&#x27;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure><p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p><p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p><p>dict就是第二种实现方式，给定一个名字，比如<code>'Michael'</code>，dict在内部就可以直接计算出<code>Michael</code>对应的存放成绩的“页码”，也就是<code>95</code>这个数字存放的内存地址，直接取出来，所以速度非常快。</p><p>你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</p><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Adam&#x27;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Adam&#x27;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 90</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 88</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure><p>如果key不存在，dict就会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Thomas&#x27;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#x27;Thomas&#x27;</span><br></pre></td></tr></table></figure><p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Thomas&#x27; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;)</span><br><span class="line">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#x27;Bob&#x27;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span><br></pre></td></tr></table></figure><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>所以，dict是用空间来换取时间的一种方法。</p><p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p><p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p><p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] = &#x27;a list&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure><h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>&#123;1, 2, 3&#125;</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p><p>重复元素在set中自动被过滤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>通过<code>remove(key)</code>方法可以删除元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p><h3 id="再议不可变对象"><a class="markdownIt-Anchor" href="#再议不可变对象"></a> 再议不可变对象</h3><p>上面我们讲了，str是不变对象，而list是可变对象。</p><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>而对于不可变对象，比如str，对str进行操作呢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a.replace(&#x27;a&#x27;, &#x27;A&#x27;)</span><br><span class="line">&#x27;Abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;abc&#x27;</span><br></pre></td></tr></table></figure><p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>'Abc'</code>，但变量<code>a</code>最后仍是<code>'abc'</code>，应该怎么理解呢？</p><p>我们先把代码改成下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; b = a.replace(&#x27;a&#x27;, &#x27;A&#x27;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#x27;Abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;abc&#x27;</span><br></pre></td></tr></table></figure><p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ a │─────────────────&gt;│ &#x27;abc&#x27; │</span><br><span class="line">└───┘                  └───────┘</span><br></pre></td></tr></table></figure><p>当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ a │─────────────────&gt;│ &#x27;abc&#x27; │</span><br><span class="line">└───┘                  └───────┘</span><br><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ b │─────────────────&gt;│ &#x27;Abc&#x27; │</span><br><span class="line">└───┘                  └───────┘</span><br></pre></td></tr></table></figure><p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><h3 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h3><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用<code>if</code>语句实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br></pre></td></tr></table></figure><p>根据Python的缩进规则，如果<code>if</code>语句判断是<code>True</code>，就把缩进的两行print语句执行了，否则，什么也不做。</p><p>也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;your age is&#x27;</span>, age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意不要少写了冒号<code>:</code>。</p><p>当然上面的判断是很粗略的，完全可以用<code>elif</code>做更细致的判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code>，所以<code>if</code>语句的完整形式就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code>，所以，请测试并解释为什么下面的程序打印的是<code>teenager</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>if</code>判断条件还可以简写，比如写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</span><br></pre></td></tr></table></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h3 id="再议-input"><a class="markdownIt-Anchor" href="#再议-input"></a> 再议 input</h3><p>最后看一个有问题的条件判断。很多同学会用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">birth = <span class="built_in">input</span>(<span class="string">&#x27;birth: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输入<code>1982</code>，结果报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unorderable types: str() &gt; int()</span><br></pre></td></tr></table></figure><p>这是因为<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&#x27;birth: &#x27;</span>)</span><br><span class="line">birth = <span class="built_in">int</span>(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</span><br></pre></td></tr></table></figure><p>再次运行，就可以得到正确地结果。但是，如果输入<code>abc</code>呢？又会得到一个错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: invalid literal for int() with base 10: &#x27;abc&#x27;</span><br></pre></td></tr></table></figure><p>原来<code>int()</code>函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p><h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3><p>要计算1+2+3，我们可以直接写表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2 + 3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>要计算1+2+3+…+10，勉强也能写出来。</p><p>但是，要计算1+2+3+…+10000，直接写表达式就不可能了。</p><p>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</p><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p>执行这段代码，会依次打印<code>names</code>的每一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure><p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p><p>再比如我们想计算1-10的整数之和，可以用一个<code>sum</code>变量做累加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p><code>range(101)</code>就可以生成0-100的整数序列，计算如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">5050</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出。</p><h4 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h4><p>在循环中，<code>break</code>语句可以提前退出循环。例如，本来要循环打印1～100的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码可以打印出1~100。</p><p>如果要提前结束循环，可以用<code>break</code>语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行上面的代码可以看到，打印出1~10后，紧接着打印<code>END</code>，程序结束。</p><p>可见<code>break</code>的作用是提前结束循环。</p><h4 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h4><p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用<code>continue</code>语句跳过某些循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。</p><p>可见<code>continue</code>的作用是提前结束本轮循环，并直接开始下一轮循环。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li>廖雪峰的Python教程. <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/">https://www.liaoxuefeng.com/wiki/1016959663602400/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是-python&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-python&quot;&gt;&lt;/a&gt; 什么是 Python&lt;/h3&gt;
&lt;p&gt;Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是</summary>
      
    
    
    
    <category term="技术博客" scheme="https://sumsc-caa.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Python" scheme="https://sumsc-caa.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机爱好者协会2021招新宣传文案</title>
    <link href="https://sumsc-caa.github.io/2021/09/29/caa2021/"/>
    <id>https://sumsc-caa.github.io/2021/09/29/caa2021/</id>
    <published>2021-09-29T16:32:49.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>又到了开学季，小21们就要来到美丽的苏大校园啦~</p><p>别急，俱乐部宣传这就来啦~</p><p><img src="/images/caa2021.assets/clip_image002.jpg" alt="img" /></p><h3 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h3><p>我们是苏州大学计算机爱好者协会——苏州大学计算机科学与技术学院的学术性社团，成立于2004年，原苏州大学微软学生俱乐部（2015年苏计算机科学与技术学院与微软亚洲研究院联合成立），现为微软开源学习社群的联络社团。</p><p><img src="/images/caa2021.assets/images_20201025_165716.jpg" alt="IMG_20201025_165716" /></p><p>我们是一个充满热情，富有开拓精神的新锐团体，在对技术保持的严谨的同时也不缺乏乐观活泼的生活态度。</p><h3 id="我们的理念"><a class="markdownIt-Anchor" href="#我们的理念"></a> 我们的理念</h3><p>我们本着“学习先进技术，开拓创新思维，体验多元文化，成就一流人才”的宗旨，线上开源社群与线下技术学习相结合，线上通过课程共建、知识共享、团队共创，培养社团成员的开源思想、创新头脑、实践能力和组织能力，助力所有学生从开源社区同获益、共成长；线下通过学术讲座、技术沙龙、兴趣小组、大型比赛、参观访问等活动，为会员提供开阔视野，探索前沿IT技术，接触最新学术成果，培养管理能力的机会，培养会员的创新头脑、实践能力和组织能力，让来自不同领域的同学得以展现才华，共同成长。我们的使命是为学生的成长提供良好的平台，为高校顶尖人才培养贡献一份力量。</p><p><strong>“予力每一位俱乐部成员，成就非凡！”</strong></p><h3 id="精彩回顾"><a class="markdownIt-Anchor" href="#精彩回顾"></a> 精彩回顾</h3><p><img src="/images/caa2021.assets/mmexport1627965703070.jpg" alt="mmexport1627965703070" /></p><p><img src="/images/caa2021.assets/images_20210414_202535.jpg" alt="IMG_20210414_202535" /></p><p><img src="/images/caa2021.assets/images_20201023_183714.jpg" alt="IMG_20201023_183714" /></p><p>在这里，你们可以学到许许多多课本以外的知识，可以提升实际工程能力，还可以探讨学术问题，无论是coding，还是科研，亦或是美工，甚至是团建……在这里，你总能发现不一样的你。</p><h3 id="精彩活动"><a class="markdownIt-Anchor" href="#精彩活动"></a> 精彩活动</h3><h4 id="python讲座"><a class="markdownIt-Anchor" href="#python讲座"></a> Python讲座</h4><p>Python是当前最流行的计算机编程语言之一，也是我们学校计算机相关专业同学的大一必修课程。但初入大学校园的你对这门课程是不是有着一丝疑虑？</p><p>别担心，我们为大家准备了一份开学大礼。Python讲座由计算机学院精通编程之道的高年级学长学姐主讲，不仅会系统性的为大家讲解Python这门语言，而且会与同学们深入交流学习计算机语言的过程中遇到的问题，为大家答疑解惑。</p><p><img src="/images/caa2021.assets/image-20210929171922251.png" alt="image-20210929171922251" /></p><h4 id="hackathon编程马拉松"><a class="markdownIt-Anchor" href="#hackathon编程马拉松"></a> Hackathon（编程马拉松）</h4><p>Hackathon是流传于电脑迷中的一种活动，你需要做的是和你的队友在有限的时间内，将一个个奇思妙想以编程的方式来实现，最令人兴奋的是，整个编程的过程几乎没有任何限制或者方向。在Hackathon中，享受不断挑战自己，超越自己的快感吧！</p><p><img src="/images/caa2021.assets/images_20201025_154614.jpg" alt="IMG_20201025_154614" /></p><p><img src="/images/caa2021.assets/images_20201024_103732.jpg" alt="IMG_20201024_103732" /></p><p><img src="/images/caa2021.assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%88%B1%E5%A5%BD%E8%80%85%E5%8D%8F%E4%BC%9A-%E7%85%A7%E7%89%872.jpg" alt="" /></p><h4 id="技术沙龙技术分享会"><a class="markdownIt-Anchor" href="#技术沙龙技术分享会"></a> 技术沙龙&amp;技术分享会</h4><p>你是否对最新IT技术、前沿学术成果充满向往？今年开始，计算机爱好者协会将进一步拓宽技术沙龙与技术分享会的领域范围。在这里，你可以与高年级/研究生学长学姐、各高校微软学生俱乐部大佬、微软亚研院科研大牛探讨学术问题，助力同学们的工程能力与科研水平的提升！</p><p><img src="/images/caa2021.assets/image-20210929172205394.png" alt="image-20210929172205394" /></p><h4 id="mosc-开源讲座"><a class="markdownIt-Anchor" href="#mosc-开源讲座"></a> MOSC 开源讲座</h4><p>微软开源学习社群（<strong>M</strong>icrosoft <strong>O</strong>pen-source <strong>S</strong>tudy <strong>C</strong>ommunity）脱胎于原微软学生俱乐部，是微软亚洲研究院对高校人才培养的<strong>进一步探索</strong>。在这里，你可以参与到双一流高校高年级学生的直播中来，参与学习由社群共创的课程，分享自己的技术与感受……</p><p><img src="/images/caa2021.assets/image-20210929174836183.png" alt="image-20210929174836183" /></p><h4 id="其他活动"><a class="markdownIt-Anchor" href="#其他活动"></a> 其他活动</h4><p>除此之外，俱乐部还会定期举办其他精彩的活动，比如破冰行动，编程挑战赛，魔盒挑战，假期充电站，参观苏州微软，前往其它高校交流学习，甚至与南航开展王者荣耀友谊赛。优秀的你也有机会获得微软亚研院内推的名额~</p><p><img src="/images/caa2021.assets/images_20210414_192716.jpg" alt="IMG_20210414_192716" /></p><p><img src="/images/caa2021.assets/images_20210414_211536.jpg" alt="IMG_20210414_211536" /></p><p><img src="/images/caa2021.assets/mmexport1627965691200.jpg" alt="mmexport1627965691200" /></p><p><img src="/images/caa2021.assets/mmexport1627965025961.jpg" alt="mmexport1627965025961" /></p><p><img src="/images/caa2021.assets/mmexport1627965601129.jpg" alt="mmexport1627965601129" /></p><p><img src="/images/caa2021.assets/mmexport1627965212608.jpg" alt="mmexport1627965212608" /></p><p><img src="/images/caa2021.assets/mmexport1627965202489.jpg" alt="mmexport1627965202489" /></p><h3 id="组织架构"><a class="markdownIt-Anchor" href="#组织架构"></a> 组织架构</h3><p>俱乐部共有三个部门，以及若干技术大佬。俱乐部各部门内采用工作组制度，每位同学可以选择加入至少一个部门（工作组）。</p><ul><li><strong>运营部</strong>主要负责活动的准备和执行、调动社团积极性和活跃度，也负责人员培训与考核工作，包括准备活动所需要的物资等等。同时运营部还负责社团的财务工作。</li><li><strong>市场部</strong>负责社团对外形象的树立和宣传推广，设计并执行品牌运营方案，在社团的各项活动中进行品牌把关。同时进行公众号运营等宣传工作。</li><li><strong>行政部</strong>主要职能为策划和组织社团内的各种活动，协调各部门促进活动的完满成功，同时也负责对实验室的日常管理工作，以及运营俱乐部Bilibili官方账号。</li><li><strong>技术组</strong>主持社团技术分享，承担社团项目开发，为社团举办活动提供相关技术支持。既是计算机爱好者协会的核心，也是我们的灵感来源。</li></ul><p><img src="/images/caa2021.assets/images_20210619_190002.jpg" alt="IMG_20210619_190002" /></p><h3 id="关于我们"><a class="markdownIt-Anchor" href="#关于我们"></a> 关于我们</h3><p>听说有童鞋担心自己零基础？</p><p>没事！无论你来自哪个年级，哪个专业，只要你</p><p>有创意 有兴趣 会学习</p><p>就能加入我们！</p><p>在百团大战后，我们将会举办技术交流会（Hackathon）。同学们会在交流会中对我们的定位和性质有一个更深的了解，我们也能从交流会中，发现一批优秀的同学，邀请他们加入社团，与我们一起挑战自我，共同成长。</p><p>在这里，让我们一起用双手将一个个天马行空的想法变成现实！</p><p>在这里，你可以在破冰活动中结识更多志同道合的朋友，在欢笑中增进彼此友谊；你可以在Hackathon中挑战自我，感受头脑风暴的深邃魅力；还可以与全国顶尖高校的同学们切磋学习；还可以参与到微软亚研院组织的学术活动，与科研大牛面对面交流。</p><p>欢迎加入我们的交流QQ群：497516494</p><p>这里有优质学长学姐</p><p>随时为你解答问题！</p><p>在百团大战开始后，我们会在群中开展招新活动。</p><img src="/images/caa2021.assets/clip_image002.png" style="zoom:80%;" /><p>欢迎关注SUMSTC微信公众号，以及社团Bilibili“苏大微软俱乐部”，获取我们的最新消息~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到了开学季，小21们就要来到美丽的苏大校园啦~&lt;/p&gt;
&lt;p&gt;别急，俱乐部宣传这就来啦~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/caa2021.assets/clip_image002.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;自我介绍&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>2021 Python 讲座</title>
    <link href="https://sumsc-caa.github.io/2021/09/23/python2021/"/>
    <id>https://sumsc-caa.github.io/2021/09/23/python2021/</id>
    <published>2021-09-23T13:03:36.000Z</published>
    <updated>2023-02-26T05:39:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>2021 Python 讲座。</p><p><a href="https://mp.weixin.qq.com/s/YjsUm3AVi2pG_Uxk-vSqMg">https://mp.weixin.qq.com/s/YjsUm3AVi2pG_Uxk-vSqMg</a><br /><a href="https://mp.weixin.qq.com/s/UYdl57MdWl5PRpTBA0DbHA">https://mp.weixin.qq.com/s/UYdl57MdWl5PRpTBA0DbHA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021 Python 讲座。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YjsUm3AVi2pG_Uxk-vSqMg&quot;&gt;https://mp.weixin.qq.com/s/YjsUm3AVi2pG_Uxk-vSqMg&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="活动" scheme="https://sumsc-caa.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
  </entry>
  
</feed>
